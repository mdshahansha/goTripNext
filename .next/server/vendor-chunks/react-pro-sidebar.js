"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-pro-sidebar";
exports.ids = ["vendor-chunks/react-pro-sidebar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-pro-sidebar/dist/index.es.js":
/*!*********************************************************!*\
  !*** ./node_modules/react-pro-sidebar/dist/index.es.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   LevelContext: () => (/* binding */ LevelContext),\n/* harmony export */   Menu: () => (/* binding */ Menu),\n/* harmony export */   MenuContext: () => (/* binding */ MenuContext),\n/* harmony export */   MenuItem: () => (/* binding */ MenuItem),\n/* harmony export */   MenuItemFR: () => (/* binding */ MenuItemFR),\n/* harmony export */   ProSidebarProvider: () => (/* binding */ ProSidebarProvider),\n/* harmony export */   Sidebar: () => (/* binding */ Sidebar),\n/* harmony export */   SidebarContext: () => (/* binding */ SidebarContext),\n/* harmony export */   SubMenu: () => (/* binding */ SubMenu),\n/* harmony export */   SubMenuFR: () => (/* binding */ SubMenuFR),\n/* harmony export */   menuClasses: () => (/* binding */ menuClasses),\n/* harmony export */   sidebarClasses: () => (/* binding */ sidebarClasses),\n/* harmony export */   useProSidebar: () => (/* binding */ useProSidebar)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ var __assign = function() {\n    __assign = Object.assign || function __assign(t) {\n        for(var s, i = 1, n = arguments.length; i < n; i++){\n            s = arguments[i];\n            for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __makeTemplateObject(cooked, raw) {\n    if (Object.defineProperty) {\n        Object.defineProperty(cooked, \"raw\", {\n            value: raw\n        });\n    } else {\n        cooked.raw = raw;\n    }\n    return cooked;\n}\nfunction _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function(target) {\n        for(var i = 1; i < arguments.length; i++){\n            var source = arguments[i];\n            for(var key in source){\n                if (Object.prototype.hasOwnProperty.call(source, key)) {\n                    target[key] = source[key];\n                }\n            }\n        }\n        return target;\n    };\n    return _extends.apply(this, arguments);\n}\nfunction memoize(fn) {\n    var cache = Object.create(null);\n    return function(arg) {\n        if (cache[arg] === undefined) cache[arg] = fn(arg);\n        return cache[arg];\n    };\n}\nvar reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/; // https://esbench.com/bench/5bfee68a4cd7e6009ef61d23\nvar isPropValid = /* #__PURE__ */ memoize(function(prop) {\n    return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;\n});\n/*\n\nBased off glamor's StyleSheet, thanks Sunil ❤️\n\nhigh performance StyleSheet for css-in-js systems\n\n- uses multiple style tags behind the scenes for millions of rules\n- uses `insertRule` for appending in production for *much* faster performance\n\n// usage\n\nimport { StyleSheet } from '@emotion/sheet'\n\nlet styleSheet = new StyleSheet({ key: '', container: document.head })\n\nstyleSheet.insert('#box { border: 1px solid red; }')\n- appends a css rule into the stylesheet\n\nstyleSheet.flush()\n- empties the stylesheet of all its contents\n\n*/ // $FlowFixMe\nfunction sheetForTag(tag) {\n    if (tag.sheet) {\n        // $FlowFixMe\n        return tag.sheet;\n    } // this weirdness brought to you by firefox\n    /* istanbul ignore next */ for(var i = 0; i < document.styleSheets.length; i++){\n        if (document.styleSheets[i].ownerNode === tag) {\n            // $FlowFixMe\n            return document.styleSheets[i];\n        }\n    }\n}\nfunction createStyleElement(options) {\n    var tag = document.createElement(\"style\");\n    tag.setAttribute(\"data-emotion\", options.key);\n    if (options.nonce !== undefined) {\n        tag.setAttribute(\"nonce\", options.nonce);\n    }\n    tag.appendChild(document.createTextNode(\"\"));\n    tag.setAttribute(\"data-s\", \"\");\n    return tag;\n}\nvar StyleSheet = /*#__PURE__*/ function() {\n    // Using Node instead of HTMLElement since container may be a ShadowRoot\n    function StyleSheet(options) {\n        var _this = this;\n        this._insertTag = function(tag) {\n            var before;\n            if (_this.tags.length === 0) {\n                if (_this.insertionPoint) {\n                    before = _this.insertionPoint.nextSibling;\n                } else if (_this.prepend) {\n                    before = _this.container.firstChild;\n                } else {\n                    before = _this.before;\n                }\n            } else {\n                before = _this.tags[_this.tags.length - 1].nextSibling;\n            }\n            _this.container.insertBefore(tag, before);\n            _this.tags.push(tag);\n        };\n        this.isSpeedy = options.speedy === undefined ? \"development\" === \"production\" : options.speedy;\n        this.tags = [];\n        this.ctr = 0;\n        this.nonce = options.nonce; // key is the value of the data-emotion attribute, it's used to identify different sheets\n        this.key = options.key;\n        this.container = options.container;\n        this.prepend = options.prepend;\n        this.insertionPoint = options.insertionPoint;\n        this.before = null;\n    }\n    var _proto = StyleSheet.prototype;\n    _proto.hydrate = function hydrate(nodes) {\n        nodes.forEach(this._insertTag);\n    };\n    _proto.insert = function insert(rule) {\n        // the max length is how many rules we have per style tag, it's 65000 in speedy mode\n        // it's 1 in dev because we insert source maps that map a single rule to a location\n        // and you can only have one source map per style tag\n        if (this.ctr % (this.isSpeedy ? 65000 : 1) === 0) {\n            this._insertTag(createStyleElement(this));\n        }\n        var tag = this.tags[this.tags.length - 1];\n        if (true) {\n            var isImportRule = rule.charCodeAt(0) === 64 && rule.charCodeAt(1) === 105;\n            if (isImportRule && this._alreadyInsertedOrderInsensitiveRule) {\n                // this would only cause problem in speedy mode\n                // but we don't want enabling speedy to affect the observable behavior\n                // so we report this error at all times\n                console.error(\"You're attempting to insert the following rule:\\n\" + rule + \"\\n\\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules.\");\n            }\n            this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !isImportRule;\n        }\n        if (this.isSpeedy) {\n            var sheet = sheetForTag(tag);\n            try {\n                // this is the ultrafast version, works across browsers\n                // the big drawback is that the css won't be editable in devtools\n                sheet.insertRule(rule, sheet.cssRules.length);\n            } catch (e) {\n                if ( true && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(rule)) {\n                    console.error('There was a problem inserting the following rule: \"' + rule + '\"', e);\n                }\n            }\n        } else {\n            tag.appendChild(document.createTextNode(rule));\n        }\n        this.ctr++;\n    };\n    _proto.flush = function flush() {\n        // $FlowFixMe\n        this.tags.forEach(function(tag) {\n            return tag.parentNode && tag.parentNode.removeChild(tag);\n        });\n        this.tags = [];\n        this.ctr = 0;\n        if (true) {\n            this._alreadyInsertedOrderInsensitiveRule = false;\n        }\n    };\n    return StyleSheet;\n}();\nvar MS = \"-ms-\";\nvar MOZ = \"-moz-\";\nvar WEBKIT = \"-webkit-\";\nvar COMMENT = \"comm\";\nvar RULESET = \"rule\";\nvar DECLARATION = \"decl\";\nvar IMPORT = \"@import\";\nvar KEYFRAMES = \"@keyframes\";\n/**\n * @param {number}\n * @return {number}\n */ var abs = Math.abs;\n/**\n * @param {number}\n * @return {string}\n */ var from = String.fromCharCode;\n/**\n * @param {object}\n * @return {object}\n */ var assign = Object.assign;\n/**\n * @param {string} value\n * @param {number} length\n * @return {number}\n */ function hash$2(value, length) {\n    return charat(value, 0) ^ 45 ? (((length << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;\n}\n/**\n * @param {string} value\n * @return {string}\n */ function trim(value) {\n    return value.trim();\n}\n/**\n * @param {string} value\n * @param {RegExp} pattern\n * @return {string?}\n */ function match(value, pattern) {\n    return (value = pattern.exec(value)) ? value[0] : value;\n}\n/**\n * @param {string} value\n * @param {(string|RegExp)} pattern\n * @param {string} replacement\n * @return {string}\n */ function replace(value, pattern, replacement) {\n    return value.replace(pattern, replacement);\n}\n/**\n * @param {string} value\n * @param {string} search\n * @return {number}\n */ function indexof(value, search) {\n    return value.indexOf(search);\n}\n/**\n * @param {string} value\n * @param {number} index\n * @return {number}\n */ function charat(value, index) {\n    return value.charCodeAt(index) | 0;\n}\n/**\n * @param {string} value\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function substr(value, begin, end) {\n    return value.slice(begin, end);\n}\n/**\n * @param {string} value\n * @return {number}\n */ function strlen(value) {\n    return value.length;\n}\n/**\n * @param {any[]} value\n * @return {number}\n */ function sizeof(value) {\n    return value.length;\n}\n/**\n * @param {any} value\n * @param {any[]} array\n * @return {any}\n */ function append(value, array) {\n    return array.push(value), value;\n}\n/**\n * @param {string[]} array\n * @param {function} callback\n * @return {string}\n */ function combine(array, callback) {\n    return array.map(callback).join(\"\");\n}\nvar line = 1;\nvar column = 1;\nvar length = 0;\nvar position = 0;\nvar character = 0;\nvar characters = \"\";\n/**\n * @param {string} value\n * @param {object | null} root\n * @param {object | null} parent\n * @param {string} type\n * @param {string[] | string} props\n * @param {object[] | string} children\n * @param {number} length\n */ function node(value, root, parent, type, props, children, length) {\n    return {\n        value: value,\n        root: root,\n        parent: parent,\n        type: type,\n        props: props,\n        children: children,\n        line: line,\n        column: column,\n        length: length,\n        return: \"\"\n    };\n}\n/**\n * @param {object} root\n * @param {object} props\n * @return {object}\n */ function copy(root, props) {\n    return assign(node(\"\", null, null, \"\", null, null, 0), root, {\n        length: -root.length\n    }, props);\n}\n/**\n * @return {number}\n */ function char() {\n    return character;\n}\n/**\n * @return {number}\n */ function prev() {\n    character = position > 0 ? charat(characters, --position) : 0;\n    if (column--, character === 10) column = 1, line--;\n    return character;\n}\n/**\n * @return {number}\n */ function next() {\n    character = position < length ? charat(characters, position++) : 0;\n    if (column++, character === 10) column = 1, line++;\n    return character;\n}\n/**\n * @return {number}\n */ function peek() {\n    return charat(characters, position);\n}\n/**\n * @return {number}\n */ function caret() {\n    return position;\n}\n/**\n * @param {number} begin\n * @param {number} end\n * @return {string}\n */ function slice(begin, end) {\n    return substr(characters, begin, end);\n}\n/**\n * @param {number} type\n * @return {number}\n */ function token(type) {\n    switch(type){\n        // \\0 \\t \\n \\r \\s whitespace token\n        case 0:\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            return 5;\n        // ! + , / > @ ~ isolate token\n        case 33:\n        case 43:\n        case 44:\n        case 47:\n        case 62:\n        case 64:\n        case 126:\n        // ; { } breakpoint token\n        case 59:\n        case 123:\n        case 125:\n            return 4;\n        // : accompanied token\n        case 58:\n            return 3;\n        // \" ' ( [ opening delimit token\n        case 34:\n        case 39:\n        case 40:\n        case 91:\n            return 2;\n        // ) ] closing delimit token\n        case 41:\n        case 93:\n            return 1;\n    }\n    return 0;\n}\n/**\n * @param {string} value\n * @return {any[]}\n */ function alloc(value) {\n    return line = column = 1, length = strlen(characters = value), position = 0, [];\n}\n/**\n * @param {any} value\n * @return {any}\n */ function dealloc(value) {\n    return characters = \"\", value;\n}\n/**\n * @param {number} type\n * @return {string}\n */ function delimit(type) {\n    return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));\n}\n/**\n * @param {number} type\n * @return {string}\n */ function whitespace(type) {\n    while(character = peek())if (character < 33) next();\n    else break;\n    return token(type) > 2 || token(character) > 3 ? \"\" : \" \";\n}\n/**\n * @param {number} index\n * @param {number} count\n * @return {string}\n */ function escaping(index, count) {\n    while(--count && next())// not 0-9 A-F a-f\n    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97) break;\n    return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32));\n}\n/**\n * @param {number} type\n * @return {number}\n */ function delimiter(type) {\n    while(next())switch(character){\n        // ] ) \" '\n        case type:\n            return position;\n        // \" '\n        case 34:\n        case 39:\n            if (type !== 34 && type !== 39) delimiter(character);\n            break;\n        // (\n        case 40:\n            if (type === 41) delimiter(type);\n            break;\n        // \\\n        case 92:\n            next();\n            break;\n    }\n    return position;\n}\n/**\n * @param {number} type\n * @param {number} index\n * @return {number}\n */ function commenter(type, index) {\n    while(next())// //\n    if (type + character === 47 + 10) break;\n    else if (type + character === 42 + 42 && peek() === 47) break;\n    return \"/*\" + slice(index, position - 1) + \"*\" + from(type === 47 ? type : next());\n}\n/**\n * @param {number} index\n * @return {string}\n */ function identifier(index) {\n    while(!token(peek()))next();\n    return slice(index, position);\n}\n/**\n * @param {string} value\n * @return {object[]}\n */ function compile(value) {\n    return dealloc(parse(\"\", null, null, null, [\n        \"\"\n    ], value = alloc(value), 0, [\n        0\n    ], value));\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {string[]} rule\n * @param {string[]} rules\n * @param {string[]} rulesets\n * @param {number[]} pseudo\n * @param {number[]} points\n * @param {string[]} declarations\n * @return {object}\n */ function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {\n    var index = 0;\n    var offset = 0;\n    var length = pseudo;\n    var atrule = 0;\n    var property = 0;\n    var previous = 0;\n    var variable = 1;\n    var scanning = 1;\n    var ampersand = 1;\n    var character = 0;\n    var type = \"\";\n    var props = rules;\n    var children = rulesets;\n    var reference = rule;\n    var characters = type;\n    while(scanning)switch(previous = character, character = next()){\n        // (\n        case 40:\n            if (previous != 108 && charat(characters, length - 1) == 58) {\n                if (indexof(characters += replace(delimit(character), \"&\", \"&\\f\"), \"&\\f\") != -1) ampersand = -1;\n                break;\n            }\n        // \" ' [\n        case 34:\n        case 39:\n        case 91:\n            characters += delimit(character);\n            break;\n        // \\t \\n \\r \\s\n        case 9:\n        case 10:\n        case 13:\n        case 32:\n            characters += whitespace(previous);\n            break;\n        // \\\n        case 92:\n            characters += escaping(caret() - 1, 7);\n            continue;\n        // /\n        case 47:\n            switch(peek()){\n                case 42:\n                case 47:\n                    append(comment(commenter(next(), caret()), root, parent), declarations);\n                    break;\n                default:\n                    characters += \"/\";\n            }\n            break;\n        // {\n        case 123 * variable:\n            points[index++] = strlen(characters) * ampersand;\n        // } ; \\0\n        case 125 * variable:\n        case 59:\n        case 0:\n            switch(character){\n                // \\0 }\n                case 0:\n                case 125:\n                    scanning = 0;\n                // ;\n                case 59 + offset:\n                    if (property > 0 && strlen(characters) - length) append(property > 32 ? declaration(characters + \";\", rule, parent, length - 1) : declaration(replace(characters, \" \", \"\") + \";\", rule, parent, length - 2), declarations);\n                    break;\n                // @ ;\n                case 59:\n                    characters += \";\";\n                // { rule/at-rule\n                default:\n                    append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length), rulesets);\n                    if (character === 123) if (offset === 0) parse(characters, root, reference, reference, props, rulesets, length, points, children);\n                    else switch(atrule === 99 && charat(characters, 3) === 110 ? 100 : atrule){\n                        // d m s\n                        case 100:\n                        case 109:\n                        case 115:\n                            parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length), children), rules, children, length, points, rule ? props : children);\n                            break;\n                        default:\n                            parse(characters, reference, reference, reference, [\n                                \"\"\n                            ], children, 0, points, children);\n                    }\n            }\n            index = offset = property = 0, variable = ampersand = 1, type = characters = \"\", length = pseudo;\n            break;\n        // :\n        case 58:\n            length = 1 + strlen(characters), property = previous;\n        default:\n            if (variable < 1) {\n                if (character == 123) --variable;\n                else if (character == 125 && variable++ == 0 && prev() == 125) continue;\n            }\n            switch(characters += from(character), character * variable){\n                // &\n                case 38:\n                    ampersand = offset > 0 ? 1 : (characters += \"\\f\", -1);\n                    break;\n                // ,\n                case 44:\n                    points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;\n                    break;\n                // @\n                case 64:\n                    // -\n                    if (peek() === 45) characters += delimit(next());\n                    atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;\n                    break;\n                // -\n                case 45:\n                    if (previous === 45 && strlen(characters) == 2) variable = 0;\n            }\n    }\n    return rulesets;\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} index\n * @param {number} offset\n * @param {string[]} rules\n * @param {number[]} points\n * @param {string} type\n * @param {string[]} props\n * @param {string[]} children\n * @param {number} length\n * @return {object}\n */ function ruleset(value, root, parent, index, offset, rules, points, type, props, children, length) {\n    var post = offset - 1;\n    var rule = offset === 0 ? rules : [\n        \"\"\n    ];\n    var size = sizeof(rule);\n    for(var i = 0, j = 0, k = 0; i < index; ++i)for(var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)if (z = trim(j > 0 ? rule[x] + \" \" + y : replace(y, /&\\f/g, rule[x]))) props[k++] = z;\n    return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length);\n}\n/**\n * @param {number} value\n * @param {object} root\n * @param {object?} parent\n * @return {object}\n */ function comment(value, root, parent) {\n    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0);\n}\n/**\n * @param {string} value\n * @param {object} root\n * @param {object?} parent\n * @param {number} length\n * @return {object}\n */ function declaration(value, root, parent, length) {\n    return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length);\n}\n/**\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function serialize(children, callback) {\n    var output = \"\";\n    var length = sizeof(children);\n    for(var i = 0; i < length; i++)output += callback(children[i], i, children, callback) || \"\";\n    return output;\n}\n/**\n * @param {object} element\n * @param {number} index\n * @param {object[]} children\n * @param {function} callback\n * @return {string}\n */ function stringify(element, index, children, callback) {\n    switch(element.type){\n        case IMPORT:\n        case DECLARATION:\n            return element.return = element.return || element.value;\n        case COMMENT:\n            return \"\";\n        case KEYFRAMES:\n            return element.return = element.value + \"{\" + serialize(element.children, callback) + \"}\";\n        case RULESET:\n            element.value = element.props.join(\",\");\n    }\n    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + \"{\" + children + \"}\" : \"\";\n}\n/**\n * @param {function[]} collection\n * @return {function}\n */ function middleware(collection) {\n    var length = sizeof(collection);\n    return function(element, index, children, callback) {\n        var output = \"\";\n        for(var i = 0; i < length; i++)output += collection[i](element, index, children, callback) || \"\";\n        return output;\n    };\n}\n/**\n * @param {function} callback\n * @return {function}\n */ function rulesheet(callback) {\n    return function(element) {\n        if (!element.root) {\n            if (element = element.return) callback(element);\n        }\n    };\n}\nvar weakMemoize = function weakMemoize(func) {\n    // $FlowFixMe flow doesn't include all non-primitive types as allowed for weakmaps\n    var cache = new WeakMap();\n    return function(arg) {\n        if (cache.has(arg)) {\n            // $FlowFixMe\n            return cache.get(arg);\n        }\n        var ret = func(arg);\n        cache.set(arg, ret);\n        return ret;\n    };\n};\nvar identifierWithPointTracking = function identifierWithPointTracking(begin, points, index) {\n    var previous = 0;\n    var character = 0;\n    while(true){\n        previous = character;\n        character = peek(); // &\\f\n        if (previous === 38 && character === 12) {\n            points[index] = 1;\n        }\n        if (token(character)) {\n            break;\n        }\n        next();\n    }\n    return slice(begin, position);\n};\nvar toRules = function toRules(parsed, points) {\n    // pretend we've started with a comma\n    var index = -1;\n    var character = 44;\n    do {\n        switch(token(character)){\n            case 0:\n                // &\\f\n                if (character === 38 && peek() === 12) {\n                    // this is not 100% correct, we don't account for literal sequences here - like for example quoted strings\n                    // stylis inserts \\f after & to know when & where it should replace this sequence with the context selector\n                    // and when it should just concatenate the outer and inner selectors\n                    // it's very unlikely for this sequence to actually appear in a different context, so we just leverage this fact here\n                    points[index] = 1;\n                }\n                parsed[index] += identifierWithPointTracking(position - 1, points, index);\n                break;\n            case 2:\n                parsed[index] += delimit(character);\n                break;\n            case 4:\n                // comma\n                if (character === 44) {\n                    // colon\n                    parsed[++index] = peek() === 58 ? \"&\\f\" : \"\";\n                    points[index] = parsed[index].length;\n                    break;\n                }\n            // fallthrough\n            default:\n                parsed[index] += from(character);\n        }\n    }while (character = next());\n    return parsed;\n};\nvar getRules = function getRules(value, points) {\n    return dealloc(toRules(alloc(value), points));\n}; // WeakSet would be more appropriate, but only WeakMap is supported in IE11\nvar fixedElements = /* #__PURE__ */ new WeakMap();\nvar compat = function compat(element) {\n    if (element.type !== \"rule\" || !element.parent || // positive .length indicates that this rule contains pseudo\n    // negative .length indicates that this rule has been already prefixed\n    element.length < 1) {\n        return;\n    }\n    var value = element.value, parent = element.parent;\n    var isImplicitRule = element.column === parent.column && element.line === parent.line;\n    while(parent.type !== \"rule\"){\n        parent = parent.parent;\n        if (!parent) return;\n    } // short-circuit for the simplest case\n    if (element.props.length === 1 && value.charCodeAt(0) !== 58 && !fixedElements.get(parent)) {\n        return;\n    } // if this is an implicitly inserted rule (the one eagerly inserted at the each new nested level)\n    // then the props has already been manipulated beforehand as they that array is shared between it and its \"rule parent\"\n    if (isImplicitRule) {\n        return;\n    }\n    fixedElements.set(element, true);\n    var points = [];\n    var rules = getRules(value, points);\n    var parentRules = parent.props;\n    for(var i = 0, k = 0; i < rules.length; i++){\n        for(var j = 0; j < parentRules.length; j++, k++){\n            element.props[k] = points[i] ? rules[i].replace(/&\\f/g, parentRules[j]) : parentRules[j] + \" \" + rules[i];\n        }\n    }\n};\nvar removeLabel = function removeLabel(element) {\n    if (element.type === \"decl\") {\n        var value = element.value;\n        if (value.charCodeAt(0) === 108 && // charcode for b\n        value.charCodeAt(2) === 98) {\n            // this ignores label\n            element[\"return\"] = \"\";\n            element.value = \"\";\n        }\n    }\n};\nvar ignoreFlag = \"emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason\";\nvar isIgnoringComment = function isIgnoringComment(element) {\n    return element.type === \"comm\" && element.children.indexOf(ignoreFlag) > -1;\n};\nvar createUnsafeSelectorsAlarm = function createUnsafeSelectorsAlarm(cache) {\n    return function(element, index, children) {\n        if (element.type !== \"rule\" || cache.compat) return;\n        var unsafePseudoClasses = element.value.match(/(:first|:nth|:nth-last)-child/g);\n        if (unsafePseudoClasses) {\n            var isNested = element.parent === children[0]; // in nested rules comments become children of the \"auto-inserted\" rule\n            //\n            // considering this input:\n            // .a {\n            //   .b /* comm */ {}\n            //   color: hotpink;\n            // }\n            // we get output corresponding to this:\n            // .a {\n            //   & {\n            //     /* comm */\n            //     color: hotpink;\n            //   }\n            //   .b {}\n            // }\n            var commentContainer = isNested ? children[0].children : children;\n            for(var i = commentContainer.length - 1; i >= 0; i--){\n                var node = commentContainer[i];\n                if (node.line < element.line) {\n                    break;\n                } // it is quite weird but comments are *usually* put at `column: element.column - 1`\n                // so we seek *from the end* for the node that is earlier than the rule's `element` and check that\n                // this will also match inputs like this:\n                // .a {\n                //   /* comm */\n                //   .b {}\n                // }\n                //\n                // but that is fine\n                //\n                // it would be the easiest to change the placement of the comment to be the first child of the rule:\n                // .a {\n                //   .b { /* comm */ }\n                // }\n                // with such inputs we wouldn't have to search for the comment at all\n                // TODO: consider changing this comment placement in the next major version\n                if (node.column < element.column) {\n                    if (isIgnoringComment(node)) {\n                        return;\n                    }\n                    break;\n                }\n            }\n            unsafePseudoClasses.forEach(function(unsafePseudoClass) {\n                console.error('The pseudo class \"' + unsafePseudoClass + '\" is potentially unsafe when doing server-side rendering. Try changing it to \"' + unsafePseudoClass.split(\"-child\")[0] + '-of-type\".');\n            });\n        }\n    };\n};\nvar isImportRule = function isImportRule(element) {\n    return element.type.charCodeAt(1) === 105 && element.type.charCodeAt(0) === 64;\n};\nvar isPrependedWithRegularRules = function isPrependedWithRegularRules(index, children) {\n    for(var i = index - 1; i >= 0; i--){\n        if (!isImportRule(children[i])) {\n            return true;\n        }\n    }\n    return false;\n}; // use this to remove incorrect elements from further processing\n// so they don't get handed to the `sheet` (or anything else)\n// as that could potentially lead to additional logs which in turn could be overhelming to the user\nvar nullifyElement = function nullifyElement(element) {\n    element.type = \"\";\n    element.value = \"\";\n    element[\"return\"] = \"\";\n    element.children = \"\";\n    element.props = \"\";\n};\nvar incorrectImportAlarm = function incorrectImportAlarm(element, index, children) {\n    if (!isImportRule(element)) {\n        return;\n    }\n    if (element.parent) {\n        console.error(\"`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles.\");\n        nullifyElement(element);\n    } else if (isPrependedWithRegularRules(index, children)) {\n        console.error(\"`@import` rules can't be after other rules. Please put your `@import` rules before your other rules.\");\n        nullifyElement(element);\n    }\n};\n/* eslint-disable no-fallthrough */ function prefix(value, length) {\n    switch(hash$2(value, length)){\n        // color-adjust\n        case 5103:\n            return WEBKIT + \"print-\" + value + value;\n        // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)\n        case 5737:\n        case 4201:\n        case 3177:\n        case 3433:\n        case 1641:\n        case 4457:\n        case 2921:\n        case 5572:\n        case 6356:\n        case 5844:\n        case 3191:\n        case 6645:\n        case 3005:\n        case 6391:\n        case 5879:\n        case 5623:\n        case 6135:\n        case 4599:\n        case 4855:\n        case 4215:\n        case 6389:\n        case 5109:\n        case 5365:\n        case 5621:\n        case 3829:\n            return WEBKIT + value + value;\n        // appearance, user-select, transform, hyphens, text-size-adjust\n        case 5349:\n        case 4246:\n        case 4810:\n        case 6968:\n        case 2756:\n            return WEBKIT + value + MOZ + value + MS + value + value;\n        // flex, flex-direction\n        case 6828:\n        case 4268:\n            return WEBKIT + value + MS + value + value;\n        // order\n        case 6165:\n            return WEBKIT + value + MS + \"flex-\" + value + value;\n        // align-items\n        case 5187:\n            return WEBKIT + value + replace(value, /(\\w+).+(:[^]+)/, WEBKIT + \"box-$1$2\" + MS + \"flex-$1$2\") + value;\n        // align-self\n        case 5443:\n            return WEBKIT + value + MS + \"flex-item-\" + replace(value, /flex-|-self/, \"\") + value;\n        // align-content\n        case 4675:\n            return WEBKIT + value + MS + \"flex-line-pack\" + replace(value, /align-content|flex-|-self/, \"\") + value;\n        // flex-shrink\n        case 5548:\n            return WEBKIT + value + MS + replace(value, \"shrink\", \"negative\") + value;\n        // flex-basis\n        case 5292:\n            return WEBKIT + value + MS + replace(value, \"basis\", \"preferred-size\") + value;\n        // flex-grow\n        case 6060:\n            return WEBKIT + \"box-\" + replace(value, \"-grow\", \"\") + WEBKIT + value + MS + replace(value, \"grow\", \"positive\") + value;\n        // transition\n        case 4554:\n            return WEBKIT + replace(value, /([^-])(transform)/g, \"$1\" + WEBKIT + \"$2\") + value;\n        // cursor\n        case 6187:\n            return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + \"$1\"), /(image-set)/, WEBKIT + \"$1\"), value, \"\") + value;\n        // background, background-image\n        case 5495:\n        case 3959:\n            return replace(value, /(image-set\\([^]*)/, WEBKIT + \"$1\" + \"$`$1\");\n        // justify-content\n        case 4968:\n            return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + \"box-pack:$3\" + MS + \"flex-pack:$3\"), /s.+-b[^;]+/, \"justify\") + WEBKIT + value + value;\n        // (margin|padding)-inline-(start|end)\n        case 4095:\n        case 3583:\n        case 4068:\n        case 2532:\n            return replace(value, /(.+)-inline(.+)/, WEBKIT + \"$1$2\") + value;\n        // (min|max)?(width|height|inline-size|block-size)\n        case 8116:\n        case 7059:\n        case 5753:\n        case 5535:\n        case 5445:\n        case 5701:\n        case 4933:\n        case 4677:\n        case 5533:\n        case 5789:\n        case 5021:\n        case 4765:\n            // stretch, max-content, min-content, fill-available\n            if (strlen(value) - 1 - length > 6) switch(charat(value, length + 1)){\n                // (m)ax-content, (m)in-content\n                case 109:\n                    // -\n                    if (charat(value, length + 4) !== 45) break;\n                // (f)ill-available, (f)it-content\n                case 102:\n                    return replace(value, /(.+:)(.+)-([^]+)/, \"$1\" + WEBKIT + \"$2-$3\" + \"$1\" + MOZ + (charat(value, length + 3) == 108 ? \"$3\" : \"$2-$3\")) + value;\n                // (s)tretch\n                case 115:\n                    return ~indexof(value, \"stretch\") ? prefix(replace(value, \"stretch\", \"fill-available\"), length) + value : value;\n            }\n            break;\n        // position: sticky\n        case 4949:\n            // (s)ticky?\n            if (charat(value, length + 1) !== 115) break;\n        // display: (flex|inline-flex)\n        case 6444:\n            switch(charat(value, strlen(value) - 3 - (~indexof(value, \"!important\") && 10))){\n                // stic(k)y\n                case 107:\n                    return replace(value, \":\", \":\" + WEBKIT) + value;\n                // (inline-)?fl(e)x\n                case 101:\n                    return replace(value, /(.+:)([^;!]+)(;|!.+)?/, \"$1\" + WEBKIT + (charat(value, 14) === 45 ? \"inline-\" : \"\") + \"box$3\" + \"$1\" + WEBKIT + \"$2$3\" + \"$1\" + MS + \"$2box$3\") + value;\n            }\n            break;\n        // writing-mode\n        case 5936:\n            switch(charat(value, length + 11)){\n                // vertical-l(r)\n                case 114:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb\") + value;\n                // vertical-r(l)\n                case 108:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"tb-rl\") + value;\n                // horizontal(-)tb\n                case 45:\n                    return WEBKIT + value + MS + replace(value, /[svh]\\w+-[tblr]{2}/, \"lr\") + value;\n            }\n            return WEBKIT + value + MS + value + value;\n    }\n    return value;\n}\nvar prefixer = function prefixer(element, index, children, callback) {\n    if (element.length > -1) {\n        if (!element[\"return\"]) switch(element.type){\n            case DECLARATION:\n                element[\"return\"] = prefix(element.value, element.length);\n                break;\n            case KEYFRAMES:\n                return serialize([\n                    copy(element, {\n                        value: replace(element.value, \"@\", \"@\" + WEBKIT)\n                    })\n                ], callback);\n            case RULESET:\n                if (element.length) return combine(element.props, function(value) {\n                    switch(match(value, /(::plac\\w+|:read-\\w+)/)){\n                        // :read-(only|write)\n                        case \":read-only\":\n                        case \":read-write\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(read-\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                })\n                            ], callback);\n                        // :placeholder\n                        case \"::placeholder\":\n                            return serialize([\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + WEBKIT + \"input-$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, \":\" + MOZ + \"$1\")\n                                    ]\n                                }),\n                                copy(element, {\n                                    props: [\n                                        replace(value, /:(plac\\w+)/, MS + \"input-$1\")\n                                    ]\n                                })\n                            ], callback);\n                    }\n                    return \"\";\n                });\n        }\n    }\n};\nvar isBrowser$5 = typeof document !== \"undefined\";\nvar getServerStylisCache = isBrowser$5 ? undefined : weakMemoize(function() {\n    return memoize(function() {\n        var cache = {};\n        return function(name) {\n            return cache[name];\n        };\n    });\n});\nvar defaultStylisPlugins = [\n    prefixer\n];\nvar createCache = function createCache(options) {\n    var key = options.key;\n    if ( true && !key) {\n        throw new Error(\"You have to configure `key` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.\\n\" + 'If multiple caches share the same key they might \"fight\" for each other\\'s style elements.');\n    }\n    if (isBrowser$5 && key === \"css\") {\n        var ssrStyles = document.querySelectorAll(\"style[data-emotion]:not([data-s])\"); // get SSRed styles out of the way of React's hydration\n        // document.head is a safe place to move them to(though note document.head is not necessarily the last place they will be)\n        // note this very very intentionally targets all style elements regardless of the key to ensure\n        // that creating a cache works inside of render of a React component\n        Array.prototype.forEach.call(ssrStyles, function(node) {\n            // we want to only move elements which have a space in the data-emotion attribute value\n            // because that indicates that it is an Emotion 11 server-side rendered style elements\n            // while we will already ignore Emotion 11 client-side inserted styles because of the :not([data-s]) part in the selector\n            // Emotion 10 client-side inserted styles did not have data-s (but importantly did not have a space in their data-emotion attributes)\n            // so checking for the space ensures that loading Emotion 11 after Emotion 10 has inserted some styles\n            // will not result in the Emotion 10 styles being destroyed\n            var dataEmotionAttribute = node.getAttribute(\"data-emotion\");\n            if (dataEmotionAttribute.indexOf(\" \") === -1) {\n                return;\n            }\n            document.head.appendChild(node);\n            node.setAttribute(\"data-s\", \"\");\n        });\n    }\n    var stylisPlugins = options.stylisPlugins || defaultStylisPlugins;\n    if (true) {\n        // $FlowFixMe\n        if (/[^a-z-]/.test(key)) {\n            throw new Error('Emotion key must only contain lower case alphabetical characters and - but \"' + key + '\" was passed');\n        }\n    }\n    var inserted = {};\n    var container;\n    var nodesToHydrate = [];\n    if (isBrowser$5) {\n        container = options.container || document.head;\n        Array.prototype.forEach.call(// means that the style elements we're looking at are only Emotion 11 server-rendered style elements\n        document.querySelectorAll('style[data-emotion^=\"' + key + ' \"]'), function(node) {\n            var attrib = node.getAttribute(\"data-emotion\").split(\" \"); // $FlowFixMe\n            for(var i = 1; i < attrib.length; i++){\n                inserted[attrib[i]] = true;\n            }\n            nodesToHydrate.push(node);\n        });\n    }\n    var _insert;\n    var omnipresentPlugins = [\n        compat,\n        removeLabel\n    ];\n    if (true) {\n        omnipresentPlugins.push(createUnsafeSelectorsAlarm({\n            get compat () {\n                return cache.compat;\n            }\n        }), incorrectImportAlarm);\n    }\n    if (isBrowser$5) {\n        var currentSheet;\n        var finalizingPlugins = [\n            stringify,\n             true ? function(element) {\n                if (!element.root) {\n                    if (element[\"return\"]) {\n                        currentSheet.insert(element[\"return\"]);\n                    } else if (element.value && element.type !== COMMENT) {\n                        // insert empty rule in non-production environments\n                        // so @emotion/jest can grab `key` from the (JS)DOM for caches without any rules inserted yet\n                        currentSheet.insert(element.value + \"{}\");\n                    }\n                }\n            } : 0\n        ];\n        var serializer = middleware(omnipresentPlugins.concat(stylisPlugins, finalizingPlugins));\n        var stylis = function stylis(styles) {\n            return serialize(compile(styles), serializer);\n        };\n        _insert = function insert(selector, serialized, sheet, shouldCache) {\n            currentSheet = sheet;\n            if ( true && serialized.map !== undefined) {\n                currentSheet = {\n                    insert: function insert(rule) {\n                        sheet.insert(rule + serialized.map);\n                    }\n                };\n            }\n            stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            if (shouldCache) {\n                cache.inserted[serialized.name] = true;\n            }\n        };\n    } else {\n        var _finalizingPlugins = [\n            stringify\n        ];\n        var _serializer = middleware(omnipresentPlugins.concat(stylisPlugins, _finalizingPlugins));\n        var _stylis = function _stylis(styles) {\n            return serialize(compile(styles), _serializer);\n        }; // $FlowFixMe\n        var serverStylisCache = getServerStylisCache(stylisPlugins)(key);\n        var getRules = function getRules(selector, serialized) {\n            var name = serialized.name;\n            if (serverStylisCache[name] === undefined) {\n                serverStylisCache[name] = _stylis(selector ? selector + \"{\" + serialized.styles + \"}\" : serialized.styles);\n            }\n            return serverStylisCache[name];\n        };\n        _insert = function _insert(selector, serialized, sheet, shouldCache) {\n            var name = serialized.name;\n            var rules = getRules(selector, serialized);\n            if (cache.compat === undefined) {\n                // in regular mode, we don't set the styles on the inserted cache\n                // since we don't need to and that would be wasting memory\n                // we return them so that they are rendered in a style tag\n                if (shouldCache) {\n                    cache.inserted[name] = true;\n                }\n                if (// because if people do ssr in tests, the source maps showing up would be annoying\n                 true && serialized.map !== undefined) {\n                    return rules + serialized.map;\n                }\n                return rules;\n            } else {\n                // in compat mode, we put the styles on the inserted cache so\n                // that emotion-server can pull out the styles\n                // except when we don't want to cache it which was in Global but now\n                // is nowhere but we don't want to do a major right now\n                // and just in case we're going to leave the case here\n                // it's also not affecting client side bundle size\n                // so it's really not a big deal\n                if (shouldCache) {\n                    cache.inserted[name] = rules;\n                } else {\n                    return rules;\n                }\n            }\n        };\n    }\n    var cache = {\n        key: key,\n        sheet: new StyleSheet({\n            key: key,\n            container: container,\n            nonce: options.nonce,\n            speedy: options.speedy,\n            prepend: options.prepend,\n            insertionPoint: options.insertionPoint\n        }),\n        nonce: options.nonce,\n        inserted: inserted,\n        registered: {},\n        insert: _insert\n    };\n    cache.sheet.hydrate(nodesToHydrate);\n    return cache;\n};\nvar isBrowser$4 = typeof document !== \"undefined\";\nfunction getRegisteredStyles$1(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles$1 = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$4 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles$1 = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles$1(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$4 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$4 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2$1(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys$1 = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$2 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR$1 = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex$1 = /[A-Z]|^ms/g;\nvar animationRegex$1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty$1 = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue$1 = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName$1 = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty$1(styleName) ? styleName : styleName.replace(hyphenateRegex$1, \"-$&\").toLowerCase();\n});\nvar processStyleValue$1 = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex$1, function(match, p1, p2) {\n                        cursor$1 = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor$1\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys$1[key] !== 1 && !isCustomProperty$1(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern$1 = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues$1 = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue$1 = processStyleValue$1;\n    var msPattern$1 = /^-ms-/;\n    var hyphenPattern$1 = /-(.)/g;\n    var hyphenatedCache$1 = {};\n    processStyleValue$1 = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues$1.indexOf(value) === -1 && !contentValuePattern$1.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue$1(key, value);\n        if (processed !== \"\" && !isCustomProperty$1(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache$1[key] === undefined) {\n            hyphenatedCache$1[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern$1, \"ms-\").replace(hyphenPattern$1, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage$1 = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation$1(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage$1);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor$1 = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor$1\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor$1 = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor$1\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject$1(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor$1;\n                    var result = interpolation(mergedProps);\n                    cursor$1 = previousCursor;\n                    return handleInterpolation$1(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex$1, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject$1(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation$1(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue$1(value)) {\n                    string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage$1);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue$1(value[_i])) {\n                            string += processStyleName$1(_key) + \":\" + processStyleValue$1(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation$1(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName$1(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR$1);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern$1 = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern$1;\nif (true) {\n    sourceMapPattern$1 = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor$1;\nvar serializeStyles$1 = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor$1 = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation$1(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation$1(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$2);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern$1, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern$1.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern$1.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2$1(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor$1,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor$1\n    };\n};\nvar isBrowser$3 = typeof document !== \"undefined\";\nvar syncFallback = function syncFallback(create) {\n    return create();\n};\nvar useInsertionEffect = react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] ? react__WEBPACK_IMPORTED_MODULE_0__[\"useInsertion\" + \"Effect\"] : false;\nvar useInsertionEffectAlwaysWithSyncFallback = !isBrowser$3 ? syncFallback : useInsertionEffect || syncFallback;\nvar isBrowser$2 = typeof document !== \"undefined\";\nvar hasOwnProperty = {}.hasOwnProperty;\nvar EmotionCacheContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(// because this module is primarily intended for the browser and node\n// but it's also required in react native and similar environments sometimes\n// and we could have a special build just for that\n// but this is much easier and the native packages\n// might use a different theme context in the future anyway\ntypeof HTMLElement !== \"undefined\" ? /* #__PURE__ */ createCache({\n    key: \"css\"\n}) : null);\nif (true) {\n    EmotionCacheContext.displayName = \"EmotionCacheContext\";\n}\nEmotionCacheContext.Provider;\nvar withEmotionCache = function withEmotionCache(func) {\n    // $FlowFixMe\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function(props, ref) {\n        // the cache will never be null in the browser\n        var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n        return func(props, cache, ref);\n    });\n};\nif (!isBrowser$2) {\n    withEmotionCache = function withEmotionCache(func) {\n        return function(props) {\n            var cache = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(EmotionCacheContext);\n            if (cache === null) {\n                // yes, we're potentially creating this on every render\n                // it doesn't actually matter though since it's only on the server\n                // so there will only every be a single render\n                // that could change in the future because of suspense and etc. but for now,\n                // this works and i don't want to optimise for a future thing that we aren't sure about\n                cache = createCache({\n                    key: \"css\"\n                });\n                return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(EmotionCacheContext.Provider, {\n                    value: cache\n                }, func(props, cache));\n            } else {\n                return func(props, cache);\n            }\n        };\n    };\n}\nvar ThemeContext = /* #__PURE__ */ /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nif (true) {\n    ThemeContext.displayName = \"EmotionThemeContext\";\n}\nvar typePropName = \"__EMOTION_TYPE_PLEASE_DO_NOT_USE__\";\nvar labelPropName = \"__EMOTION_LABEL_PLEASE_DO_NOT_USE__\";\nvar Insertion$1 = function Insertion(_ref) {\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles$1(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles$1(cache, serialized, isStringTag);\n    });\n    if (!isBrowser$2 && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\nvar Emotion = /* #__PURE__ */ withEmotionCache(function(props, cache, ref) {\n    var cssProp = props.css; // so that using `css` from `emotion` and passing the result to the css prop works\n    // not passing the registered cache to serializeStyles because it would\n    // make certain babel optimisations not possible\n    if (typeof cssProp === \"string\" && cache.registered[cssProp] !== undefined) {\n        cssProp = cache.registered[cssProp];\n    }\n    var WrappedComponent = props[typePropName];\n    var registeredStyles = [\n        cssProp\n    ];\n    var className = \"\";\n    if (typeof props.className === \"string\") {\n        className = getRegisteredStyles$1(cache.registered, registeredStyles, props.className);\n    } else if (props.className != null) {\n        className = props.className + \" \";\n    }\n    var serialized = serializeStyles$1(registeredStyles, undefined, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext));\n    if ( true && serialized.name.indexOf(\"-\") === -1) {\n        var labelFromStack = props[labelPropName];\n        if (labelFromStack) {\n            serialized = serializeStyles$1([\n                serialized,\n                \"label:\" + labelFromStack + \";\"\n            ]);\n        }\n    }\n    className += cache.key + \"-\" + serialized.name;\n    var newProps = {};\n    for(var key in props){\n        if (hasOwnProperty.call(props, key) && key !== \"css\" && key !== typePropName && ( false || key !== labelPropName)) {\n            newProps[key] = props[key];\n        }\n    }\n    newProps.ref = ref;\n    newProps.className = className;\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion$1, {\n        cache: cache,\n        serialized: serialized,\n        isStringTag: typeof WrappedComponent === \"string\"\n    }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(WrappedComponent, newProps));\n});\nif (true) {\n    Emotion.displayName = \"EmotionCssPropInternal\";\n}\nvar isBrowser$1 = typeof document !== \"undefined\";\nfunction getRegisteredStyles(registered, registeredStyles, classNames) {\n    var rawClassName = \"\";\n    classNames.split(\" \").forEach(function(className) {\n        if (registered[className] !== undefined) {\n            registeredStyles.push(registered[className] + \";\");\n        } else {\n            rawClassName += className + \" \";\n        }\n    });\n    return rawClassName;\n}\nvar registerStyles = function registerStyles(cache, serialized, isStringTag) {\n    var className = cache.key + \"-\" + serialized.name;\n    if (// class name could be used further down\n    // the tree but if it's a string tag, we know it won't\n    // so we don't have to add it to registered cache.\n    // this improves memory usage since we can avoid storing the whole style string\n    (isStringTag === false || // we need to always store it if we're in compat mode and\n    // in node since emotion-server relies on whether a style is in\n    // the registered cache to know whether a style is global or not\n    // also, note that this check will be dead code eliminated in the browser\n    isBrowser$1 === false && cache.compat !== undefined) && cache.registered[className] === undefined) {\n        cache.registered[className] = serialized.styles;\n    }\n};\nvar insertStyles = function insertStyles(cache, serialized, isStringTag) {\n    registerStyles(cache, serialized, isStringTag);\n    var className = cache.key + \"-\" + serialized.name;\n    if (cache.inserted[serialized.name] === undefined) {\n        var stylesForSSR = \"\";\n        var current = serialized;\n        do {\n            var maybeStyles = cache.insert(serialized === current ? \".\" + className : \"\", current, cache.sheet, true);\n            if (!isBrowser$1 && maybeStyles !== undefined) {\n                stylesForSSR += maybeStyles;\n            }\n            current = current.next;\n        }while (current !== undefined);\n        if (!isBrowser$1 && stylesForSSR.length !== 0) {\n            return stylesForSSR;\n        }\n    }\n};\n/* eslint-disable */ // Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n    // 'm' and 'r' are mixing constants generated offline.\n    // They're not really 'magic', they just happen to work well.\n    // const m = 0x5bd1e995;\n    // const r = 24;\n    // Initialize the hash\n    var h = 0; // Mix 4 bytes at a time into the hash\n    var k, i = 0, len = str.length;\n    for(; len >= 4; ++i, len -= 4){\n        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n        k = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n        k ^= /* k >>> r: */ k >>> 24;\n        h = /* Math.imul(k, m): */ (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^ /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Handle the last few bytes of the input array\n    switch(len){\n        case 3:\n            h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n        case 2:\n            h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n        case 1:\n            h ^= str.charCodeAt(i) & 0xff;\n            h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    } // Do a few final mixes of the hash to ensure the last few\n    // bytes are well-incorporated.\n    h ^= h >>> 13;\n    h = /* Math.imul(h, m): */ (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n    return ((h ^ h >>> 15) >>> 0).toString(36);\n}\nvar unitlessKeys = {\n    animationIterationCount: 1,\n    borderImageOutset: 1,\n    borderImageSlice: 1,\n    borderImageWidth: 1,\n    boxFlex: 1,\n    boxFlexGroup: 1,\n    boxOrdinalGroup: 1,\n    columnCount: 1,\n    columns: 1,\n    flex: 1,\n    flexGrow: 1,\n    flexPositive: 1,\n    flexShrink: 1,\n    flexNegative: 1,\n    flexOrder: 1,\n    gridRow: 1,\n    gridRowEnd: 1,\n    gridRowSpan: 1,\n    gridRowStart: 1,\n    gridColumn: 1,\n    gridColumnEnd: 1,\n    gridColumnSpan: 1,\n    gridColumnStart: 1,\n    msGridRow: 1,\n    msGridRowSpan: 1,\n    msGridColumn: 1,\n    msGridColumnSpan: 1,\n    fontWeight: 1,\n    lineHeight: 1,\n    opacity: 1,\n    order: 1,\n    orphans: 1,\n    tabSize: 1,\n    widows: 1,\n    zIndex: 1,\n    zoom: 1,\n    WebkitLineClamp: 1,\n    // SVG-related properties\n    fillOpacity: 1,\n    floodOpacity: 1,\n    stopOpacity: 1,\n    strokeDasharray: 1,\n    strokeDashoffset: 1,\n    strokeMiterlimit: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR$1 = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar UNDEFINED_AS_OBJECT_KEY_ERROR = \"You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).\";\nvar hyphenateRegex = /[A-Z]|^ms/g;\nvar animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g;\nvar isCustomProperty = function isCustomProperty(property) {\n    return property.charCodeAt(1) === 45;\n};\nvar isProcessableValue = function isProcessableValue(value) {\n    return value != null && typeof value !== \"boolean\";\n};\nvar processStyleName = /* #__PURE__ */ memoize(function(styleName) {\n    return isCustomProperty(styleName) ? styleName : styleName.replace(hyphenateRegex, \"-$&\").toLowerCase();\n});\nvar processStyleValue = function processStyleValue(key, value) {\n    switch(key){\n        case \"animation\":\n        case \"animationName\":\n            {\n                if (typeof value === \"string\") {\n                    return value.replace(animationRegex, function(match, p1, p2) {\n                        cursor = {\n                            name: p1,\n                            styles: p2,\n                            next: cursor\n                        };\n                        return p1;\n                    });\n                }\n            }\n    }\n    if (unitlessKeys[key] !== 1 && !isCustomProperty(key) && typeof value === \"number\" && value !== 0) {\n        return value + \"px\";\n    }\n    return value;\n};\nif (true) {\n    var contentValuePattern = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\\(|(no-)?(open|close)-quote/;\n    var contentValues = [\n        \"normal\",\n        \"none\",\n        \"initial\",\n        \"inherit\",\n        \"unset\"\n    ];\n    var oldProcessStyleValue = processStyleValue;\n    var msPattern = /^-ms-/;\n    var hyphenPattern = /-(.)/g;\n    var hyphenatedCache = {};\n    processStyleValue = function processStyleValue(key, value) {\n        if (key === \"content\") {\n            if (typeof value !== \"string\" || contentValues.indexOf(value) === -1 && !contentValuePattern.test(value) && (value.charAt(0) !== value.charAt(value.length - 1) || value.charAt(0) !== '\"' && value.charAt(0) !== \"'\")) {\n                throw new Error(\"You seem to be using a value for 'content' without quotes, try replacing it with `content: '\\\"\" + value + \"\\\"'`\");\n            }\n        }\n        var processed = oldProcessStyleValue(key, value);\n        if (processed !== \"\" && !isCustomProperty(key) && key.indexOf(\"-\") !== -1 && hyphenatedCache[key] === undefined) {\n            hyphenatedCache[key] = true;\n            console.error(\"Using kebab-case for css properties in objects is not supported. Did you mean \" + key.replace(msPattern, \"ms-\").replace(hyphenPattern, function(str, _char) {\n                return _char.toUpperCase();\n            }) + \"?\");\n        }\n        return processed;\n    };\n}\nvar noComponentSelectorMessage = \"Component selectors can only be used in conjunction with \" + \"@emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware \" + \"compiler transform.\";\nfunction handleInterpolation(mergedProps, registered, interpolation) {\n    if (interpolation == null) {\n        return \"\";\n    }\n    if (interpolation.__emotion_styles !== undefined) {\n        if ( true && interpolation.toString() === \"NO_COMPONENT_SELECTOR\") {\n            throw new Error(noComponentSelectorMessage);\n        }\n        return interpolation;\n    }\n    switch(typeof interpolation){\n        case \"boolean\":\n            {\n                return \"\";\n            }\n        case \"object\":\n            {\n                if (interpolation.anim === 1) {\n                    cursor = {\n                        name: interpolation.name,\n                        styles: interpolation.styles,\n                        next: cursor\n                    };\n                    return interpolation.name;\n                }\n                if (interpolation.styles !== undefined) {\n                    var next = interpolation.next;\n                    if (next !== undefined) {\n                        // not the most efficient thing ever but this is a pretty rare case\n                        // and there will be very few iterations of this generally\n                        while(next !== undefined){\n                            cursor = {\n                                name: next.name,\n                                styles: next.styles,\n                                next: cursor\n                            };\n                            next = next.next;\n                        }\n                    }\n                    var styles = interpolation.styles + \";\";\n                    if ( true && interpolation.map !== undefined) {\n                        styles += interpolation.map;\n                    }\n                    return styles;\n                }\n                return createStringFromObject(mergedProps, registered, interpolation);\n            }\n        case \"function\":\n            {\n                if (mergedProps !== undefined) {\n                    var previousCursor = cursor;\n                    var result = interpolation(mergedProps);\n                    cursor = previousCursor;\n                    return handleInterpolation(mergedProps, registered, result);\n                } else if (true) {\n                    console.error(\"Functions that are interpolated in css calls will be stringified.\\n\" + \"If you want to have a css call based on props, create a function that returns a css call like this\\n\" + \"let dynamicStyle = (props) => css`color: ${props.color}`\\n\" + \"It can be called directly with props or interpolated in a styled call like this\\n\" + \"let SomeComponent = styled('div')`${dynamicStyle}`\");\n                }\n                break;\n            }\n        case \"string\":\n            if (true) {\n                var matched = [];\n                var replaced = interpolation.replace(animationRegex, function(match, p1, p2) {\n                    var fakeVarName = \"animation\" + matched.length;\n                    matched.push(\"const \" + fakeVarName + \" = keyframes`\" + p2.replace(/^@keyframes animation-\\w+/, \"\") + \"`\");\n                    return \"${\" + fakeVarName + \"}\";\n                });\n                if (matched.length) {\n                    console.error(\"`keyframes` output got interpolated into plain string, please wrap it with `css`.\\n\\n\" + \"Instead of doing this:\\n\\n\" + [].concat(matched, [\n                        \"`\" + replaced + \"`\"\n                    ]).join(\"\\n\") + \"\\n\\nYou should wrap it with `css` like this:\\n\\n\" + (\"css`\" + replaced + \"`\"));\n                }\n            }\n            break;\n    } // finalize string values (regular strings and functions interpolated into css calls)\n    if (registered == null) {\n        return interpolation;\n    }\n    var cached = registered[interpolation];\n    return cached !== undefined ? cached : interpolation;\n}\nfunction createStringFromObject(mergedProps, registered, obj) {\n    var string = \"\";\n    if (Array.isArray(obj)) {\n        for(var i = 0; i < obj.length; i++){\n            string += handleInterpolation(mergedProps, registered, obj[i]) + \";\";\n        }\n    } else {\n        for(var _key in obj){\n            var value = obj[_key];\n            if (typeof value !== \"object\") {\n                if (registered != null && registered[value] !== undefined) {\n                    string += _key + \"{\" + registered[value] + \"}\";\n                } else if (isProcessableValue(value)) {\n                    string += processStyleName(_key) + \":\" + processStyleValue(_key, value) + \";\";\n                }\n            } else {\n                if (_key === \"NO_COMPONENT_SELECTOR\" && \"development\" !== \"production\") {\n                    throw new Error(noComponentSelectorMessage);\n                }\n                if (Array.isArray(value) && typeof value[0] === \"string\" && (registered == null || registered[value[0]] === undefined)) {\n                    for(var _i = 0; _i < value.length; _i++){\n                        if (isProcessableValue(value[_i])) {\n                            string += processStyleName(_key) + \":\" + processStyleValue(_key, value[_i]) + \";\";\n                        }\n                    }\n                } else {\n                    var interpolated = handleInterpolation(mergedProps, registered, value);\n                    switch(_key){\n                        case \"animation\":\n                        case \"animationName\":\n                            {\n                                string += processStyleName(_key) + \":\" + interpolated + \";\";\n                                break;\n                            }\n                        default:\n                            {\n                                if ( true && _key === \"undefined\") {\n                                    console.error(UNDEFINED_AS_OBJECT_KEY_ERROR);\n                                }\n                                string += _key + \"{\" + interpolated + \"}\";\n                            }\n                    }\n                }\n            }\n        }\n    }\n    return string;\n}\nvar labelPattern = /label:\\s*([^\\s;\\n{]+)\\s*(;|$)/g;\nvar sourceMapPattern;\nif (true) {\n    sourceMapPattern = /\\/\\*#\\ssourceMappingURL=data:application\\/json;\\S+\\s+\\*\\//g;\n} // this is the cursor for keyframes\n// keyframes are stored on the SerializedStyles object as a linked list\nvar cursor;\nvar serializeStyles = function serializeStyles(args, registered, mergedProps) {\n    if (args.length === 1 && typeof args[0] === \"object\" && args[0] !== null && args[0].styles !== undefined) {\n        return args[0];\n    }\n    var stringMode = true;\n    var styles = \"\";\n    cursor = undefined;\n    var strings = args[0];\n    if (strings == null || strings.raw === undefined) {\n        stringMode = false;\n        styles += handleInterpolation(mergedProps, registered, strings);\n    } else {\n        if ( true && strings[0] === undefined) {\n            console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n        }\n        styles += strings[0];\n    } // we start at 1 since we've already handled the first arg\n    for(var i = 1; i < args.length; i++){\n        styles += handleInterpolation(mergedProps, registered, args[i]);\n        if (stringMode) {\n            if ( true && strings[i] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR$1);\n            }\n            styles += strings[i];\n        }\n    }\n    var sourceMap;\n    if (true) {\n        styles = styles.replace(sourceMapPattern, function(match) {\n            sourceMap = match;\n            return \"\";\n        });\n    } // using a global regex with .exec is stateful so lastIndex has to be reset each time\n    labelPattern.lastIndex = 0;\n    var identifierName = \"\";\n    var match; // https://esbench.com/bench/5b809c2cf2949800a0f61fb5\n    while((match = labelPattern.exec(styles)) !== null){\n        identifierName += \"-\" + // $FlowFixMe we know it's not null\n        match[1];\n    }\n    var name = murmur2(styles) + identifierName;\n    if (true) {\n        // $FlowFixMe SerializedStyles type doesn't have toString property (and we don't want to add it)\n        return {\n            name: name,\n            styles: styles,\n            map: sourceMap,\n            next: cursor,\n            toString: function toString() {\n                return \"You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).\";\n            }\n        };\n    }\n    return {\n        name: name,\n        styles: styles,\n        next: cursor\n    };\n};\nvar testOmitPropsOnStringTag = isPropValid;\nvar testOmitPropsOnComponent = function testOmitPropsOnComponent(key) {\n    return key !== \"theme\";\n};\nvar getDefaultShouldForwardProp = function getDefaultShouldForwardProp(tag) {\n    return typeof tag === \"string\" && // 96 is one less than the char code\n    // for \"a\" so this is checking that\n    // it's a lowercase character\n    tag.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent;\n};\nvar composeShouldForwardProps = function composeShouldForwardProps(tag, options, isReal) {\n    var shouldForwardProp;\n    if (options) {\n        var optionsShouldForwardProp = options.shouldForwardProp;\n        shouldForwardProp = tag.__emotion_forwardProp && optionsShouldForwardProp ? function(propName) {\n            return tag.__emotion_forwardProp(propName) && optionsShouldForwardProp(propName);\n        } : optionsShouldForwardProp;\n    }\n    if (typeof shouldForwardProp !== \"function\" && isReal) {\n        shouldForwardProp = tag.__emotion_forwardProp;\n    }\n    return shouldForwardProp;\n};\nvar ILLEGAL_ESCAPE_SEQUENCE_ERROR = \"You have illegal escape sequence in your template literal, most likely inside content's property value.\\nBecause you write your CSS inside a JavaScript string you actually have to do double escaping, so for example \\\"content: '\\\\00d7';\\\" should become \\\"content: '\\\\\\\\00d7';\\\".\\nYou can read more about this here:\\nhttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences\";\nvar isBrowser = typeof document !== \"undefined\";\nvar Insertion = function Insertion(_ref) {\n    var cache = _ref.cache, serialized = _ref.serialized, isStringTag = _ref.isStringTag;\n    registerStyles(cache, serialized, isStringTag);\n    var rules = useInsertionEffectAlwaysWithSyncFallback(function() {\n        return insertStyles(cache, serialized, isStringTag);\n    });\n    if (!isBrowser && rules !== undefined) {\n        var _ref2;\n        var serializedNames = serialized.name;\n        var next = serialized.next;\n        while(next !== undefined){\n            serializedNames += \" \" + next.name;\n            next = next.next;\n        }\n        return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(\"style\", (_ref2 = {}, _ref2[\"data-emotion\"] = cache.key + \" \" + serializedNames, _ref2.dangerouslySetInnerHTML = {\n            __html: rules\n        }, _ref2.nonce = cache.sheet.nonce, _ref2));\n    }\n    return null;\n};\nvar createStyled = function createStyled(tag, options) {\n    if (true) {\n        if (tag === undefined) {\n            throw new Error(\"You are trying to create a styled element with an undefined component.\\nYou may have forgotten to import it.\");\n        }\n    }\n    var isReal = tag.__emotion_real === tag;\n    var baseTag = isReal && tag.__emotion_base || tag;\n    var identifierName;\n    var targetClassName;\n    if (options !== undefined) {\n        identifierName = options.label;\n        targetClassName = options.target;\n    }\n    var shouldForwardProp = composeShouldForwardProps(tag, options, isReal);\n    var defaultShouldForwardProp = shouldForwardProp || getDefaultShouldForwardProp(baseTag);\n    var shouldUseAs = !defaultShouldForwardProp(\"as\");\n    return function() {\n        var args = arguments;\n        var styles = isReal && tag.__emotion_styles !== undefined ? tag.__emotion_styles.slice(0) : [];\n        if (identifierName !== undefined) {\n            styles.push(\"label:\" + identifierName + \";\");\n        }\n        if (args[0] == null || args[0].raw === undefined) {\n            styles.push.apply(styles, args);\n        } else {\n            if ( true && args[0][0] === undefined) {\n                console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n            }\n            styles.push(args[0][0]);\n            var len = args.length;\n            var i = 1;\n            for(; i < len; i++){\n                if ( true && args[0][i] === undefined) {\n                    console.error(ILLEGAL_ESCAPE_SEQUENCE_ERROR);\n                }\n                styles.push(args[i], args[0][i]);\n            }\n        } // $FlowFixMe: we need to cast StatelessFunctionalComponent to our PrivateStyledComponent class\n        var Styled = withEmotionCache(function(props, cache, ref) {\n            var FinalTag = shouldUseAs && props.as || baseTag;\n            var className = \"\";\n            var classInterpolations = [];\n            var mergedProps = props;\n            if (props.theme == null) {\n                mergedProps = {};\n                for(var key in props){\n                    mergedProps[key] = props[key];\n                }\n                mergedProps.theme = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ThemeContext);\n            }\n            if (typeof props.className === \"string\") {\n                className = getRegisteredStyles(cache.registered, classInterpolations, props.className);\n            } else if (props.className != null) {\n                className = props.className + \" \";\n            }\n            var serialized = serializeStyles(styles.concat(classInterpolations), cache.registered, mergedProps);\n            className += cache.key + \"-\" + serialized.name;\n            if (targetClassName !== undefined) {\n                className += \" \" + targetClassName;\n            }\n            var finalShouldForwardProp = shouldUseAs && shouldForwardProp === undefined ? getDefaultShouldForwardProp(FinalTag) : defaultShouldForwardProp;\n            var newProps = {};\n            for(var _key in props){\n                if (shouldUseAs && _key === \"as\") continue;\n                if (finalShouldForwardProp(_key)) {\n                    newProps[_key] = props[_key];\n                }\n            }\n            newProps.className = className;\n            newProps.ref = ref;\n            return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(Insertion, {\n                cache: cache,\n                serialized: serialized,\n                isStringTag: typeof FinalTag === \"string\"\n            }), /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(FinalTag, newProps));\n        });\n        Styled.displayName = identifierName !== undefined ? identifierName : \"Styled(\" + (typeof baseTag === \"string\" ? baseTag : baseTag.displayName || baseTag.name || \"Component\") + \")\";\n        Styled.defaultProps = tag.defaultProps;\n        Styled.__emotion_real = Styled;\n        Styled.__emotion_base = baseTag;\n        Styled.__emotion_styles = styles;\n        Styled.__emotion_forwardProp = shouldForwardProp;\n        Object.defineProperty(Styled, \"toString\", {\n            value: function value() {\n                if (targetClassName === undefined && \"development\" !== \"production\") {\n                    return \"NO_COMPONENT_SELECTOR\";\n                } // $FlowFixMe: coerce undefined to string\n                return \".\" + targetClassName;\n            }\n        });\n        Styled.withComponent = function(nextTag, nextOptions) {\n            return createStyled(nextTag, _extends({}, options, nextOptions, {\n                shouldForwardProp: composeShouldForwardProps(Styled, nextOptions, true)\n            })).apply(void 0, styles);\n        };\n        return Styled;\n    };\n};\nvar tags = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"area\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"base\",\n    \"bdi\",\n    \"bdo\",\n    \"big\",\n    \"blockquote\",\n    \"body\",\n    \"br\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"col\",\n    \"colgroup\",\n    \"data\",\n    \"datalist\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"dialog\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"embed\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"head\",\n    \"header\",\n    \"hgroup\",\n    \"hr\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"keygen\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"link\",\n    \"main\",\n    \"map\",\n    \"mark\",\n    \"marquee\",\n    \"menu\",\n    \"menuitem\",\n    \"meta\",\n    \"meter\",\n    \"nav\",\n    \"noscript\",\n    \"object\",\n    \"ol\",\n    \"optgroup\",\n    \"option\",\n    \"output\",\n    \"p\",\n    \"param\",\n    \"picture\",\n    \"pre\",\n    \"progress\",\n    \"q\",\n    \"rp\",\n    \"rt\",\n    \"ruby\",\n    \"s\",\n    \"samp\",\n    \"script\",\n    \"section\",\n    \"select\",\n    \"small\",\n    \"source\",\n    \"span\",\n    \"strong\",\n    \"style\",\n    \"sub\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"title\",\n    \"tr\",\n    \"track\",\n    \"u\",\n    \"ul\",\n    \"var\",\n    \"video\",\n    \"wbr\",\n    \"circle\",\n    \"clipPath\",\n    \"defs\",\n    \"ellipse\",\n    \"foreignObject\",\n    \"g\",\n    \"image\",\n    \"line\",\n    \"linearGradient\",\n    \"mask\",\n    \"path\",\n    \"pattern\",\n    \"polygon\",\n    \"polyline\",\n    \"radialGradient\",\n    \"rect\",\n    \"stop\",\n    \"svg\",\n    \"text\",\n    \"tspan\"\n];\nvar newStyled = createStyled.bind();\ntags.forEach(function(tagName) {\n    // $FlowFixMe: we can ignore this because its exposed type is defined by the CreateStyled type\n    newStyled[tagName] = newStyled(tagName);\n});\nvar classnames$1 = {\n    exports: {}\n};\n/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/ (function(module) {\n    /* global define */ (function() {\n        var hasOwn = {}.hasOwnProperty;\n        function classNames() {\n            var classes = [];\n            for(var i = 0; i < arguments.length; i++){\n                var arg = arguments[i];\n                if (!arg) continue;\n                var argType = typeof arg;\n                if (argType === \"string\" || argType === \"number\") {\n                    classes.push(arg);\n                } else if (Array.isArray(arg)) {\n                    if (arg.length) {\n                        var inner = classNames.apply(null, arg);\n                        if (inner) {\n                            classes.push(inner);\n                        }\n                    }\n                } else if (argType === \"object\") {\n                    if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes(\"[native code]\")) {\n                        classes.push(arg.toString());\n                        continue;\n                    }\n                    for(var key in arg){\n                        if (hasOwn.call(arg, key) && arg[key]) {\n                            classes.push(key);\n                        }\n                    }\n                }\n            }\n            return classes.join(\" \");\n        }\n        if (module.exports) {\n            classNames.default = classNames;\n            module.exports = classNames;\n        } else {\n            window.classNames = classNames;\n        }\n    })();\n})(classnames$1);\nvar classnames = classnames$1.exports;\nvar LegacySidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar SidebarProvider = function(_a) {\n    var children = _a.children;\n    var _b = react__WEBPACK_IMPORTED_MODULE_0___default().useState({\n        collapsed: false,\n        toggled: false,\n        broken: false,\n        rtl: false,\n        transitionDuration: 300\n    }), sidebarState = _b[0], setSidebarState = _b[1];\n    var updateSidebarState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(values) {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), values);\n        });\n    }, []);\n    var updateCollapseState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                collapsed: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.collapsed)\n            });\n        });\n    }, []);\n    var updateToggleState = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function() {\n        setSidebarState(function(prevState) {\n            return __assign(__assign({}, prevState), {\n                toggled: !Boolean(prevState === null || prevState === void 0 ? void 0 : prevState.toggled)\n            });\n        });\n    }, []);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return __assign(__assign({}, sidebarState), {\n            updateSidebarState: updateSidebarState,\n            updateCollapseState: updateCollapseState,\n            updateToggleState: updateToggleState\n        });\n    }, [\n        sidebarState,\n        updateCollapseState,\n        updateSidebarState,\n        updateToggleState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LegacySidebarContext.Provider, {\n        value: providerValue\n    }, children);\n};\nvar useLegacySidebar = function() {\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LegacySidebarContext);\n    return context;\n};\nvar useMediaQuery = function(breakpoint) {\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!breakpoint && window.matchMedia(breakpoint).matches), matches = _a[0], setMatches = _a[1];\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (breakpoint) {\n            var media_1 = window.matchMedia(breakpoint);\n            var handleMatch_1 = function() {\n                if (media_1.matches !== matches) {\n                    setMatches(media_1.matches);\n                }\n            };\n            handleMatch_1();\n            media_1.addEventListener(\"change\", handleMatch_1);\n            return function() {\n                return media_1.removeEventListener(\"change\", handleMatch_1);\n            };\n        }\n    }, [\n        matches,\n        breakpoint\n    ]);\n    return matches;\n};\nvar sidebarClasses = {\n    root: \"ps-sidebar-root\",\n    container: \"ps-sidebar-container\",\n    image: \"ps-sidebar-image\",\n    backdrop: \"ps-sidebar-backdrop\",\n    collapsed: \"ps-collapsed\",\n    toggled: \"ps-toggled\",\n    rtl: \"ps-rtl\",\n    broken: \"ps-broken\"\n};\nvar menuClasses = {\n    root: \"ps-menu-root\",\n    menuItemRoot: \"ps-menuitem-root\",\n    subMenuRoot: \"ps-submenu-root\",\n    button: \"ps-menu-button\",\n    prefix: \"ps-menu-prefix\",\n    suffix: \"ps-menu-suffix\",\n    label: \"ps-menu-label\",\n    icon: \"ps-menu-icon\",\n    subMenuContent: \"ps-submenu-content\",\n    SubMenuExpandIcon: \"ps-submenu-expand-icon\",\n    disabled: \"ps-disabled\",\n    active: \"ps-active\",\n    open: \"ps-open\"\n};\nvar StyledBackdrop = newStyled.div(templateObject_1$b || (templateObject_1$b = __makeTemplateObject([\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n], [\n    \"\\n  position: fixed;\\n  top: 0px;\\n  right: 0px;\\n  bottom: 0px;\\n  left: 0px;\\n  z-index: 1;\\n  background-color: rgb(0, 0, 0, 0.3);\\n\"\n])));\nvar templateObject_1$b;\nvar BREAK_POINTS = {\n    xs: \"480px\",\n    sm: \"576px\",\n    md: \"768px\",\n    lg: \"992px\",\n    xl: \"1200px\",\n    xxl: \"1600px\",\n    always: \"always\",\n    all: \"all\"\n};\nvar StyledSidebar = newStyled.aside(templateObject_1$a || (templateObject_1$a = __makeTemplateObject([\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  border-right-width: 1px;\\n  border-right-style: solid;\\n  border-color: #efefef;\\n\\n  transition: \",\n    \";\\n\\n  width: \",\n    \";\\n  min-width: \",\n    \";\\n\\n  &.\",\n    \" {\\n    width: \",\n    \";\\n    min-width: \",\n    \";\\n  }\\n\\n  &.\",\n    \" {\\n    direction: rtl;\\n    border-right-width: none;\\n    border-left-width: 1px;\\n    border-right-style: none;\\n    border-left-style: solid;\\n  }\\n\\n  &.\",\n    \" {\\n    position: fixed;\\n    height: 100%;\\n    top: 0px;\\n    z-index: 100;\\n\\n    \",\n    \"\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      \",\n    \"\\n    }\\n\\n    &.\",\n    \" {\\n      right: -\",\n    \";\\n\\n      &.\",\n    \" {\\n        right: -\",\n    \";\\n      }\\n\\n      &.\",\n    \" {\\n        right: 0;\\n      }\\n    }\\n  }\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return \"width, left, right, \".concat(transitionDuration, \"ms\");\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.rtl, sidebarClasses.broken, function(_a) {\n    var rtl = _a.rtl, width = _a.width;\n    return !rtl ? \"left: -\".concat(width, \";\") : \"\";\n}, sidebarClasses.collapsed, function(_a) {\n    var rtl = _a.rtl, collapsedWidth = _a.collapsedWidth;\n    return !rtl ? \"left: -\".concat(collapsedWidth, \"; \") : \"\";\n}, sidebarClasses.toggled, function(_a) {\n    var rtl = _a.rtl;\n    return !rtl ? \"left: 0;\" : \"\";\n}, sidebarClasses.rtl, function(_a) {\n    var width = _a.width;\n    return width;\n}, sidebarClasses.collapsed, function(_a) {\n    var collapsedWidth = _a.collapsedWidth;\n    return collapsedWidth;\n}, sidebarClasses.toggled, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar StyledSidebarContainer = newStyled.div(templateObject_2$1 || (templateObject_2$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n], [\n    \"\\n  position: relative;\\n  height: 100%;\\n  overflow-y: auto;\\n  overflow-x: hidden;\\n  z-index: 3;\\n\\n  \",\n    \"\\n\"\n])), function(_a) {\n    var backgroundColor = _a.backgroundColor;\n    return backgroundColor ? \"background-color:\".concat(backgroundColor, \";\") : \"\";\n});\nvar StyledSidebarImage = newStyled.img(templateObject_3$1 || (templateObject_3$1 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    width: 100%;\\n    height: 100%;\\n    object-fit: cover;\\n    object-position: center;\\n    position: absolute;\\n    left: 0;\\n    top: 0;\\n    z-index: 2;\\n  }\\n\"\n])), sidebarClasses.image);\nvar SidebarContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext({\n    collapsed: false,\n    toggled: false,\n    rtl: false,\n    transitionDuration: 300\n});\nvar Sidebar = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(function(_a, ref) {\n    var _b;\n    var collapsed = _a.collapsed, toggled = _a.toggled, onBackdropClick = _a.onBackdropClick, onBreakPoint = _a.onBreakPoint, _c = _a.width, width = _c === void 0 ? \"250px\" : _c, _d = _a.collapsedWidth, collapsedWidth = _d === void 0 ? \"80px\" : _d, defaultCollapsed = _a.defaultCollapsed, className = _a.className, children = _a.children, breakPoint = _a.breakPoint, customBreakPoint = _a.customBreakPoint, _e = _a.backgroundColor, backgroundColor = _e === void 0 ? \"rgb(249, 249, 249, 0.7)\" : _e, _f = _a.transitionDuration, transitionDuration = _f === void 0 ? 300 : _f, image = _a.image, rtl = _a.rtl, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"collapsed\",\n        \"toggled\",\n        \"onBackdropClick\",\n        \"onBreakPoint\",\n        \"width\",\n        \"collapsedWidth\",\n        \"defaultCollapsed\",\n        \"className\",\n        \"children\",\n        \"breakPoint\",\n        \"customBreakPoint\",\n        \"backgroundColor\",\n        \"transitionDuration\",\n        \"image\",\n        \"rtl\",\n        \"rootStyles\"\n    ]);\n    var getBreakpointValue = function() {\n        if (customBreakPoint) {\n            return \"(max-width: \".concat(customBreakPoint, \")\");\n        }\n        if (breakPoint) {\n            if ([\n                \"xs\",\n                \"sm\",\n                \"md\",\n                \"lg\",\n                \"xl\",\n                \"xxl\"\n            ].includes(breakPoint)) {\n                return \"(max-width: \".concat(BREAK_POINTS[breakPoint], \")\");\n            }\n            if (breakPoint === \"always\" || breakPoint === \"all\") {\n                if (breakPoint === \"always\") {\n                    console.warn('The \"always\" breakPoint is deprecated and will be removed in future release. ' + 'Please use the \"all\" breakPoint instead.');\n                }\n                return \"screen\";\n            }\n            return \"(max-width: \".concat(breakPoint, \")\");\n        }\n    };\n    var breakpointCallbackFnRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    breakpointCallbackFnRef.current = function(broken) {\n        onBreakPoint === null || onBreakPoint === void 0 ? void 0 : onBreakPoint(broken);\n    };\n    var broken = useMediaQuery(getBreakpointValue());\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _g[0], setMounted = _g[1];\n    var legacySidebarContext = useLegacySidebar();\n    var collapsedValue = collapsed !== null && collapsed !== void 0 ? collapsed : !mounted && defaultCollapsed ? true : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.collapsed;\n    var toggledValue = toggled !== null && toggled !== void 0 ? toggled : legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.toggled;\n    var handleBackdropClick = function() {\n        onBackdropClick === null || onBackdropClick === void 0 ? void 0 : onBackdropClick();\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            toggled: false\n        });\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var _a;\n        (_a = breakpointCallbackFnRef.current) === null || _a === void 0 ? void 0 : _a.call(breakpointCallbackFnRef, broken);\n    }, [\n        broken\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n            broken: broken,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        broken,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState,\n        rtl,\n        transitionDuration\n    ]);\n    // TODO: remove in next major version\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (!mounted) {\n            legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState({\n                collapsed: defaultCollapsed\n            });\n            setMounted(true);\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        defaultCollapsed,\n        mounted,\n        legacySidebarContext === null || legacySidebarContext === void 0 ? void 0 : legacySidebarContext.updateSidebarState\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarContext.Provider, {\n        value: {\n            collapsed: collapsedValue,\n            toggled: toggledValue,\n            rtl: rtl,\n            transitionDuration: transitionDuration\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebar, __assign({\n        ref: ref,\n        \"data-testid\": \"\".concat(sidebarClasses.root, \"-test-id\"),\n        rtl: rtl,\n        rootStyles: rootStyles,\n        width: width,\n        collapsedWidth: collapsedWidth,\n        transitionDuration: transitionDuration,\n        className: classnames(sidebarClasses.root, (_b = {}, _b[sidebarClasses.collapsed] = collapsedValue, _b[sidebarClasses.toggled] = toggledValue, _b[sidebarClasses.broken] = broken, _b[sidebarClasses.rtl] = rtl, _b), className)\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarContainer, {\n        \"data-testid\": \"\".concat(sidebarClasses.container, \"-test-id\"),\n        className: sidebarClasses.container,\n        backgroundColor: backgroundColor\n    }, children), image && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSidebarImage, {\n        \"data-testid\": \"\".concat(sidebarClasses.image, \"-test-id\"),\n        src: image,\n        alt: \"sidebar background\",\n        className: sidebarClasses.image\n    }), broken && toggledValue && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledBackdrop, {\n        \"data-testid\": \"\".concat(sidebarClasses.backdrop, \"-test-id\"),\n        role: \"button\",\n        tabIndex: 0,\n        \"aria-label\": \"backdrop\",\n        onClick: handleBackdropClick,\n        onKeyPress: handleBackdropClick,\n        className: sidebarClasses.backdrop\n    })));\n});\nvar templateObject_1$a, templateObject_2$1, templateObject_3$1;\nvar StyledUl = newStyled.ul(templateObject_1$9 || (templateObject_1$9 = __makeTemplateObject([\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n], [\n    \"\\n  list-style-type: none;\\n  padding: 0;\\n  margin: 0;\\n\"\n])));\nvar templateObject_1$9;\nvar StyledMenu = newStyled.nav(templateObject_1$8 || (templateObject_1$8 = __makeTemplateObject([\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n], [\n    \"\\n  &.\",\n    \" {\\n    \",\n    \"\\n  }\\n\"\n])), menuClasses.root, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar MenuContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(undefined);\nvar LevelContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createContext(0);\nvar MenuFR = function(_a, ref) {\n    var children = _a.children, className = _a.className, _b = _a.transitionDuration, transitionDuration = _b === void 0 ? 300 : _b, _c = _a.closeOnClick, closeOnClick = _c === void 0 ? false : _c, rootStyles = _a.rootStyles, menuItemStyles = _a.menuItemStyles, renderExpandIcon = _a.renderExpandIcon, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"transitionDuration\",\n        \"closeOnClick\",\n        \"rootStyles\",\n        \"menuItemStyles\",\n        \"renderExpandIcon\"\n    ]);\n    var providerValue = react__WEBPACK_IMPORTED_MODULE_0___default().useMemo(function() {\n        return {\n            transitionDuration: transitionDuration,\n            closeOnClick: closeOnClick,\n            menuItemStyles: menuItemStyles,\n            renderExpandIcon: renderExpandIcon\n        };\n    }, [\n        transitionDuration,\n        closeOnClick,\n        menuItemStyles,\n        renderExpandIcon\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuContext.Provider, {\n        value: providerValue\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: 0\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenu, __assign({\n        ref: ref,\n        className: classnames(menuClasses.root, className),\n        rootStyles: rootStyles\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children))));\n};\nvar Menu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuFR);\nvar templateObject_1$8;\nvar useMenu = function() {\n    var context = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(MenuContext);\n    if (context === undefined) {\n        //TODO: set better error message\n        throw new Error(\"Menu Component is required!\");\n    }\n    return context;\n};\nvar StyledSubMenuContent = newStyled.div(templateObject_1$7 || (templateObject_1$7 = __makeTemplateObject([\n    \"\\n  display: none;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  display: none;\\n  overflow: hidden;\\n  z-index: 999;\\n  transition: height \",\n    \"ms;\\n  box-sizing: border-box;\\n  background-color: white;\\n\\n  \",\n    \"\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed && \"\\n     background-color: white;\\n     box-shadow: 0 3px 6px -4px #0000001f, 0 6px 16px #00000014, 0 9px 28px 8px #0000000d;\\n     \";\n}, function(_a) {\n    var defaultOpen = _a.defaultOpen;\n    return defaultOpen && \"height: auto;display: block;\";\n}, function(_a) {\n    var collapsed = _a.collapsed, firstLevel = _a.firstLevel, openWhenCollapsed = _a.openWhenCollapsed;\n    return collapsed && firstLevel ? \"\\n      position: fixed;\\n      padding-left: 0px;\\n      width: 200px;\\n      border-radius: 4px;\\n      height: auto!important;\\n      display: block!important;     \\n      transition: none!important;     \\n      visibility: \".concat(openWhenCollapsed ? \"visible\" : \"hidden\", \";\\n     \") : \"\\n      position: static!important;\\n      transform: none!important;\\n      \";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar SubMenuContentFR = function(_a, ref) {\n    var children = _a.children, open = _a.open, openWhenCollapsed = _a.openWhenCollapsed, firstLevel = _a.firstLevel, collapsed = _a.collapsed, defaultOpen = _a.defaultOpen, rest = __rest(_a, [\n        \"children\",\n        \"open\",\n        \"openWhenCollapsed\",\n        \"firstLevel\",\n        \"collapsed\",\n        \"defaultOpen\"\n    ]);\n    var transitionDuration = useMenu().transitionDuration;\n    var defaultOpenState = react__WEBPACK_IMPORTED_MODULE_0___default().useState(defaultOpen)[0];\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenuContent, __assign({\n        \"data-testid\": \"\".concat(menuClasses.subMenuContent, \"-test-id\"),\n        ref: ref,\n        firstLevel: firstLevel,\n        collapsed: collapsed,\n        open: open,\n        openWhenCollapsed: openWhenCollapsed,\n        transitionDuration: transitionDuration,\n        defaultOpen: defaultOpenState\n    }, rest), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledUl, null, children));\n};\nvar SubMenuContent = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuContentFR);\nvar templateObject_1$7;\nvar StyledMenuLabel = newStyled.span(templateObject_1$6 || (templateObject_1$6 = __makeTemplateObject([\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  flex-grow: 1;\\n  overflow: hidden;\\n  text-overflow: ellipsis;\\n  white-space: nowrap;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$6;\nvar StyledMenuIcon = newStyled.span(templateObject_1$5 || (templateObject_1$5 = __makeTemplateObject([\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  width: 35px;\\n  min-width: 35px;\\n  height: 35px;\\n  line-height: 35px;\\n  text-align: center;\\n  display: inline-block;\\n  border-radius: 2px;\\n  display: flex;\\n  align-items: center;\\n  justify-content: center;\\n\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 10px;\" : \"margin-right: 10px;\";\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$5;\nvar StyledMenuPrefix = newStyled.span(templateObject_1$4 || (templateObject_1$4 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"margin-left: 5px;\" : \"margin-right: 5px;\";\n}, function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$4;\nvar StyledMenuSuffix = newStyled.span(templateObject_1$3 || (templateObject_1$3 = __makeTemplateObject([\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  margin-right: 5px;\\n  margin-left: 5px;\\n  opacity: \",\n    \";\\n  transition: opacity \",\n    \"ms;\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var firstLevel = _a.firstLevel, collapsed = _a.collapsed;\n    return firstLevel && collapsed ? \"0\" : \"1\";\n}, function(_a) {\n    var transitionDuration = _a.transitionDuration;\n    return transitionDuration;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar templateObject_1$3;\nvar StyledExpandIconWrapper = newStyled.span(templateObject_1$2 || (templateObject_1$2 = __makeTemplateObject([\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n], [\n    \"\\n  \",\n    \"\\n\\n  \",\n    \";\\n\"\n])), function(_a) {\n    var collapsed = _a.collapsed, level = _a.level, rtl = _a.rtl;\n    return collapsed && level === 0 && \"\\n    position: absolute;\\n    \".concat(rtl ? \"left: 10px;\" : \"right: 10px;\", \"\\n    top: 50%;\\n    transform: translateY(-50%);\\n    \\n    \");\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n});\nvar StyledExpandIcon = newStyled.span(templateObject_2 || (templateObject_2 = __makeTemplateObject([\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n], [\n    \"\\n  display: inline-block;\\n  transition: transform 0.3s;\\n  \",\n    \"\\n\\n  width: 5px;\\n  height: 5px;\\n  transform: rotate(\",\n    \");\\n\"\n])), function(_a) {\n    var rtl = _a.rtl;\n    return rtl ? \"\\n          border-left: 2px solid currentcolor;\\n          border-top: 2px solid currentcolor;\\n        \" : \" border-right: 2px solid currentcolor;\\n          border-bottom: 2px solid currentcolor;\\n        \";\n}, function(_a) {\n    var open = _a.open, rtl = _a.rtl;\n    return open ? rtl ? \"-135deg\" : \"45deg\" : \"-45deg\";\n});\nvar StyledExpandIconCollapsed = newStyled.span(templateObject_3 || (templateObject_3 = __makeTemplateObject([\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n], [\n    \"\\n  width: 5px;\\n  height: 5px;\\n  background-color: currentcolor;\\n  border-radius: 50%;\\n  display: inline-block;\\n\"\n])));\nvar templateObject_1$2, templateObject_2, templateObject_3;\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [\n    top,\n    bottom,\n    right,\n    left\n];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n    return acc.concat([\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []);\nvar placements = /*#__PURE__*/ [].concat(basePlacements, [\n    auto\n]).reduce(function(acc, placement) {\n    return acc.concat([\n        placement,\n        placement + \"-\" + start,\n        placement + \"-\" + end\n    ]);\n}, []); // modifiers that need to read the DOM\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\"; // pure-logic modifiers\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [\n    beforeRead,\n    read,\n    afterRead,\n    beforeMain,\n    main,\n    afterMain,\n    beforeWrite,\n    write,\n    afterWrite\n];\nfunction getNodeName(element) {\n    return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n    if (node == null) {\n        return window;\n    }\n    if (node.toString() !== \"[object Window]\") {\n        var ownerDocument = node.ownerDocument;\n        return ownerDocument ? ownerDocument.defaultView || window : window;\n    }\n    return node;\n}\nfunction isElement(node) {\n    var OwnElement = getWindow(node).Element;\n    return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n    var OwnElement = getWindow(node).HTMLElement;\n    return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n    // IE 11 has no ShadowRoot\n    if (typeof ShadowRoot === \"undefined\") {\n        return false;\n    }\n    var OwnElement = getWindow(node).ShadowRoot;\n    return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n// and applies them to the HTMLElements such as popper and arrow\nfunction applyStyles(_ref) {\n    var state = _ref.state;\n    Object.keys(state.elements).forEach(function(name) {\n        var style = state.styles[name] || {};\n        var attributes = state.attributes[name] || {};\n        var element = state.elements[name]; // arrow is optional + virtual elements\n        if (!isHTMLElement(element) || !getNodeName(element)) {\n            return;\n        } // Flow doesn't support to extend this property, but it's the most\n        // effective way to apply styles to an HTMLElement\n        // $FlowFixMe[cannot-write]\n        Object.assign(element.style, style);\n        Object.keys(attributes).forEach(function(name) {\n            var value = attributes[name];\n            if (value === false) {\n                element.removeAttribute(name);\n            } else {\n                element.setAttribute(name, value === true ? \"\" : value);\n            }\n        });\n    });\n}\nfunction effect$2(_ref2) {\n    var state = _ref2.state;\n    var initialStyles = {\n        popper: {\n            position: state.options.strategy,\n            left: \"0\",\n            top: \"0\",\n            margin: \"0\"\n        },\n        arrow: {\n            position: \"absolute\"\n        },\n        reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n    if (state.elements.arrow) {\n        Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    }\n    return function() {\n        Object.keys(state.elements).forEach(function(name) {\n            var element = state.elements[name];\n            var attributes = state.attributes[name] || {};\n            var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n            var style = styleProperties.reduce(function(style, property) {\n                style[property] = \"\";\n                return style;\n            }, {}); // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            }\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(attribute) {\n                element.removeAttribute(attribute);\n            });\n        });\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar applyStyles$1 = {\n    name: \"applyStyles\",\n    enabled: true,\n    phase: \"write\",\n    fn: applyStyles,\n    effect: effect$2,\n    requires: [\n        \"computeStyles\"\n    ]\n};\nfunction getBasePlacement(placement) {\n    return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n    var uaData = navigator.userAgentData;\n    if (uaData != null && uaData.brands) {\n        return uaData.brands.map(function(item) {\n            return item.brand + \"/\" + item.version;\n        }).join(\" \");\n    }\n    return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n    if (includeScale === void 0) {\n        includeScale = false;\n    }\n    if (isFixedStrategy === void 0) {\n        isFixedStrategy = false;\n    }\n    var clientRect = element.getBoundingClientRect();\n    var scaleX = 1;\n    var scaleY = 1;\n    if (includeScale && isHTMLElement(element)) {\n        scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n        scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n    }\n    var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n    var width = clientRect.width / scaleX;\n    var height = clientRect.height / scaleY;\n    return {\n        width: width,\n        height: height,\n        top: y,\n        right: x + width,\n        bottom: y + height,\n        left: x,\n        x: x,\n        y: y\n    };\n}\n// means it doesn't take into account transforms.\nfunction getLayoutRect(element) {\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\n    var width = element.offsetWidth;\n    var height = element.offsetHeight;\n    if (Math.abs(clientRect.width - width) <= 1) {\n        width = clientRect.width;\n    }\n    if (Math.abs(clientRect.height - height) <= 1) {\n        height = clientRect.height;\n    }\n    return {\n        x: element.offsetLeft,\n        y: element.offsetTop,\n        width: width,\n        height: height\n    };\n}\nfunction contains(parent, child) {\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n    if (parent.contains(child)) {\n        return true;\n    } else if (rootNode && isShadowRoot(rootNode)) {\n        var next = child;\n        do {\n            if (next && parent.isSameNode(next)) {\n                return true;\n            } // $FlowFixMe[prop-missing]: need a better way to handle this...\n            next = next.parentNode || next.host;\n        }while (next);\n    } // Give up, the result is false\n    return false;\n}\nfunction getComputedStyle(element) {\n    return getWindow(element).getComputedStyle(element);\n}\nfunction isTableElement(element) {\n    return [\n        \"table\",\n        \"td\",\n        \"th\"\n    ].indexOf(getNodeName(element)) >= 0;\n}\nfunction getDocumentElement(element) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getParentNode(element) {\n    if (getNodeName(element) === \"html\") {\n        return element;\n    }\n    return(// $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n    );\n}\nfunction getTrueOffsetParent(element) {\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n    getComputedStyle(element).position === \"fixed\") {\n        return null;\n    }\n    return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\nfunction getContainingBlock(element) {\n    var isFirefox = /firefox/i.test(getUAString());\n    var isIE = /Trident/i.test(getUAString());\n    if (isIE && isHTMLElement(element)) {\n        // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n        var elementCss = getComputedStyle(element);\n        if (elementCss.position === \"fixed\") {\n            return null;\n        }\n    }\n    var currentNode = getParentNode(element);\n    if (isShadowRoot(currentNode)) {\n        currentNode = currentNode.host;\n    }\n    while(isHTMLElement(currentNode) && [\n        \"html\",\n        \"body\"\n    ].indexOf(getNodeName(currentNode)) < 0){\n        var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n        // create a containing block.\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n        if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n            \"transform\",\n            \"perspective\"\n        ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n            return currentNode;\n        } else {\n            currentNode = currentNode.parentNode;\n        }\n    }\n    return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element) {\n    var window1 = getWindow(element);\n    var offsetParent = getTrueOffsetParent(element);\n    while(offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\"){\n        offsetParent = getTrueOffsetParent(offsetParent);\n    }\n    if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n        return window1;\n    }\n    return offsetParent || getContainingBlock(element) || window1;\n}\nfunction getMainAxisFromPlacement(placement) {\n    return [\n        \"top\",\n        \"bottom\"\n    ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value, max$1) {\n    return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min, value, max) {\n    var v = within(min, value, max);\n    return v > max ? max : v;\n}\nfunction getFreshSideObject() {\n    return {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n    };\n}\nfunction mergePaddingObject(paddingObject) {\n    return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n    return keys.reduce(function(hashMap, key) {\n        hashMap[key] = value;\n        return hashMap;\n    }, {});\n}\nvar toPaddingObject = function toPaddingObject(padding, state) {\n    padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : padding;\n    return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n    var _state$modifiersData$;\n    var state = _ref.state, name = _ref.name, options = _ref.options;\n    var arrowElement = state.elements.arrow;\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var basePlacement = getBasePlacement(state.placement);\n    var axis = getMainAxisFromPlacement(basePlacement);\n    var isVertical = [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0;\n    var len = isVertical ? \"height\" : \"width\";\n    if (!arrowElement || !popperOffsets) {\n        return;\n    }\n    var paddingObject = toPaddingObject(options.padding, state);\n    var arrowRect = getLayoutRect(arrowElement);\n    var minProp = axis === \"y\" ? top : left;\n    var maxProp = axis === \"y\" ? bottom : right;\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n    var arrowOffsetParent = getOffsetParent(arrowElement);\n    var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n    // outside of the popper bounds\n    var min = paddingObject[minProp];\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n    var axisProp = axis;\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n    var state = _ref2.state, options = _ref2.options;\n    var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n    if (arrowElement == null) {\n        return;\n    } // CSS selector\n    if (typeof arrowElement === \"string\") {\n        arrowElement = state.elements.popper.querySelector(arrowElement);\n        if (!arrowElement) {\n            return;\n        }\n    }\n    if (true) {\n        if (!isHTMLElement(arrowElement)) {\n            console.error([\n                'Popper: \"arrow\" element must be an HTMLElement (not an SVGElement).',\n                \"To use an SVG arrow, wrap it in an HTMLElement that will be used as\",\n                \"the arrow.\"\n            ].join(\" \"));\n        }\n    }\n    if (!contains(state.elements.popper, arrowElement)) {\n        if (true) {\n            console.error([\n                'Popper: \"arrow\" modifier\\'s `element` must be a child of the popper',\n                \"element.\"\n            ].join(\" \"));\n        }\n        return;\n    }\n    state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\nvar arrow$1 = {\n    name: \"arrow\",\n    enabled: true,\n    phase: \"main\",\n    fn: arrow,\n    effect: effect$1,\n    requires: [\n        \"popperOffsets\"\n    ],\n    requiresIfExists: [\n        \"preventOverflow\"\n    ]\n};\nfunction getVariation(placement) {\n    return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n    top: \"auto\",\n    right: \"auto\",\n    bottom: \"auto\",\n    left: \"auto\"\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\nfunction roundOffsetsByDPR(_ref) {\n    var x = _ref.x, y = _ref.y;\n    var win = window;\n    var dpr = win.devicePixelRatio || 1;\n    return {\n        x: round(x * dpr) / dpr || 0,\n        y: round(y * dpr) / dpr || 0\n    };\n}\nfunction mapToStyles(_ref2) {\n    var _Object$assign2;\n    var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n    var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n    var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref3.x;\n    y = _ref3.y;\n    var hasX = offsets.hasOwnProperty(\"x\");\n    var hasY = offsets.hasOwnProperty(\"y\");\n    var sideX = left;\n    var sideY = top;\n    var win = window;\n    if (adaptive) {\n        var offsetParent = getOffsetParent(popper);\n        var heightProp = \"clientHeight\";\n        var widthProp = \"clientWidth\";\n        if (offsetParent === getWindow(popper)) {\n            offsetParent = getDocumentElement(popper);\n            if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n                heightProp = \"scrollHeight\";\n                widthProp = \"scrollWidth\";\n            }\n        } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n        offsetParent = offsetParent;\n        if (placement === top || (placement === left || placement === right) && variation === end) {\n            sideY = bottom;\n            var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n            y -= offsetY - popperRect.height;\n            y *= gpuAcceleration ? 1 : -1;\n        }\n        if (placement === left || (placement === top || placement === bottom) && variation === end) {\n            sideX = right;\n            var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n            x -= offsetX - popperRect.width;\n            x *= gpuAcceleration ? 1 : -1;\n        }\n    }\n    var commonStyles = Object.assign({\n        position: position\n    }, adaptive && unsetSides);\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n        x: x,\n        y: y\n    }) : {\n        x: x,\n        y: y\n    };\n    x = _ref4.x;\n    y = _ref4.y;\n    if (gpuAcceleration) {\n        var _Object$assign;\n        return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n    }\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n    var state = _ref5.state, options = _ref5.options;\n    var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n    if (true) {\n        var transitionProperty = getComputedStyle(state.elements.popper).transitionProperty || \"\";\n        if (adaptive && [\n            \"transform\",\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ].some(function(property) {\n            return transitionProperty.indexOf(property) >= 0;\n        })) {\n            console.warn([\n                \"Popper: Detected CSS transitions on at least one of the following\",\n                'CSS properties: \"transform\", \"top\", \"right\", \"bottom\", \"left\".',\n                \"\\n\\n\",\n                'Disable the \"computeStyles\" modifier\\'s `adaptive` option to allow',\n                \"for smooth transitions, or remove these properties from the CSS\",\n                \"transition declaration on the popper element if only transitioning\",\n                \"opacity or background-color for example.\",\n                \"\\n\\n\",\n                \"We recommend using the popper element as a wrapper around an inner\",\n                \"element that can have any CSS property transitioned for animations.\"\n            ].join(\" \"));\n        }\n    }\n    var commonStyles = {\n        placement: getBasePlacement(state.placement),\n        variation: getVariation(state.placement),\n        popper: state.elements.popper,\n        popperRect: state.rects.popper,\n        gpuAcceleration: gpuAcceleration,\n        isFixed: state.options.strategy === \"fixed\"\n    };\n    if (state.modifiersData.popperOffsets != null) {\n        state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.popperOffsets,\n            position: state.options.strategy,\n            adaptive: adaptive,\n            roundOffsets: roundOffsets\n        })));\n    }\n    if (state.modifiersData.arrow != null) {\n        state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n            offsets: state.modifiersData.arrow,\n            position: \"absolute\",\n            adaptive: false,\n            roundOffsets: roundOffsets\n        })));\n    }\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-placement\": state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar computeStyles$1 = {\n    name: \"computeStyles\",\n    enabled: true,\n    phase: \"beforeWrite\",\n    fn: computeStyles,\n    data: {}\n};\nvar passive = {\n    passive: true\n};\nfunction effect(_ref) {\n    var state = _ref.state, instance = _ref.instance, options = _ref.options;\n    var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n    var window1 = getWindow(state.elements.popper);\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n    if (scroll) {\n        scrollParents.forEach(function(scrollParent) {\n            scrollParent.addEventListener(\"scroll\", instance.update, passive);\n        });\n    }\n    if (resize) {\n        window1.addEventListener(\"resize\", instance.update, passive);\n    }\n    return function() {\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.removeEventListener(\"resize\", instance.update, passive);\n        }\n    };\n} // eslint-disable-next-line import/no-unused-modules\nvar eventListeners = {\n    name: \"eventListeners\",\n    enabled: true,\n    phase: \"write\",\n    fn: function fn() {},\n    effect: effect,\n    data: {}\n};\nvar hash$1 = {\n    left: \"right\",\n    right: \"left\",\n    bottom: \"top\",\n    top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n    return placement.replace(/left|right|bottom|top/g, function(matched) {\n        return hash$1[matched];\n    });\n}\nvar hash = {\n    start: \"end\",\n    end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n    return placement.replace(/start|end/g, function(matched) {\n        return hash[matched];\n    });\n}\nfunction getWindowScroll(node) {\n    var win = getWindow(node);\n    var scrollLeft = win.pageXOffset;\n    var scrollTop = win.pageYOffset;\n    return {\n        scrollLeft: scrollLeft,\n        scrollTop: scrollTop\n    };\n}\nfunction getWindowScrollBarX(element) {\n    // If <html> has a CSS width greater than the viewport, then this will be\n    // incorrect for RTL.\n    // Popper 1 is broken in this case and never had a bug report so let's assume\n    // it's not an issue. I don't think anyone ever specifies width on <html>\n    // anyway.\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\n    // this (e.g. Edge 2019, IE11, Safari)\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getViewportRect(element, strategy) {\n    var win = getWindow(element);\n    var html = getDocumentElement(element);\n    var visualViewport = win.visualViewport;\n    var width = html.clientWidth;\n    var height = html.clientHeight;\n    var x = 0;\n    var y = 0;\n    if (visualViewport) {\n        width = visualViewport.width;\n        height = visualViewport.height;\n        var layoutViewport = isLayoutViewport();\n        if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n            x = visualViewport.offsetLeft;\n            y = visualViewport.offsetTop;\n        }\n    }\n    return {\n        width: width,\n        height: height,\n        x: x + getWindowScrollBarX(element),\n        y: y\n    };\n}\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\nfunction getDocumentRect(element) {\n    var _element$ownerDocumen;\n    var html = getDocumentElement(element);\n    var winScroll = getWindowScroll(element);\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n    var y = -winScroll.scrollTop;\n    if (getComputedStyle(body || html).direction === \"rtl\") {\n        x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n    }\n    return {\n        width: width,\n        height: height,\n        x: x,\n        y: y\n    };\n}\nfunction isScrollParent(element) {\n    // Firefox wants us to check `-x` and `-y` variations as well\n    var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n    if ([\n        \"html\",\n        \"body\",\n        \"#document\"\n    ].indexOf(getNodeName(node)) >= 0) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return node.ownerDocument.body;\n    }\n    if (isHTMLElement(node) && isScrollParent(node)) {\n        return node;\n    }\n    return getScrollParent(getParentNode(node));\n}\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/ function listScrollParents(element, list) {\n    var _element$ownerDocumen;\n    if (list === void 0) {\n        list = [];\n    }\n    var scrollParent = getScrollParent(element);\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n    var win = getWindow(scrollParent);\n    var target = isBody ? [\n        win\n    ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n    var updatedList = list.concat(target);\n    return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction rectToClientRect(rect) {\n    return Object.assign({}, rect, {\n        left: rect.x,\n        top: rect.y,\n        right: rect.x + rect.width,\n        bottom: rect.y + rect.height\n    });\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n    var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n    rect.top = rect.top + element.clientTop;\n    rect.left = rect.left + element.clientLeft;\n    rect.bottom = rect.top + element.clientHeight;\n    rect.right = rect.left + element.clientWidth;\n    rect.width = element.clientWidth;\n    rect.height = element.clientHeight;\n    rect.x = rect.left;\n    rect.y = rect.top;\n    return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\nfunction getClippingParents(element) {\n    var clippingParents = listScrollParents(getParentNode(element));\n    var canEscapeClipping = [\n        \"absolute\",\n        \"fixed\"\n    ].indexOf(getComputedStyle(element).position) >= 0;\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n    if (!isElement(clipperElement)) {\n        return [];\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n    return clippingParents.filter(function(clippingParent) {\n        return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n    });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n    var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n    var clippingParents = [].concat(mainClippingParents, [\n        rootBoundary\n    ]);\n    var firstClippingParent = clippingParents[0];\n    var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n        var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n        accRect.top = max(rect.top, accRect.top);\n        accRect.right = min(rect.right, accRect.right);\n        accRect.bottom = min(rect.bottom, accRect.bottom);\n        accRect.left = max(rect.left, accRect.left);\n        return accRect;\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n    clippingRect.width = clippingRect.right - clippingRect.left;\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\n    clippingRect.x = clippingRect.left;\n    clippingRect.y = clippingRect.top;\n    return clippingRect;\n}\nfunction computeOffsets(_ref) {\n    var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n    var basePlacement = placement ? getBasePlacement(placement) : null;\n    var variation = placement ? getVariation(placement) : null;\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\n    var offsets;\n    switch(basePlacement){\n        case top:\n            offsets = {\n                x: commonX,\n                y: reference.y - element.height\n            };\n            break;\n        case bottom:\n            offsets = {\n                x: commonX,\n                y: reference.y + reference.height\n            };\n            break;\n        case right:\n            offsets = {\n                x: reference.x + reference.width,\n                y: commonY\n            };\n            break;\n        case left:\n            offsets = {\n                x: reference.x - element.width,\n                y: commonY\n            };\n            break;\n        default:\n            offsets = {\n                x: reference.x,\n                y: reference.y\n            };\n    }\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n    if (mainAxis != null) {\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        switch(variation){\n            case start:\n                offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                break;\n            case end:\n                offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                break;\n        }\n    }\n    return offsets;\n}\nfunction detectOverflow(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n    var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    var altContext = elementContext === popper ? reference : popper;\n    var popperRect = state.rects.popper;\n    var element = state.elements[altBoundary ? altContext : elementContext];\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\n    var popperOffsets = computeOffsets({\n        reference: referenceClientRect,\n        element: popperRect,\n        strategy: \"absolute\",\n        placement: placement\n    });\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n    // 0 or negative = within the clipping rect\n    var overflowOffsets = {\n        top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n        bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n        left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n        right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n    };\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n    if (elementContext === popper && offsetData) {\n        var offset = offsetData[placement];\n        Object.keys(overflowOffsets).forEach(function(key) {\n            var multiply = [\n                right,\n                bottom\n            ].indexOf(key) >= 0 ? 1 : -1;\n            var axis = [\n                top,\n                bottom\n            ].indexOf(key) >= 0 ? \"y\" : \"x\";\n            overflowOffsets[key] += offset[axis] * multiply;\n        });\n    }\n    return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n    var variation = getVariation(placement);\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n        return getVariation(placement) === variation;\n    }) : basePlacements;\n    var allowedPlacements = placements$1.filter(function(placement) {\n        return allowedAutoPlacements.indexOf(placement) >= 0;\n    });\n    if (allowedPlacements.length === 0) {\n        allowedPlacements = placements$1;\n        if (true) {\n            console.error([\n                \"Popper: The `allowedAutoPlacements` option did not allow any\",\n                \"placements. Ensure the `placement` option matches the variation\",\n                \"of the allowed placements.\",\n                'For example, \"auto\" cannot be used to allow \"bottom-start\".',\n                'Use \"auto-start\" instead.'\n            ].join(\" \"));\n        }\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n    var overflows = allowedPlacements.reduce(function(acc, placement) {\n        acc[placement] = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding\n        })[getBasePlacement(placement)];\n        return acc;\n    }, {});\n    return Object.keys(overflows).sort(function(a, b) {\n        return overflows[a] - overflows[b];\n    });\n}\nfunction getExpandedFallbackPlacements(placement) {\n    if (getBasePlacement(placement) === auto) {\n        return [];\n    }\n    var oppositePlacement = getOppositePlacement(placement);\n    return [\n        getOppositeVariationPlacement(placement),\n        oppositePlacement,\n        getOppositeVariationPlacement(oppositePlacement)\n    ];\n}\nfunction flip(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    if (state.modifiersData[name]._skip) {\n        return;\n    }\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n    var preferredPlacement = state.options.placement;\n    var basePlacement = getBasePlacement(preferredPlacement);\n    var isBasePlacement = basePlacement === preferredPlacement;\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n        getOppositePlacement(preferredPlacement)\n    ] : getExpandedFallbackPlacements(preferredPlacement));\n    var placements = [\n        preferredPlacement\n    ].concat(fallbackPlacements).reduce(function(acc, placement) {\n        return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            flipVariations: flipVariations,\n            allowedAutoPlacements: allowedAutoPlacements\n        }) : placement);\n    }, []);\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var checksMap = new Map();\n    var makeFallbackChecks = true;\n    var firstFittingPlacement = placements[0];\n    for(var i = 0; i < placements.length; i++){\n        var placement = placements[i];\n        var _basePlacement = getBasePlacement(placement);\n        var isStartVariation = getVariation(placement) === start;\n        var isVertical = [\n            top,\n            bottom\n        ].indexOf(_basePlacement) >= 0;\n        var len = isVertical ? \"width\" : \"height\";\n        var overflow = detectOverflow(state, {\n            placement: placement,\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            altBoundary: altBoundary,\n            padding: padding\n        });\n        var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n        if (referenceRect[len] > popperRect[len]) {\n            mainVariationSide = getOppositePlacement(mainVariationSide);\n        }\n        var altVariationSide = getOppositePlacement(mainVariationSide);\n        var checks = [];\n        if (checkMainAxis) {\n            checks.push(overflow[_basePlacement] <= 0);\n        }\n        if (checkAltAxis) {\n            checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n        }\n        if (checks.every(function(check) {\n            return check;\n        })) {\n            firstFittingPlacement = placement;\n            makeFallbackChecks = false;\n            break;\n        }\n        checksMap.set(placement, checks);\n    }\n    if (makeFallbackChecks) {\n        // `2` may be desired in some cases – research later\n        var numberOfChecks = flipVariations ? 3 : 1;\n        var _loop = function _loop(_i) {\n            var fittingPlacement = placements.find(function(placement) {\n                var checks = checksMap.get(placement);\n                if (checks) {\n                    return checks.slice(0, _i).every(function(check) {\n                        return check;\n                    });\n                }\n            });\n            if (fittingPlacement) {\n                firstFittingPlacement = fittingPlacement;\n                return \"break\";\n            }\n        };\n        for(var _i = numberOfChecks; _i > 0; _i--){\n            var _ret = _loop(_i);\n            if (_ret === \"break\") break;\n        }\n    }\n    if (state.placement !== firstFittingPlacement) {\n        state.modifiersData[name]._skip = true;\n        state.placement = firstFittingPlacement;\n        state.reset = true;\n    }\n} // eslint-disable-next-line import/no-unused-modules\nvar flip$1 = {\n    name: \"flip\",\n    enabled: true,\n    phase: \"main\",\n    fn: flip,\n    requiresIfExists: [\n        \"offset\"\n    ],\n    data: {\n        _skip: false\n    }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n    if (preventedOffsets === void 0) {\n        preventedOffsets = {\n            x: 0,\n            y: 0\n        };\n    }\n    return {\n        top: overflow.top - rect.height - preventedOffsets.y,\n        right: overflow.right - rect.width + preventedOffsets.x,\n        bottom: overflow.bottom - rect.height + preventedOffsets.y,\n        left: overflow.left - rect.width - preventedOffsets.x\n    };\n}\nfunction isAnySideFullyClipped(overflow) {\n    return [\n        top,\n        right,\n        bottom,\n        left\n    ].some(function(side) {\n        return overflow[side] >= 0;\n    });\n}\nfunction hide(_ref) {\n    var state = _ref.state, name = _ref.name;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var preventedOffsets = state.modifiersData.preventOverflow;\n    var referenceOverflow = detectOverflow(state, {\n        elementContext: \"reference\"\n    });\n    var popperAltOverflow = detectOverflow(state, {\n        altBoundary: true\n    });\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n    state.modifiersData[name] = {\n        referenceClippingOffsets: referenceClippingOffsets,\n        popperEscapeOffsets: popperEscapeOffsets,\n        isReferenceHidden: isReferenceHidden,\n        hasPopperEscaped: hasPopperEscaped\n    };\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\n        \"data-popper-reference-hidden\": isReferenceHidden,\n        \"data-popper-escaped\": hasPopperEscaped\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar hide$1 = {\n    name: \"hide\",\n    enabled: true,\n    phase: \"main\",\n    requiresIfExists: [\n        \"preventOverflow\"\n    ],\n    fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset) {\n    var basePlacement = getBasePlacement(placement);\n    var invertDistance = [\n        left,\n        top\n    ].indexOf(basePlacement) >= 0 ? -1 : 1;\n    var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n        placement: placement\n    })) : offset, skidding = _ref[0], distance = _ref[1];\n    skidding = skidding || 0;\n    distance = (distance || 0) * invertDistance;\n    return [\n        left,\n        right\n    ].indexOf(basePlacement) >= 0 ? {\n        x: distance,\n        y: skidding\n    } : {\n        x: skidding,\n        y: distance\n    };\n}\nfunction offset(_ref2) {\n    var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n    var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n        0,\n        0\n    ] : _options$offset;\n    var data = placements.reduce(function(acc, placement) {\n        acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n        return acc;\n    }, {});\n    var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n    if (state.modifiersData.popperOffsets != null) {\n        state.modifiersData.popperOffsets.x += x;\n        state.modifiersData.popperOffsets.y += y;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar offset$1 = {\n    name: \"offset\",\n    enabled: true,\n    phase: \"main\",\n    requires: [\n        \"popperOffsets\"\n    ],\n    fn: offset\n};\nfunction popperOffsets(_ref) {\n    var state = _ref.state, name = _ref.name;\n    // Offsets are the actual position the popper needs to have to be\n    // properly positioned near its reference element\n    // This is the most basic placement, and will be adjusted by\n    // the modifiers in the next step\n    state.modifiersData[name] = computeOffsets({\n        reference: state.rects.reference,\n        element: state.rects.popper,\n        strategy: \"absolute\",\n        placement: state.placement\n    });\n} // eslint-disable-next-line import/no-unused-modules\nvar popperOffsets$1 = {\n    name: \"popperOffsets\",\n    enabled: true,\n    phase: \"read\",\n    fn: popperOffsets,\n    data: {}\n};\nfunction getAltAxis(axis) {\n    return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n    var state = _ref.state, options = _ref.options, name = _ref.name;\n    var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n    var overflow = detectOverflow(state, {\n        boundary: boundary,\n        rootBoundary: rootBoundary,\n        padding: padding,\n        altBoundary: altBoundary\n    });\n    var basePlacement = getBasePlacement(state.placement);\n    var variation = getVariation(state.placement);\n    var isBasePlacement = !variation;\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\n    var altAxis = getAltAxis(mainAxis);\n    var popperOffsets = state.modifiersData.popperOffsets;\n    var referenceRect = state.rects.reference;\n    var popperRect = state.rects.popper;\n    var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n        placement: state.placement\n    })) : tetherOffset;\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n        mainAxis: tetherOffsetValue,\n        altAxis: tetherOffsetValue\n    } : Object.assign({\n        mainAxis: 0,\n        altAxis: 0\n    }, tetherOffsetValue);\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n    var data = {\n        x: 0,\n        y: 0\n    };\n    if (!popperOffsets) {\n        return;\n    }\n    if (checkMainAxis) {\n        var _offsetModifierState$;\n        var mainSide = mainAxis === \"y\" ? top : left;\n        var altSide = mainAxis === \"y\" ? bottom : right;\n        var len = mainAxis === \"y\" ? \"height\" : \"width\";\n        var offset = popperOffsets[mainAxis];\n        var min$1 = offset + overflow[mainSide];\n        var max$1 = offset - overflow[altSide];\n        var additive = tether ? -popperRect[len] / 2 : 0;\n        var minLen = variation === start ? referenceRect[len] : popperRect[len];\n        var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n        // outside the reference bounds\n        var arrowElement = state.elements.arrow;\n        var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n            width: 0,\n            height: 0\n        };\n        var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n        var arrowPaddingMin = arrowPaddingObject[mainSide];\n        var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n        // to include its full size in the calculation. If the reference is small\n        // and near the edge of a boundary, the popper can overflow even if the\n        // reference is not overflowing as well (e.g. virtual elements with no\n        // width or height)\n        var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n        var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n        var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n        var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n        var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n        var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n        var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n        var tetherMax = offset + maxOffset - offsetModifierValue;\n        var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n        popperOffsets[mainAxis] = preventedOffset;\n        data[mainAxis] = preventedOffset - offset;\n    }\n    if (checkAltAxis) {\n        var _offsetModifierState$2;\n        var _mainSide = mainAxis === \"x\" ? top : left;\n        var _altSide = mainAxis === \"x\" ? bottom : right;\n        var _offset = popperOffsets[altAxis];\n        var _len = altAxis === \"y\" ? \"height\" : \"width\";\n        var _min = _offset + overflow[_mainSide];\n        var _max = _offset - overflow[_altSide];\n        var isOriginSide = [\n            top,\n            left\n        ].indexOf(basePlacement) !== -1;\n        var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n        var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n        var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n        var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n        popperOffsets[altAxis] = _preventedOffset;\n        data[altAxis] = _preventedOffset - _offset;\n    }\n    state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\nvar preventOverflow$1 = {\n    name: \"preventOverflow\",\n    enabled: true,\n    phase: \"main\",\n    fn: preventOverflow,\n    requiresIfExists: [\n        \"offset\"\n    ]\n};\nfunction getHTMLElementScroll(element) {\n    return {\n        scrollLeft: element.scrollLeft,\n        scrollTop: element.scrollTop\n    };\n}\nfunction getNodeScroll(node) {\n    if (node === getWindow(node) || !isHTMLElement(node)) {\n        return getWindowScroll(node);\n    } else {\n        return getHTMLElementScroll(node);\n    }\n}\nfunction isElementScaled(element) {\n    var rect = element.getBoundingClientRect();\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\n    return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n    if (isFixed === void 0) {\n        isFixed = false;\n    }\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n    var documentElement = getDocumentElement(offsetParent);\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n    var scroll = {\n        scrollLeft: 0,\n        scrollTop: 0\n    };\n    var offsets = {\n        x: 0,\n        y: 0\n    };\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n        if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n        isScrollParent(documentElement)) {\n            scroll = getNodeScroll(offsetParent);\n        }\n        if (isHTMLElement(offsetParent)) {\n            offsets = getBoundingClientRect(offsetParent, true);\n            offsets.x += offsetParent.clientLeft;\n            offsets.y += offsetParent.clientTop;\n        } else if (documentElement) {\n            offsets.x = getWindowScrollBarX(documentElement);\n        }\n    }\n    return {\n        x: rect.left + scroll.scrollLeft - offsets.x,\n        y: rect.top + scroll.scrollTop - offsets.y,\n        width: rect.width,\n        height: rect.height\n    };\n}\nfunction order(modifiers) {\n    var map = new Map();\n    var visited = new Set();\n    var result = [];\n    modifiers.forEach(function(modifier) {\n        map.set(modifier.name, modifier);\n    }); // On visiting object, check for its dependencies and visit them recursively\n    function sort(modifier) {\n        visited.add(modifier.name);\n        var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n        requires.forEach(function(dep) {\n            if (!visited.has(dep)) {\n                var depModifier = map.get(dep);\n                if (depModifier) {\n                    sort(depModifier);\n                }\n            }\n        });\n        result.push(modifier);\n    }\n    modifiers.forEach(function(modifier) {\n        if (!visited.has(modifier.name)) {\n            // check for visited object\n            sort(modifier);\n        }\n    });\n    return result;\n}\nfunction orderModifiers(modifiers) {\n    // order based on dependencies\n    var orderedModifiers = order(modifiers); // order based on phase\n    return modifierPhases.reduce(function(acc, phase) {\n        return acc.concat(orderedModifiers.filter(function(modifier) {\n            return modifier.phase === phase;\n        }));\n    }, []);\n}\nfunction debounce(fn) {\n    var pending;\n    return function() {\n        if (!pending) {\n            pending = new Promise(function(resolve) {\n                Promise.resolve().then(function() {\n                    pending = undefined;\n                    resolve(fn());\n                });\n            });\n        }\n        return pending;\n    };\n}\nfunction format(str) {\n    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n        args[_key - 1] = arguments[_key];\n    }\n    return [].concat(args).reduce(function(p, c) {\n        return p.replace(/%s/, c);\n    }, str);\n}\nvar INVALID_MODIFIER_ERROR = 'Popper: modifier \"%s\" provided an invalid %s property, expected %s but got %s';\nvar MISSING_DEPENDENCY_ERROR = 'Popper: modifier \"%s\" requires \"%s\", but \"%s\" modifier is not available';\nvar VALID_PROPERTIES = [\n    \"name\",\n    \"enabled\",\n    \"phase\",\n    \"fn\",\n    \"effect\",\n    \"requires\",\n    \"options\"\n];\nfunction validateModifiers(modifiers) {\n    modifiers.forEach(function(modifier) {\n        [].concat(Object.keys(modifier), VALID_PROPERTIES) // IE11-compatible replacement for `new Set(iterable)`\n        .filter(function(value, index, self) {\n            return self.indexOf(value) === index;\n        }).forEach(function(key) {\n            switch(key){\n                case \"name\":\n                    if (typeof modifier.name !== \"string\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, String(modifier.name), '\"name\"', '\"string\"', '\"' + String(modifier.name) + '\"'));\n                    }\n                    break;\n                case \"enabled\":\n                    if (typeof modifier.enabled !== \"boolean\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"enabled\"', '\"boolean\"', '\"' + String(modifier.enabled) + '\"'));\n                    }\n                    break;\n                case \"phase\":\n                    if (modifierPhases.indexOf(modifier.phase) < 0) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"phase\"', \"either \" + modifierPhases.join(\", \"), '\"' + String(modifier.phase) + '\"'));\n                    }\n                    break;\n                case \"fn\":\n                    if (typeof modifier.fn !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"fn\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"effect\":\n                    if (modifier.effect != null && typeof modifier.effect !== \"function\") {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"effect\"', '\"function\"', '\"' + String(modifier.fn) + '\"'));\n                    }\n                    break;\n                case \"requires\":\n                    if (modifier.requires != null && !Array.isArray(modifier.requires)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requires\"', '\"array\"', '\"' + String(modifier.requires) + '\"'));\n                    }\n                    break;\n                case \"requiresIfExists\":\n                    if (!Array.isArray(modifier.requiresIfExists)) {\n                        console.error(format(INVALID_MODIFIER_ERROR, modifier.name, '\"requiresIfExists\"', '\"array\"', '\"' + String(modifier.requiresIfExists) + '\"'));\n                    }\n                    break;\n                case \"options\":\n                case \"data\":\n                    break;\n                default:\n                    console.error('PopperJS: an invalid property has been provided to the \"' + modifier.name + '\" modifier, valid properties are ' + VALID_PROPERTIES.map(function(s) {\n                        return '\"' + s + '\"';\n                    }).join(\", \") + '; but \"' + key + '\" was provided.');\n            }\n            modifier.requires && modifier.requires.forEach(function(requirement) {\n                if (modifiers.find(function(mod) {\n                    return mod.name === requirement;\n                }) == null) {\n                    console.error(format(MISSING_DEPENDENCY_ERROR, String(modifier.name), requirement, requirement));\n                }\n            });\n        });\n    });\n}\nfunction uniqueBy(arr, fn) {\n    var identifiers = new Set();\n    return arr.filter(function(item) {\n        var identifier = fn(item);\n        if (!identifiers.has(identifier)) {\n            identifiers.add(identifier);\n            return true;\n        }\n    });\n}\nfunction mergeByName(modifiers) {\n    var merged = modifiers.reduce(function(merged, current) {\n        var existing = merged[current.name];\n        merged[current.name] = existing ? Object.assign({}, existing, current, {\n            options: Object.assign({}, existing.options, current.options),\n            data: Object.assign({}, existing.data, current.data)\n        }) : current;\n        return merged;\n    }, {}); // IE11 does not support Object.values\n    return Object.keys(merged).map(function(key) {\n        return merged[key];\n    });\n}\nvar INVALID_ELEMENT_ERROR = \"Popper: Invalid reference or popper argument provided. They must be either a DOM element or virtual element.\";\nvar INFINITE_LOOP_ERROR = \"Popper: An infinite loop in the modifiers cycle has been detected! The cycle has been interrupted to prevent a browser crash.\";\nvar DEFAULT_OPTIONS = {\n    placement: \"bottom\",\n    modifiers: [],\n    strategy: \"absolute\"\n};\nfunction areValidElements() {\n    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n        args[_key] = arguments[_key];\n    }\n    return !args.some(function(element) {\n        return !(element && typeof element.getBoundingClientRect === \"function\");\n    });\n}\nfunction popperGenerator(generatorOptions) {\n    if (generatorOptions === void 0) {\n        generatorOptions = {};\n    }\n    var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n    return function createPopper(reference, popper, options) {\n        if (options === void 0) {\n            options = defaultOptions;\n        }\n        var state = {\n            placement: \"bottom\",\n            orderedModifiers: [],\n            options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n            modifiersData: {},\n            elements: {\n                reference: reference,\n                popper: popper\n            },\n            attributes: {},\n            styles: {}\n        };\n        var effectCleanupFns = [];\n        var isDestroyed = false;\n        var instance = {\n            state: state,\n            setOptions: function setOptions(setOptionsAction) {\n                var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                cleanupModifierEffects();\n                state.options = Object.assign({}, defaultOptions, state.options, options);\n                state.scrollParents = {\n                    reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                    popper: listScrollParents(popper)\n                }; // Orders the modifiers based on their dependencies and `phase`\n                // properties\n                var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                state.orderedModifiers = orderedModifiers.filter(function(m) {\n                    return m.enabled;\n                }); // Validate the provided modifiers so that the consumer will get warned\n                // if one of the modifiers is invalid for any reason\n                if (true) {\n                    var modifiers = uniqueBy([].concat(orderedModifiers, state.options.modifiers), function(_ref) {\n                        var name = _ref.name;\n                        return name;\n                    });\n                    validateModifiers(modifiers);\n                    if (getBasePlacement(state.options.placement) === auto) {\n                        var flipModifier = state.orderedModifiers.find(function(_ref2) {\n                            var name = _ref2.name;\n                            return name === \"flip\";\n                        });\n                        if (!flipModifier) {\n                            console.error([\n                                'Popper: \"auto\" placements require the \"flip\" modifier be',\n                                \"present and enabled to work.\"\n                            ].join(\" \"));\n                        }\n                    }\n                    var _getComputedStyle = getComputedStyle(popper), marginTop = _getComputedStyle.marginTop, marginRight = _getComputedStyle.marginRight, marginBottom = _getComputedStyle.marginBottom, marginLeft = _getComputedStyle.marginLeft; // We no longer take into account `margins` on the popper, and it can\n                    // cause bugs with positioning, so we'll warn the consumer\n                    if ([\n                        marginTop,\n                        marginRight,\n                        marginBottom,\n                        marginLeft\n                    ].some(function(margin) {\n                        return parseFloat(margin);\n                    })) {\n                        console.warn([\n                            'Popper: CSS \"margin\" styles cannot be used to apply padding',\n                            \"between the popper and its reference element or boundary.\",\n                            \"To replicate margin, use the `offset` modifier, as well as\",\n                            \"the `padding` option in the `preventOverflow` and `flip`\",\n                            \"modifiers.\"\n                        ].join(\" \"));\n                    }\n                }\n                runModifierEffects();\n                return instance.update();\n            },\n            // Sync update – it will always be executed, even if not necessary. This\n            // is useful for low frequency updates where sync behavior simplifies the\n            // logic.\n            // For high frequency updates (e.g. `resize` and `scroll` events), always\n            // prefer the async Popper#update method\n            forceUpdate: function forceUpdate() {\n                if (isDestroyed) {\n                    return;\n                }\n                var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                // anymore\n                if (!areValidElements(reference, popper)) {\n                    if (true) {\n                        console.error(INVALID_ELEMENT_ERROR);\n                    }\n                    return;\n                } // Store the reference and popper rects to be read by modifiers\n                state.rects = {\n                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                    popper: getLayoutRect(popper)\n                }; // Modifiers have the ability to reset the current update cycle. The\n                // most common use case for this is the `flip` modifier changing the\n                // placement, which then needs to re-run all the modifiers, because the\n                // logic was previously ran for the previous placement and is therefore\n                // stale/incorrect\n                state.reset = false;\n                state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                // is filled with the initial data specified by the modifier. This means\n                // it doesn't persist and is fresh on each update.\n                // To ensure persistent data, use `${name}#persistent`\n                state.orderedModifiers.forEach(function(modifier) {\n                    return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                });\n                var __debug_loops__ = 0;\n                for(var index = 0; index < state.orderedModifiers.length; index++){\n                    if (true) {\n                        __debug_loops__ += 1;\n                        if (__debug_loops__ > 100) {\n                            console.error(INFINITE_LOOP_ERROR);\n                            break;\n                        }\n                    }\n                    if (state.reset === true) {\n                        state.reset = false;\n                        index = -1;\n                        continue;\n                    }\n                    var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                    if (typeof fn === \"function\") {\n                        state = fn({\n                            state: state,\n                            options: _options,\n                            name: name,\n                            instance: instance\n                        }) || state;\n                    }\n                }\n            },\n            // Async and optimistically optimized update – it will not be executed if\n            // not necessary (debounced to run at most once-per-tick)\n            update: debounce(function() {\n                return new Promise(function(resolve) {\n                    instance.forceUpdate();\n                    resolve(state);\n                });\n            }),\n            destroy: function destroy() {\n                cleanupModifierEffects();\n                isDestroyed = true;\n            }\n        };\n        if (!areValidElements(reference, popper)) {\n            if (true) {\n                console.error(INVALID_ELEMENT_ERROR);\n            }\n            return instance;\n        }\n        instance.setOptions(options).then(function(state) {\n            if (!isDestroyed && options.onFirstUpdate) {\n                options.onFirstUpdate(state);\n            }\n        }); // Modifiers have the ability to execute arbitrary code before the first\n        // update cycle runs. They will be executed in the same order as the update\n        // cycle. This is useful when a modifier adds some persistent data that\n        // other modifiers need to use, but the modifier is run after the dependent\n        // one.\n        function runModifierEffects() {\n            state.orderedModifiers.forEach(function(_ref3) {\n                var name = _ref3.name, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, effect = _ref3.effect;\n                if (typeof effect === \"function\") {\n                    var cleanupFn = effect({\n                        state: state,\n                        name: name,\n                        instance: instance,\n                        options: options\n                    });\n                    var noopFn = function noopFn() {};\n                    effectCleanupFns.push(cleanupFn || noopFn);\n                }\n            });\n        }\n        function cleanupModifierEffects() {\n            effectCleanupFns.forEach(function(fn) {\n                return fn();\n            });\n            effectCleanupFns = [];\n        }\n        return instance;\n    };\n}\nvar defaultModifiers = [\n    eventListeners,\n    popperOffsets$1,\n    computeStyles$1,\n    applyStyles$1,\n    offset$1,\n    flip$1,\n    preventOverflow$1,\n    arrow$1,\n    hide$1\n];\nvar createPopper = /*#__PURE__*/ popperGenerator({\n    defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\nvar usePopper = function(options) {\n    var level = options.level, buttonRef = options.buttonRef, contentRef = options.contentRef;\n    var _a = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _a.collapsed, toggled = _a.toggled, transitionDuration = _a.transitionDuration;\n    var popperInstanceRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    /**\r\n     * create popper instance only on first level submenu components and when sidebar is collapsed\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (level === 0 && collapsed && contentRef.current && buttonRef.current) {\n            popperInstanceRef.current = createPopper(buttonRef.current, contentRef.current, {\n                placement: \"right\",\n                strategy: \"fixed\",\n                modifiers: [\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: [\n                                0,\n                                5\n                            ]\n                        }\n                    }\n                ]\n            });\n        }\n        return function() {\n            var _a;\n            return (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.destroy();\n        };\n    }, [\n        level,\n        collapsed,\n        contentRef,\n        buttonRef\n    ]);\n    /**\r\n     * update popper instance (position) when buttonRef or contentRef changes\r\n     */ react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        if (contentRef.current && buttonRef.current) {\n            var ro = new ResizeObserver(function() {\n                var _a;\n                (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n            });\n            ro.observe(contentRef.current);\n            ro.observe(buttonRef.current);\n        }\n        setTimeout(function() {\n            var _a;\n            (_a = popperInstanceRef.current) === null || _a === void 0 ? void 0 : _a.update();\n        }, transitionDuration);\n    }, [\n        transitionDuration,\n        toggled,\n        contentRef,\n        buttonRef\n    ]);\n    return {\n        popperInstance: popperInstanceRef.current\n    };\n};\nvar menuButtonStyles = function(props) {\n    var rtl = props.rtl, level = props.level, collapsed = props.collapsed, disabled = props.disabled, active = props.active;\n    return \"\\n    display: flex;\\n    align-items: center;\\n    height: 50px;\\n    text-decoration: none;\\n    color: inherit;\\n    box-sizing: border-box;\\n    cursor: pointer;\\n\\n    \".concat(rtl ? \"padding-left: 20px;\\n           padding-right: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n            \") : \"padding-right: 20px;\\n           padding-left: \".concat(level === 0 ? 20 : (collapsed ? level : level + 1) * 20, \"px;\\n           \"), \"\\n\\n    &:hover {\\n      background-color: #f3f3f3;\\n    }\\n\\n    \").concat(disabled && \" \\n      pointer-events: none;\\n      cursor: default;\\n      color:#adadad;\\n        \", \"\\n\\n    \").concat(active && \"background-color: #e2eef9;\", \"\\n  \\n  \");\n};\nvar MenuButtonRef = function(_a, ref) {\n    var className = _a.className, component = _a.component, children = _a.children, rest = __rest(_a, [\n        \"className\",\n        \"component\",\n        \"children\"\n    ]);\n    if (component) {\n        if (typeof component === \"string\") {\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(component, __assign(__assign({\n                className: classnames(className)\n            }, rest), {\n                ref: ref\n            }), children);\n        } else {\n            var _b = component.props, classNameProp = _b.className, props = __rest(_b, [\n                \"className\"\n            ]);\n            return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().cloneElement(component, __assign(__assign(__assign({\n                className: classnames(className, classNameProp)\n            }, rest), props), {\n                ref: ref\n            }), children);\n        }\n    } else {\n        return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"a\", __assign({\n            ref: ref,\n            className: classnames(className)\n        }, rest), children);\n    }\n};\nvar MenuButton = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuButtonRef);\nvar StyledSubMenu = newStyled.li(templateObject_1$1 || (templateObject_1$1 = __makeTemplateObject([\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  position: relative;\\n  width: 100%;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\nvar SubMenuFR = function(_a, ref) {\n    var _b;\n    var children = _a.children, className = _a.className, label = _a.label, icon = _a.icon, title = _a.title, prefix = _a.prefix, suffix = _a.suffix, openControlled = _a.open, defaultOpen = _a.defaultOpen, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, rootStyles = _a.rootStyles, component = _a.component, onOpenChange = _a.onOpenChange, onClick = _a.onClick, onKeyUp = _a.onKeyUp, rest = __rest(_a, [\n        \"children\",\n        \"className\",\n        \"label\",\n        \"icon\",\n        \"title\",\n        \"prefix\",\n        \"suffix\",\n        \"open\",\n        \"defaultOpen\",\n        \"active\",\n        \"disabled\",\n        \"rootStyles\",\n        \"component\",\n        \"onOpenChange\",\n        \"onClick\",\n        \"onKeyUp\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, sidebarTransitionDuration = _e.transitionDuration;\n    var _f = useMenu(), renderExpandIcon = _f.renderExpandIcon, closeOnClick = _f.closeOnClick, menuItemStyles = _f.menuItemStyles, transitionDuration = _f.transitionDuration;\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(!!defaultOpen), open = _g[0], setOpen = _g[1];\n    var _h = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), openWhenCollapsed = _h[0], setOpenWhenCollapsed = _h[1];\n    var _j = react__WEBPACK_IMPORTED_MODULE_0___default().useState(false), mounted = _j[0], setMounted = _j[1];\n    var buttonRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var contentRef = react__WEBPACK_IMPORTED_MODULE_0___default().useRef(null);\n    var timer = react__WEBPACK_IMPORTED_MODULE_0___default().useRef();\n    var popperInstance = usePopper({\n        level: level,\n        buttonRef: buttonRef,\n        contentRef: contentRef\n    }).popperInstance;\n    var slideUp = function() {\n        var target = contentRef.current;\n        if (target) {\n            target.style.display = \"block\";\n            target.style.overflow = \"hidden\";\n            target.style.height = \"auto\";\n            var height = target.offsetHeight;\n            target.style.height = \"0px\";\n            target.offsetHeight;\n            target.style.height = \"\".concat(height, \"px\");\n            timer.current = setTimeout(function() {\n                target.style.overflow = \"auto\";\n                target.style.height = \"auto\";\n            }, transitionDuration);\n        }\n    };\n    var slideDown = function() {\n        var target = contentRef.current;\n        if (target) {\n            target.style.overflow = \"hidden\";\n            target.style.height = \"\".concat(target.offsetHeight, \"px\");\n            target.offsetHeight;\n            target.style.height = \"0px\";\n            timer.current = setTimeout(function() {\n                target.style.overflow = \"auto\";\n                target.style.display = \"none\";\n            }, transitionDuration);\n        }\n    };\n    var handleSlideToggle = function() {\n        if (!(level === 0 && collapsed)) {\n            clearTimeout(Number(timer.current));\n            var openValue = openControlled !== null && openControlled !== void 0 ? openControlled : open;\n            openValue ? slideDown() : slideUp();\n            onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!openValue);\n            typeof openControlled === \"undefined\" && setOpen(!open);\n        }\n    };\n    var handleOnClick = function(event) {\n        onClick === null || onClick === void 0 ? void 0 : onClick(event);\n        handleSlideToggle();\n    };\n    var handleOnKeyUp = function(event) {\n        onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp(event);\n        if (event.key === \"Enter\") {\n            handleSlideToggle();\n        }\n    };\n    var getSubMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: true,\n                open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix, subMenuContentElStyles = menuItemStyles.subMenuContent, SubMenuExpandIconElStyles = menuItemStyles.SubMenuExpandIcon;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                case \"SubMenuExpandIcon\":\n                    return typeof SubMenuExpandIconElStyles === \"function\" ? SubMenuExpandIconElStyles(params) : SubMenuExpandIconElStyles;\n                case \"subMenuContent\":\n                    return typeof subMenuContentElStyles === \"function\" ? subMenuContentElStyles(params) : subMenuContentElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setTimeout(function() {\n            return popperInstance === null || popperInstance === void 0 ? void 0 : popperInstance.update();\n        }, sidebarTransitionDuration);\n        if (collapsed && level === 0) {\n            setOpenWhenCollapsed(false);\n        // ? if its useful to close first level submenus on collapse sidebar uncomment the code below\n        // setOpen(false);\n        }\n    }, [\n        collapsed,\n        level,\n        rtl,\n        sidebarTransitionDuration,\n        popperInstance\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        var handleTogglePopper = function(target) {\n            var _a, _b, _c;\n            if (!openWhenCollapsed && ((_a = buttonRef.current) === null || _a === void 0 ? void 0 : _a.contains(target))) setOpenWhenCollapsed(true);\n            else if (closeOnClick && !((_b = target.closest(\".\".concat(menuClasses.menuItemRoot))) === null || _b === void 0 ? void 0 : _b.classList.contains(menuClasses.subMenuRoot)) || !((_c = contentRef.current) === null || _c === void 0 ? void 0 : _c.contains(target)) && openWhenCollapsed) {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var handleDocumentClick = function(event) {\n            handleTogglePopper(event.target);\n        };\n        var handleDocumentKeyUp = function(event) {\n            if (event.key === \"Enter\") {\n                handleTogglePopper(event.target);\n            } else if (event.key === \"Escape\") {\n                setOpenWhenCollapsed(false);\n            }\n        };\n        var removeEventListeners = function() {\n            document.removeEventListener(\"click\", handleDocumentClick);\n            document.removeEventListener(\"keyup\", handleDocumentKeyUp);\n        };\n        removeEventListeners();\n        if (collapsed && level === 0) {\n            document.addEventListener(\"click\", handleDocumentClick, false);\n            document.addEventListener(\"keyup\", handleDocumentKeyUp, false);\n        }\n        return function() {\n            removeEventListeners();\n        };\n    }, [\n        collapsed,\n        level,\n        closeOnClick,\n        openWhenCollapsed\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        setMounted(true);\n    }, []);\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b[menuClasses.open] = openControlled !== null && openControlled !== void 0 ? openControlled : open, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledSubMenu, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, menuClasses.subMenuRoot, sharedClasses, className),\n        menuItemStyles: getSubMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getSubMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        ref: buttonRef,\n        title: title,\n        className: classnames(menuClasses.button, sharedClasses),\n        onClick: handleOnClick,\n        onKeyUp: handleOnKeyUp,\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getSubMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"label\")\n    }, label), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: sidebarTransitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"suffix\")\n    }, suffix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconWrapper, {\n        rtl: rtl,\n        className: classnames(menuClasses.SubMenuExpandIcon, sharedClasses),\n        collapsed: collapsed,\n        level: level,\n        rootStyles: getSubMenuItemStyles(\"SubMenuExpandIcon\")\n    }, renderExpandIcon ? renderExpandIcon({\n        level: level,\n        disabled: disabled,\n        active: active,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }) : collapsed && level === 0 ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIconCollapsed, null) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledExpandIcon, {\n        rtl: rtl,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open\n    }))), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SubMenuContent, {\n        ref: contentRef,\n        openWhenCollapsed: openWhenCollapsed,\n        open: openControlled !== null && openControlled !== void 0 ? openControlled : open,\n        firstLevel: level === 0,\n        collapsed: collapsed,\n        defaultOpen: openControlled && !mounted || defaultOpen,\n        className: classnames(menuClasses.subMenuContent, sharedClasses),\n        rootStyles: getSubMenuItemStyles(\"subMenuContent\")\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(LevelContext.Provider, {\n        value: level + 1\n    }, children)));\n};\nvar SubMenu = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(SubMenuFR);\nvar templateObject_1$1;\nvar StyledMenuItem = newStyled.li(templateObject_1 || (templateObject_1 = __makeTemplateObject([\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n], [\n    \"\\n  width: 100%;\\n  position: relative;\\n\\n  \",\n    \";\\n\\n  \",\n    \";\\n\\n  > .\",\n    \" {\\n    \",\n    \";\\n\\n    \",\n    \";\\n  }\\n\"\n])), function(_a) {\n    var menuItemStyles = _a.menuItemStyles;\n    return menuItemStyles;\n}, function(_a) {\n    var rootStyles = _a.rootStyles;\n    return rootStyles;\n}, menuClasses.button, function(_a) {\n    var level = _a.level, disabled = _a.disabled, active = _a.active, collapsed = _a.collapsed, rtl = _a.rtl;\n    return menuButtonStyles({\n        level: level,\n        disabled: disabled,\n        active: active,\n        collapsed: collapsed,\n        rtl: rtl\n    });\n}, function(_a) {\n    var buttonStyles = _a.buttonStyles;\n    return buttonStyles;\n});\nvar MenuItemFR = function(_a, ref) {\n    var _b;\n    var children = _a.children, icon = _a.icon, className = _a.className, prefix = _a.prefix, suffix = _a.suffix, _c = _a.active, active = _c === void 0 ? false : _c, _d = _a.disabled, disabled = _d === void 0 ? false : _d, component = _a.component, rootStyles = _a.rootStyles, rest = __rest(_a, [\n        \"children\",\n        \"icon\",\n        \"className\",\n        \"prefix\",\n        \"suffix\",\n        \"active\",\n        \"disabled\",\n        \"component\",\n        \"rootStyles\"\n    ]);\n    var level = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(LevelContext);\n    var _e = react__WEBPACK_IMPORTED_MODULE_0___default().useContext(SidebarContext), collapsed = _e.collapsed, rtl = _e.rtl, transitionDuration = _e.transitionDuration;\n    var menuItemStyles = useMenu().menuItemStyles;\n    var getMenuItemStyles = function(element) {\n        if (menuItemStyles) {\n            var params = {\n                level: level,\n                disabled: disabled,\n                active: active,\n                isSubmenu: false\n            };\n            var rootElStyles = menuItemStyles.root, buttonElStyles = menuItemStyles.button, labelElStyles = menuItemStyles.label, iconElStyles = menuItemStyles.icon, prefixElStyles = menuItemStyles.prefix, suffixElStyles = menuItemStyles.suffix;\n            switch(element){\n                case \"root\":\n                    return typeof rootElStyles === \"function\" ? rootElStyles(params) : rootElStyles;\n                case \"button\":\n                    return typeof buttonElStyles === \"function\" ? buttonElStyles(params) : buttonElStyles;\n                case \"label\":\n                    return typeof labelElStyles === \"function\" ? labelElStyles(params) : labelElStyles;\n                case \"icon\":\n                    return typeof iconElStyles === \"function\" ? iconElStyles(params) : iconElStyles;\n                case \"prefix\":\n                    return typeof prefixElStyles === \"function\" ? prefixElStyles(params) : prefixElStyles;\n                case \"suffix\":\n                    return typeof suffixElStyles === \"function\" ? suffixElStyles(params) : suffixElStyles;\n                default:\n                    return undefined;\n            }\n        }\n    };\n    var sharedClasses = (_b = {}, _b[menuClasses.active] = active, _b[menuClasses.disabled] = disabled, _b);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuItem, {\n        ref: ref,\n        className: classnames(menuClasses.menuItemRoot, sharedClasses, className),\n        menuItemStyles: getMenuItemStyles(\"root\"),\n        level: level,\n        collapsed: collapsed,\n        rtl: rtl,\n        disabled: disabled,\n        active: active,\n        buttonStyles: getMenuItemStyles(\"button\"),\n        rootStyles: rootStyles\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(MenuButton, __assign({\n        className: classnames(menuClasses.button, sharedClasses),\n        \"data-testid\": \"\".concat(menuClasses.button, \"-test-id\"),\n        component: component,\n        tabIndex: 0\n    }, rest), icon && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuIcon, {\n        rtl: rtl,\n        className: classnames(menuClasses.icon, sharedClasses),\n        rootStyles: getMenuItemStyles(\"icon\")\n    }, icon), prefix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuPrefix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.prefix, sharedClasses),\n        rtl: rtl,\n        rootStyles: getMenuItemStyles(\"prefix\")\n    }, prefix), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuLabel, {\n        className: classnames(menuClasses.label, sharedClasses),\n        rootStyles: getMenuItemStyles(\"label\")\n    }, children), suffix && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(StyledMenuSuffix, {\n        collapsed: collapsed,\n        transitionDuration: transitionDuration,\n        firstLevel: level === 0,\n        className: classnames(menuClasses.suffix, sharedClasses),\n        rootStyles: getMenuItemStyles(\"suffix\")\n    }, suffix)));\n};\nvar MenuItem = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().forwardRef(MenuItemFR);\nvar templateObject_1;\n/**\r\n * @deprecated\r\n * `ProSidebarProvider` is deprecated and will be removed in the next major release.\r\n */ var ProSidebarProvider = function(_a) {\n    var children = _a.children;\n    console.warn(\"ProSidebarProvider is deprecated and will be removed in the next major release.\");\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0___default().createElement(SidebarProvider, null, children);\n};\n/**\r\n * @deprecated\r\n * `useProSidebar` is deprecated and will be removed in the next major release.\r\n *  please use Sidebar props instead.\r\n */ var useProSidebar = function() {\n    var legacySidebarContext = useLegacySidebar();\n    if (legacySidebarContext === undefined) {\n        throw new Error(\"useProSidebar must be used within a ProSidebarProvider. Please wrap your component with a ProSidebarProvider to use this hook.\");\n    }\n    var collapseSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateCollapseState();\n        else legacySidebarContext.updateSidebarState({\n            collapsed: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateCollapseState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    var toggleSidebar = react__WEBPACK_IMPORTED_MODULE_0___default().useCallback(function(value) {\n        if (value === undefined) legacySidebarContext.updateToggleState();\n        else legacySidebarContext.updateSidebarState({\n            toggled: value\n        });\n    }, // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        legacySidebarContext.updateToggleState,\n        legacySidebarContext.updateSidebarState\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function() {\n        console.warn(\"useProSidebar is deprecated and will be removed in the next major release. Please use Sidebar props instead.\");\n    }, []);\n    return {\n        collapseSidebar: collapseSidebar,\n        toggleSidebar: toggleSidebar,\n        collapsed: !!legacySidebarContext.collapsed,\n        broken: !!legacySidebarContext.broken,\n        toggled: !!legacySidebarContext.toggled,\n        rtl: !!legacySidebarContext.rtl\n    };\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtcHJvLXNpZGViYXIvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDd0U7QUFFdkc7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBRTlFLElBQUlPLFdBQVc7SUFDWEEsV0FBV0MsT0FBT0MsTUFBTSxJQUFJLFNBQVNGLFNBQVNHLENBQUM7UUFDM0MsSUFBSyxJQUFJQyxHQUFHQyxJQUFJLEdBQUdDLElBQUlDLFVBQVVDLE1BQU0sRUFBRUgsSUFBSUMsR0FBR0QsSUFBSztZQUNqREQsSUFBSUcsU0FBUyxDQUFDRixFQUFFO1lBQ2hCLElBQUssSUFBSUksS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxJQUFJTixDQUFDLENBQUNNLEVBQUUsR0FBR0wsQ0FBQyxDQUFDSyxFQUFFO1FBQ2hGO1FBQ0EsT0FBT047SUFDWDtJQUNBLE9BQU9ILFNBQVNhLEtBQUssQ0FBQyxJQUFJLEVBQUVOO0FBQ2hDO0FBRUEsU0FBU08sT0FBT1YsQ0FBQyxFQUFFVyxDQUFDO0lBQ2hCLElBQUlaLElBQUksQ0FBQztJQUNULElBQUssSUFBSU0sS0FBS0wsRUFBRyxJQUFJSCxPQUFPUyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUixHQUFHSyxNQUFNTSxFQUFFQyxPQUFPLENBQUNQLEtBQUssR0FDOUVOLENBQUMsQ0FBQ00sRUFBRSxHQUFHTCxDQUFDLENBQUNLLEVBQUU7SUFDZixJQUFJTCxLQUFLLFFBQVEsT0FBT0gsT0FBT2dCLHFCQUFxQixLQUFLLFlBQ3JELElBQUssSUFBSVosSUFBSSxHQUFHSSxJQUFJUixPQUFPZ0IscUJBQXFCLENBQUNiLElBQUlDLElBQUlJLEVBQUVELE1BQU0sRUFBRUgsSUFBSztRQUNwRSxJQUFJVSxFQUFFQyxPQUFPLENBQUNQLENBQUMsQ0FBQ0osRUFBRSxJQUFJLEtBQUtKLE9BQU9T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TUFBTSxJQUFJbUwsTUFBTTtJQUNwQjtJQUNBLElBQUlnM0Isa0JBQWtCM2tDLHdEQUEwQixDQUFDLFNBQVU2QixLQUFLO1FBQzVELElBQUlBLFVBQVVXLFdBQ1YwZixxQkFBcUIxRSxtQkFBbUI7YUFFeEMwRSxxQkFBcUI5RSxrQkFBa0IsQ0FBQztZQUFFUCxXQUFXaGI7UUFBTTtJQUNuRSxHQUNBLHVEQUF1RDtJQUN2RDtRQUFDcWdCLHFCQUFxQjFFLG1CQUFtQjtRQUFFMEUscUJBQXFCOUUsa0JBQWtCO0tBQUM7SUFDbkYsSUFBSXduQixnQkFBZ0I1a0Msd0RBQTBCLENBQUMsU0FBVTZCLEtBQUs7UUFDMUQsSUFBSUEsVUFBVVcsV0FDVjBmLHFCQUFxQnhFLGlCQUFpQjthQUV0Q3dFLHFCQUFxQjlFLGtCQUFrQixDQUFDO1lBQUVOLFNBQVNqYjtRQUFNO0lBQ2pFLEdBQ0EsdURBQXVEO0lBQ3ZEO1FBQUNxZ0IscUJBQXFCeEUsaUJBQWlCO1FBQUV3RSxxQkFBcUI5RSxrQkFBa0I7S0FBQztJQUNqRnBkLHNEQUF3QixDQUFDO1FBQ3JCa0YsUUFBUTBjLElBQUksQ0FBQztJQUNqQixHQUFHLEVBQUU7SUFDTCxPQUFPO1FBQ0graUIsaUJBQWlCQTtRQUNqQkMsZUFBZUE7UUFDZi9uQixXQUFXLENBQUMsQ0FBQ3FGLHFCQUFxQnJGLFNBQVM7UUFDM0NFLFFBQVEsQ0FBQyxDQUFDbUYscUJBQXFCbkYsTUFBTTtRQUNyQ0QsU0FBUyxDQUFDLENBQUNvRixxQkFBcUJwRixPQUFPO1FBQ3ZDRSxLQUFLLENBQUMsQ0FBQ2tGLHFCQUFxQmxGLEdBQUc7SUFDbkM7QUFDSjtBQUU4SyIsInNvdXJjZXMiOlsid2VicGFjazovL2dvdHJpcC1uZXh0Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LXByby1zaWRlYmFyL2Rpc3QvaW5kZXguZXMuanM/NzM4MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgZm9yd2FyZFJlZiwgdXNlQ29udGV4dCwgY3JlYXRlRWxlbWVudCwgY3JlYXRlQ29udGV4dCwgRnJhZ21lbnQgfSBmcm9tICdyZWFjdCc7XG5cbi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiA/IE9iamVjdC5hc3NpZ24uYmluZCgpIDogZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIG1lbW9pemUoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGVbYXJnXSA9PT0gdW5kZWZpbmVkKSBjYWNoZVthcmddID0gZm4oYXJnKTtcbiAgICByZXR1cm4gY2FjaGVbYXJnXTtcbiAgfTtcbn1cblxudmFyIHJlYWN0UHJvcHNSZWdleCA9IC9eKChjaGlsZHJlbnxkYW5nZXJvdXNseVNldElubmVySFRNTHxrZXl8cmVmfGF1dG9Gb2N1c3xkZWZhdWx0VmFsdWV8ZGVmYXVsdENoZWNrZWR8aW5uZXJIVE1MfHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ3xzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmd8dmFsdWVMaW5rfGFiYnJ8YWNjZXB0fGFjY2VwdENoYXJzZXR8YWNjZXNzS2V5fGFjdGlvbnxhbGxvd3xhbGxvd1VzZXJNZWRpYXxhbGxvd1BheW1lbnRSZXF1ZXN0fGFsbG93RnVsbFNjcmVlbnxhbGxvd1RyYW5zcGFyZW5jeXxhbHR8YXN5bmN8YXV0b0NvbXBsZXRlfGF1dG9QbGF5fGNhcHR1cmV8Y2VsbFBhZGRpbmd8Y2VsbFNwYWNpbmd8Y2hhbGxlbmdlfGNoYXJTZXR8Y2hlY2tlZHxjaXRlfGNsYXNzSUR8Y2xhc3NOYW1lfGNvbHN8Y29sU3Bhbnxjb250ZW50fGNvbnRlbnRFZGl0YWJsZXxjb250ZXh0TWVudXxjb250cm9sc3xjb250cm9sc0xpc3R8Y29vcmRzfGNyb3NzT3JpZ2lufGRhdGF8ZGF0ZVRpbWV8ZGVjb2Rpbmd8ZGVmYXVsdHxkZWZlcnxkaXJ8ZGlzYWJsZWR8ZGlzYWJsZVBpY3R1cmVJblBpY3R1cmV8ZG93bmxvYWR8ZHJhZ2dhYmxlfGVuY1R5cGV8ZW50ZXJLZXlIaW50fGZvcm18Zm9ybUFjdGlvbnxmb3JtRW5jVHlwZXxmb3JtTWV0aG9kfGZvcm1Ob1ZhbGlkYXRlfGZvcm1UYXJnZXR8ZnJhbWVCb3JkZXJ8aGVhZGVyc3xoZWlnaHR8aGlkZGVufGhpZ2h8aHJlZnxocmVmTGFuZ3xodG1sRm9yfGh0dHBFcXVpdnxpZHxpbnB1dE1vZGV8aW50ZWdyaXR5fGlzfGtleVBhcmFtc3xrZXlUeXBlfGtpbmR8bGFiZWx8bGFuZ3xsaXN0fGxvYWRpbmd8bG9vcHxsb3d8bWFyZ2luSGVpZ2h0fG1hcmdpbldpZHRofG1heHxtYXhMZW5ndGh8bWVkaWF8bWVkaWFHcm91cHxtZXRob2R8bWlufG1pbkxlbmd0aHxtdWx0aXBsZXxtdXRlZHxuYW1lfG5vbmNlfG5vVmFsaWRhdGV8b3BlbnxvcHRpbXVtfHBhdHRlcm58cGxhY2Vob2xkZXJ8cGxheXNJbmxpbmV8cG9zdGVyfHByZWxvYWR8cHJvZmlsZXxyYWRpb0dyb3VwfHJlYWRPbmx5fHJlZmVycmVyUG9saWN5fHJlbHxyZXF1aXJlZHxyZXZlcnNlZHxyb2xlfHJvd3N8cm93U3BhbnxzYW5kYm94fHNjb3BlfHNjb3BlZHxzY3JvbGxpbmd8c2VhbWxlc3N8c2VsZWN0ZWR8c2hhcGV8c2l6ZXxzaXplc3xzbG90fHNwYW58c3BlbGxDaGVja3xzcmN8c3JjRG9jfHNyY0xhbmd8c3JjU2V0fHN0YXJ0fHN0ZXB8c3R5bGV8c3VtbWFyeXx0YWJJbmRleHx0YXJnZXR8dGl0bGV8dHJhbnNsYXRlfHR5cGV8dXNlTWFwfHZhbHVlfHdpZHRofHdtb2RlfHdyYXB8YWJvdXR8ZGF0YXR5cGV8aW5saXN0fHByZWZpeHxwcm9wZXJ0eXxyZXNvdXJjZXx0eXBlb2Z8dm9jYWJ8YXV0b0NhcGl0YWxpemV8YXV0b0NvcnJlY3R8YXV0b1NhdmV8Y29sb3J8aW5jcmVtZW50YWx8ZmFsbGJhY2t8aW5lcnR8aXRlbVByb3B8aXRlbVNjb3BlfGl0ZW1UeXBlfGl0ZW1JRHxpdGVtUmVmfG9ufG9wdGlvbnxyZXN1bHRzfHNlY3VyaXR5fHVuc2VsZWN0YWJsZXxhY2NlbnRIZWlnaHR8YWNjdW11bGF0ZXxhZGRpdGl2ZXxhbGlnbm1lbnRCYXNlbGluZXxhbGxvd1Jlb3JkZXJ8YWxwaGFiZXRpY3xhbXBsaXR1ZGV8YXJhYmljRm9ybXxhc2NlbnR8YXR0cmlidXRlTmFtZXxhdHRyaWJ1dGVUeXBlfGF1dG9SZXZlcnNlfGF6aW11dGh8YmFzZUZyZXF1ZW5jeXxiYXNlbGluZVNoaWZ0fGJhc2VQcm9maWxlfGJib3h8YmVnaW58Ymlhc3xieXxjYWxjTW9kZXxjYXBIZWlnaHR8Y2xpcHxjbGlwUGF0aFVuaXRzfGNsaXBQYXRofGNsaXBSdWxlfGNvbG9ySW50ZXJwb2xhdGlvbnxjb2xvckludGVycG9sYXRpb25GaWx0ZXJzfGNvbG9yUHJvZmlsZXxjb2xvclJlbmRlcmluZ3xjb250ZW50U2NyaXB0VHlwZXxjb250ZW50U3R5bGVUeXBlfGN1cnNvcnxjeHxjeXxkfGRlY2VsZXJhdGV8ZGVzY2VudHxkaWZmdXNlQ29uc3RhbnR8ZGlyZWN0aW9ufGRpc3BsYXl8ZGl2aXNvcnxkb21pbmFudEJhc2VsaW5lfGR1cnxkeHxkeXxlZGdlTW9kZXxlbGV2YXRpb258ZW5hYmxlQmFja2dyb3VuZHxlbmR8ZXhwb25lbnR8ZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZHxmaWxsfGZpbGxPcGFjaXR5fGZpbGxSdWxlfGZpbHRlcnxmaWx0ZXJSZXN8ZmlsdGVyVW5pdHN8Zmxvb2RDb2xvcnxmbG9vZE9wYWNpdHl8Zm9jdXNhYmxlfGZvbnRGYW1pbHl8Zm9udFNpemV8Zm9udFNpemVBZGp1c3R8Zm9udFN0cmV0Y2h8Zm9udFN0eWxlfGZvbnRWYXJpYW50fGZvbnRXZWlnaHR8Zm9ybWF0fGZyb218ZnJ8Znh8Znl8ZzF8ZzJ8Z2x5cGhOYW1lfGdseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsfGdseXBoT3JpZW50YXRpb25WZXJ0aWNhbHxnbHlwaFJlZnxncmFkaWVudFRyYW5zZm9ybXxncmFkaWVudFVuaXRzfGhhbmdpbmd8aG9yaXpBZHZYfGhvcml6T3JpZ2luWHxpZGVvZ3JhcGhpY3xpbWFnZVJlbmRlcmluZ3xpbnxpbjJ8aW50ZXJjZXB0fGt8azF8azJ8azN8azR8a2VybmVsTWF0cml4fGtlcm5lbFVuaXRMZW5ndGh8a2VybmluZ3xrZXlQb2ludHN8a2V5U3BsaW5lc3xrZXlUaW1lc3xsZW5ndGhBZGp1c3R8bGV0dGVyU3BhY2luZ3xsaWdodGluZ0NvbG9yfGxpbWl0aW5nQ29uZUFuZ2xlfGxvY2FsfG1hcmtlckVuZHxtYXJrZXJNaWR8bWFya2VyU3RhcnR8bWFya2VySGVpZ2h0fG1hcmtlclVuaXRzfG1hcmtlcldpZHRofG1hc2t8bWFza0NvbnRlbnRVbml0c3xtYXNrVW5pdHN8bWF0aGVtYXRpY2FsfG1vZGV8bnVtT2N0YXZlc3xvZmZzZXR8b3BhY2l0eXxvcGVyYXRvcnxvcmRlcnxvcmllbnR8b3JpZW50YXRpb258b3JpZ2lufG92ZXJmbG93fG92ZXJsaW5lUG9zaXRpb258b3ZlcmxpbmVUaGlja25lc3N8cGFub3NlMXxwYWludE9yZGVyfHBhdGhMZW5ndGh8cGF0dGVybkNvbnRlbnRVbml0c3xwYXR0ZXJuVHJhbnNmb3JtfHBhdHRlcm5Vbml0c3xwb2ludGVyRXZlbnRzfHBvaW50c3xwb2ludHNBdFh8cG9pbnRzQXRZfHBvaW50c0F0WnxwcmVzZXJ2ZUFscGhhfHByZXNlcnZlQXNwZWN0UmF0aW98cHJpbWl0aXZlVW5pdHN8cnxyYWRpdXN8cmVmWHxyZWZZfHJlbmRlcmluZ0ludGVudHxyZXBlYXRDb3VudHxyZXBlYXREdXJ8cmVxdWlyZWRFeHRlbnNpb25zfHJlcXVpcmVkRmVhdHVyZXN8cmVzdGFydHxyZXN1bHR8cm90YXRlfHJ4fHJ5fHNjYWxlfHNlZWR8c2hhcGVSZW5kZXJpbmd8c2xvcGV8c3BhY2luZ3xzcGVjdWxhckNvbnN0YW50fHNwZWN1bGFyRXhwb25lbnR8c3BlZWR8c3ByZWFkTWV0aG9kfHN0YXJ0T2Zmc2V0fHN0ZERldmlhdGlvbnxzdGVtaHxzdGVtdnxzdGl0Y2hUaWxlc3xzdG9wQ29sb3J8c3RvcE9wYWNpdHl8c3RyaWtldGhyb3VnaFBvc2l0aW9ufHN0cmlrZXRocm91Z2hUaGlja25lc3N8c3RyaW5nfHN0cm9rZXxzdHJva2VEYXNoYXJyYXl8c3Ryb2tlRGFzaG9mZnNldHxzdHJva2VMaW5lY2FwfHN0cm9rZUxpbmVqb2lufHN0cm9rZU1pdGVybGltaXR8c3Ryb2tlT3BhY2l0eXxzdHJva2VXaWR0aHxzdXJmYWNlU2NhbGV8c3lzdGVtTGFuZ3VhZ2V8dGFibGVWYWx1ZXN8dGFyZ2V0WHx0YXJnZXRZfHRleHRBbmNob3J8dGV4dERlY29yYXRpb258dGV4dFJlbmRlcmluZ3x0ZXh0TGVuZ3RofHRvfHRyYW5zZm9ybXx1MXx1Mnx1bmRlcmxpbmVQb3NpdGlvbnx1bmRlcmxpbmVUaGlja25lc3N8dW5pY29kZXx1bmljb2RlQmlkaXx1bmljb2RlUmFuZ2V8dW5pdHNQZXJFbXx2QWxwaGFiZXRpY3x2SGFuZ2luZ3x2SWRlb2dyYXBoaWN8dk1hdGhlbWF0aWNhbHx2YWx1ZXN8dmVjdG9yRWZmZWN0fHZlcnNpb258dmVydEFkdll8dmVydE9yaWdpblh8dmVydE9yaWdpbll8dmlld0JveHx2aWV3VGFyZ2V0fHZpc2liaWxpdHl8d2lkdGhzfHdvcmRTcGFjaW5nfHdyaXRpbmdNb2RlfHh8eEhlaWdodHx4MXx4Mnx4Q2hhbm5lbFNlbGVjdG9yfHhsaW5rQWN0dWF0ZXx4bGlua0FyY3JvbGV8eGxpbmtIcmVmfHhsaW5rUm9sZXx4bGlua1Nob3d8eGxpbmtUaXRsZXx4bGlua1R5cGV8eG1sQmFzZXx4bWxuc3x4bWxuc1hsaW5rfHhtbExhbmd8eG1sU3BhY2V8eXx5MXx5Mnx5Q2hhbm5lbFNlbGVjdG9yfHp8em9vbUFuZFBhbnxmb3J8Y2xhc3N8YXV0b2ZvY3VzKXwoKFtEZF1bQWFdW1R0XVtBYV18W0FhXVtScl1bSWldW0FhXXx4KS0uKikpJC87IC8vIGh0dHBzOi8vZXNiZW5jaC5jb20vYmVuY2gvNWJmZWU2OGE0Y2Q3ZTYwMDllZjYxZDIzXG5cbnZhciBpc1Byb3BWYWxpZCA9IC8qICNfX1BVUkVfXyAqL21lbW9pemUoZnVuY3Rpb24gKHByb3ApIHtcbiAgcmV0dXJuIHJlYWN0UHJvcHNSZWdleC50ZXN0KHByb3ApIHx8IHByb3AuY2hhckNvZGVBdCgwKSA9PT0gMTExXG4gIC8qIG8gKi9cbiAgJiYgcHJvcC5jaGFyQ29kZUF0KDEpID09PSAxMTBcbiAgLyogbiAqL1xuICAmJiBwcm9wLmNoYXJDb2RlQXQoMikgPCA5MTtcbn1cbi8qIForMSAqL1xuKTtcblxuLypcblxuQmFzZWQgb2ZmIGdsYW1vcidzIFN0eWxlU2hlZXQsIHRoYW5rcyBTdW5pbCDinaTvuI9cblxuaGlnaCBwZXJmb3JtYW5jZSBTdHlsZVNoZWV0IGZvciBjc3MtaW4tanMgc3lzdGVtc1xuXG4tIHVzZXMgbXVsdGlwbGUgc3R5bGUgdGFncyBiZWhpbmQgdGhlIHNjZW5lcyBmb3IgbWlsbGlvbnMgb2YgcnVsZXNcbi0gdXNlcyBgaW5zZXJ0UnVsZWAgZm9yIGFwcGVuZGluZyBpbiBwcm9kdWN0aW9uIGZvciAqbXVjaCogZmFzdGVyIHBlcmZvcm1hbmNlXG5cbi8vIHVzYWdlXG5cbmltcG9ydCB7IFN0eWxlU2hlZXQgfSBmcm9tICdAZW1vdGlvbi9zaGVldCdcblxubGV0IHN0eWxlU2hlZXQgPSBuZXcgU3R5bGVTaGVldCh7IGtleTogJycsIGNvbnRhaW5lcjogZG9jdW1lbnQuaGVhZCB9KVxuXG5zdHlsZVNoZWV0Lmluc2VydCgnI2JveCB7IGJvcmRlcjogMXB4IHNvbGlkIHJlZDsgfScpXG4tIGFwcGVuZHMgYSBjc3MgcnVsZSBpbnRvIHRoZSBzdHlsZXNoZWV0XG5cbnN0eWxlU2hlZXQuZmx1c2goKVxuLSBlbXB0aWVzIHRoZSBzdHlsZXNoZWV0IG9mIGFsbCBpdHMgY29udGVudHNcblxuKi9cbi8vICRGbG93Rml4TWVcbmZ1bmN0aW9uIHNoZWV0Rm9yVGFnKHRhZykge1xuICBpZiAodGFnLnNoZWV0KSB7XG4gICAgLy8gJEZsb3dGaXhNZVxuICAgIHJldHVybiB0YWcuc2hlZXQ7XG4gIH0gLy8gdGhpcyB3ZWlyZG5lc3MgYnJvdWdodCB0byB5b3UgYnkgZmlyZWZveFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvY3VtZW50LnN0eWxlU2hlZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGRvY3VtZW50LnN0eWxlU2hlZXRzW2ldLm93bmVyTm9kZSA9PT0gdGFnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICByZXR1cm4gZG9jdW1lbnQuc3R5bGVTaGVldHNbaV07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XG4gIHZhciB0YWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICB0YWcuc2V0QXR0cmlidXRlKCdkYXRhLWVtb3Rpb24nLCBvcHRpb25zLmtleSk7XG5cbiAgaWYgKG9wdGlvbnMubm9uY2UgIT09IHVuZGVmaW5lZCkge1xuICAgIHRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgb3B0aW9ucy5ub25jZSk7XG4gIH1cblxuICB0YWcuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpKTtcbiAgdGFnLnNldEF0dHJpYnV0ZSgnZGF0YS1zJywgJycpO1xuICByZXR1cm4gdGFnO1xufVxuXG52YXIgU3R5bGVTaGVldCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8vIFVzaW5nIE5vZGUgaW5zdGVhZCBvZiBIVE1MRWxlbWVudCBzaW5jZSBjb250YWluZXIgbWF5IGJlIGEgU2hhZG93Um9vdFxuICBmdW5jdGlvbiBTdHlsZVNoZWV0KG9wdGlvbnMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdGhpcy5faW5zZXJ0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgdmFyIGJlZm9yZTtcblxuICAgICAgaWYgKF90aGlzLnRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGlmIChfdGhpcy5pbnNlcnRpb25Qb2ludCkge1xuICAgICAgICAgIGJlZm9yZSA9IF90aGlzLmluc2VydGlvblBvaW50Lm5leHRTaWJsaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKF90aGlzLnByZXBlbmQpIHtcbiAgICAgICAgICBiZWZvcmUgPSBfdGhpcy5jb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBiZWZvcmUgPSBfdGhpcy5iZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlZm9yZSA9IF90aGlzLnRhZ3NbX3RoaXMudGFncy5sZW5ndGggLSAxXS5uZXh0U2libGluZztcbiAgICAgIH1cblxuICAgICAgX3RoaXMuY29udGFpbmVyLmluc2VydEJlZm9yZSh0YWcsIGJlZm9yZSk7XG5cbiAgICAgIF90aGlzLnRhZ3MucHVzaCh0YWcpO1xuICAgIH07XG5cbiAgICB0aGlzLmlzU3BlZWR5ID0gb3B0aW9ucy5zcGVlZHkgPT09IHVuZGVmaW5lZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgOiBvcHRpb25zLnNwZWVkeTtcbiAgICB0aGlzLnRhZ3MgPSBbXTtcbiAgICB0aGlzLmN0ciA9IDA7XG4gICAgdGhpcy5ub25jZSA9IG9wdGlvbnMubm9uY2U7IC8vIGtleSBpcyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEtZW1vdGlvbiBhdHRyaWJ1dGUsIGl0J3MgdXNlZCB0byBpZGVudGlmeSBkaWZmZXJlbnQgc2hlZXRzXG5cbiAgICB0aGlzLmtleSA9IG9wdGlvbnMua2V5O1xuICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgdGhpcy5wcmVwZW5kID0gb3B0aW9ucy5wcmVwZW5kO1xuICAgIHRoaXMuaW5zZXJ0aW9uUG9pbnQgPSBvcHRpb25zLmluc2VydGlvblBvaW50O1xuICAgIHRoaXMuYmVmb3JlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBfcHJvdG8gPSBTdHlsZVNoZWV0LnByb3RvdHlwZTtcblxuICBfcHJvdG8uaHlkcmF0ZSA9IGZ1bmN0aW9uIGh5ZHJhdGUobm9kZXMpIHtcbiAgICBub2Rlcy5mb3JFYWNoKHRoaXMuX2luc2VydFRhZyk7XG4gIH07XG5cbiAgX3Byb3RvLmluc2VydCA9IGZ1bmN0aW9uIGluc2VydChydWxlKSB7XG4gICAgLy8gdGhlIG1heCBsZW5ndGggaXMgaG93IG1hbnkgcnVsZXMgd2UgaGF2ZSBwZXIgc3R5bGUgdGFnLCBpdCdzIDY1MDAwIGluIHNwZWVkeSBtb2RlXG4gICAgLy8gaXQncyAxIGluIGRldiBiZWNhdXNlIHdlIGluc2VydCBzb3VyY2UgbWFwcyB0aGF0IG1hcCBhIHNpbmdsZSBydWxlIHRvIGEgbG9jYXRpb25cbiAgICAvLyBhbmQgeW91IGNhbiBvbmx5IGhhdmUgb25lIHNvdXJjZSBtYXAgcGVyIHN0eWxlIHRhZ1xuICAgIGlmICh0aGlzLmN0ciAlICh0aGlzLmlzU3BlZWR5ID8gNjUwMDAgOiAxKSA9PT0gMCkge1xuICAgICAgdGhpcy5faW5zZXJ0VGFnKGNyZWF0ZVN0eWxlRWxlbWVudCh0aGlzKSk7XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IHRoaXMudGFnc1t0aGlzLnRhZ3MubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGlzSW1wb3J0UnVsZSA9IHJ1bGUuY2hhckNvZGVBdCgwKSA9PT0gNjQgJiYgcnVsZS5jaGFyQ29kZUF0KDEpID09PSAxMDU7XG5cbiAgICAgIGlmIChpc0ltcG9ydFJ1bGUgJiYgdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUpIHtcbiAgICAgICAgLy8gdGhpcyB3b3VsZCBvbmx5IGNhdXNlIHByb2JsZW0gaW4gc3BlZWR5IG1vZGVcbiAgICAgICAgLy8gYnV0IHdlIGRvbid0IHdhbnQgZW5hYmxpbmcgc3BlZWR5IHRvIGFmZmVjdCB0aGUgb2JzZXJ2YWJsZSBiZWhhdmlvclxuICAgICAgICAvLyBzbyB3ZSByZXBvcnQgdGhpcyBlcnJvciBhdCBhbGwgdGltZXNcbiAgICAgICAgY29uc29sZS5lcnJvcihcIllvdSdyZSBhdHRlbXB0aW5nIHRvIGluc2VydCB0aGUgZm9sbG93aW5nIHJ1bGU6XFxuXCIgKyBydWxlICsgJ1xcblxcbmBAaW1wb3J0YCBydWxlcyBtdXN0IGJlIGJlZm9yZSBhbGwgb3RoZXIgdHlwZXMgb2YgcnVsZXMgaW4gYSBzdHlsZXNoZWV0IGJ1dCBvdGhlciBydWxlcyBoYXZlIGFscmVhZHkgYmVlbiBpbnNlcnRlZC4gUGxlYXNlIGVuc3VyZSB0aGF0IGBAaW1wb3J0YCBydWxlcyBhcmUgYmVmb3JlIGFsbCBvdGhlciBydWxlcy4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FscmVhZHlJbnNlcnRlZE9yZGVySW5zZW5zaXRpdmVSdWxlID0gdGhpcy5fYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUgfHwgIWlzSW1wb3J0UnVsZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc1NwZWVkeSkge1xuICAgICAgdmFyIHNoZWV0ID0gc2hlZXRGb3JUYWcodGFnKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgdWx0cmFmYXN0IHZlcnNpb24sIHdvcmtzIGFjcm9zcyBicm93c2Vyc1xuICAgICAgICAvLyB0aGUgYmlnIGRyYXdiYWNrIGlzIHRoYXQgdGhlIGNzcyB3b24ndCBiZSBlZGl0YWJsZSBpbiBkZXZ0b29sc1xuICAgICAgICBzaGVldC5pbnNlcnRSdWxlKHJ1bGUsIHNoZWV0LmNzc1J1bGVzLmxlbmd0aCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICEvOigtbW96LXBsYWNlaG9sZGVyfC1tb3otZm9jdXMtaW5uZXJ8LW1vei1mb2N1c3Jpbmd8LW1zLWlucHV0LXBsYWNlaG9sZGVyfC1tb3otcmVhZC13cml0ZXwtbW96LXJlYWQtb25seXwtbXMtY2xlYXJ8LW1zLWV4cGFuZHwtbXMtcmV2ZWFsKXsvLnRlc3QocnVsZSkpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlcmUgd2FzIGEgcHJvYmxlbSBpbnNlcnRpbmcgdGhlIGZvbGxvd2luZyBydWxlOiBcXFwiXCIgKyBydWxlICsgXCJcXFwiXCIsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShydWxlKSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdHIrKztcbiAgfTtcblxuICBfcHJvdG8uZmx1c2ggPSBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgdGhpcy50YWdzLmZvckVhY2goZnVuY3Rpb24gKHRhZykge1xuICAgICAgcmV0dXJuIHRhZy5wYXJlbnROb2RlICYmIHRhZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRhZyk7XG4gICAgfSk7XG4gICAgdGhpcy50YWdzID0gW107XG4gICAgdGhpcy5jdHIgPSAwO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX2FscmVhZHlJbnNlcnRlZE9yZGVySW5zZW5zaXRpdmVSdWxlID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdHlsZVNoZWV0O1xufSgpO1xuXG52YXIgTVMgPSAnLW1zLSc7XG52YXIgTU9aID0gJy1tb3otJztcbnZhciBXRUJLSVQgPSAnLXdlYmtpdC0nO1xuXG52YXIgQ09NTUVOVCA9ICdjb21tJztcbnZhciBSVUxFU0VUID0gJ3J1bGUnO1xudmFyIERFQ0xBUkFUSU9OID0gJ2RlY2wnO1xudmFyIElNUE9SVCA9ICdAaW1wb3J0JztcbnZhciBLRVlGUkFNRVMgPSAnQGtleWZyYW1lcyc7XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbnZhciBhYnMgPSBNYXRoLmFicztcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn1cbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xudmFyIGZyb20gPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaGFzaCQyICh2YWx1ZSwgbGVuZ3RoKSB7XG5cdHJldHVybiBjaGFyYXQodmFsdWUsIDApIF4gNDUgPyAoKCgoKCgobGVuZ3RoIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAwKSkgPDwgMikgXiBjaGFyYXQodmFsdWUsIDEpKSA8PCAyKSBeIGNoYXJhdCh2YWx1ZSwgMikpIDw8IDIpIF4gY2hhcmF0KHZhbHVlLCAzKSA6IDBcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdHJpbSAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLnRyaW0oKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtSZWdFeHB9IHBhdHRlcm5cbiAqIEByZXR1cm4ge3N0cmluZz99XG4gKi9cbmZ1bmN0aW9uIG1hdGNoICh2YWx1ZSwgcGF0dGVybikge1xuXHRyZXR1cm4gKHZhbHVlID0gcGF0dGVybi5leGVjKHZhbHVlKSkgPyB2YWx1ZVswXSA6IHZhbHVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0geyhzdHJpbmd8UmVnRXhwKX0gcGF0dGVyblxuICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlcGxhY2UgKHZhbHVlLCBwYXR0ZXJuLCByZXBsYWNlbWVudCkge1xuXHRyZXR1cm4gdmFsdWUucmVwbGFjZShwYXR0ZXJuLCByZXBsYWNlbWVudClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWFyY2hcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gaW5kZXhvZiAodmFsdWUsIHNlYXJjaCkge1xuXHRyZXR1cm4gdmFsdWUuaW5kZXhPZihzZWFyY2gpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gY2hhcmF0ICh2YWx1ZSwgaW5kZXgpIHtcblx0cmV0dXJuIHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpIHwgMFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN1YnN0ciAodmFsdWUsIGJlZ2luLCBlbmQpIHtcblx0cmV0dXJuIHZhbHVlLnNsaWNlKGJlZ2luLCBlbmQpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHN0cmxlbiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLmxlbmd0aFxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHNpemVvZiAodmFsdWUpIHtcblx0cmV0dXJuIHZhbHVlLmxlbmd0aFxufVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHBhcmFtIHthbnlbXX0gYXJyYXlcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gYXBwZW5kICh2YWx1ZSwgYXJyYXkpIHtcblx0cmV0dXJuIGFycmF5LnB1c2godmFsdWUpLCB2YWx1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nW119IGFycmF5XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjb21iaW5lIChhcnJheSwgY2FsbGJhY2spIHtcblx0cmV0dXJuIGFycmF5Lm1hcChjYWxsYmFjaykuam9pbignJylcbn1cblxudmFyIGxpbmUgPSAxO1xudmFyIGNvbHVtbiA9IDE7XG52YXIgbGVuZ3RoID0gMDtcbnZhciBwb3NpdGlvbiA9IDA7XG52YXIgY2hhcmFjdGVyID0gMDtcbnZhciBjaGFyYWN0ZXJzID0gJyc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdCB8IG51bGx9IHJvb3RcbiAqIEBwYXJhbSB7b2JqZWN0IHwgbnVsbH0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmdbXSB8IHN0cmluZ30gcHJvcHNcbiAqIEBwYXJhbSB7b2JqZWN0W10gfCBzdHJpbmd9IGNoaWxkcmVuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIG5vZGUgKHZhbHVlLCByb290LCBwYXJlbnQsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoKSB7XG5cdHJldHVybiB7dmFsdWU6IHZhbHVlLCByb290OiByb290LCBwYXJlbnQ6IHBhcmVudCwgdHlwZTogdHlwZSwgcHJvcHM6IHByb3BzLCBjaGlsZHJlbjogY2hpbGRyZW4sIGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uLCBsZW5ndGg6IGxlbmd0aCwgcmV0dXJuOiAnJ31cbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvcHkgKHJvb3QsIHByb3BzKSB7XG5cdHJldHVybiBhc3NpZ24obm9kZSgnJywgbnVsbCwgbnVsbCwgJycsIG51bGwsIG51bGwsIDApLCByb290LCB7bGVuZ3RoOiAtcm9vdC5sZW5ndGh9LCBwcm9wcylcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNoYXIgKCkge1xuXHRyZXR1cm4gY2hhcmFjdGVyXG59XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwcmV2ICgpIHtcblx0Y2hhcmFjdGVyID0gcG9zaXRpb24gPiAwID8gY2hhcmF0KGNoYXJhY3RlcnMsIC0tcG9zaXRpb24pIDogMDtcblxuXHRpZiAoY29sdW1uLS0sIGNoYXJhY3RlciA9PT0gMTApXG5cdFx0Y29sdW1uID0gMSwgbGluZS0tO1xuXG5cdHJldHVybiBjaGFyYWN0ZXJcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIG5leHQgKCkge1xuXHRjaGFyYWN0ZXIgPSBwb3NpdGlvbiA8IGxlbmd0aCA/IGNoYXJhdChjaGFyYWN0ZXJzLCBwb3NpdGlvbisrKSA6IDA7XG5cblx0aWYgKGNvbHVtbisrLCBjaGFyYWN0ZXIgPT09IDEwKVxuXHRcdGNvbHVtbiA9IDEsIGxpbmUrKztcblxuXHRyZXR1cm4gY2hhcmFjdGVyXG59XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBwZWVrICgpIHtcblx0cmV0dXJuIGNoYXJhdChjaGFyYWN0ZXJzLCBwb3NpdGlvbilcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNhcmV0ICgpIHtcblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJlZ2luXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNsaWNlIChiZWdpbiwgZW5kKSB7XG5cdHJldHVybiBzdWJzdHIoY2hhcmFjdGVycywgYmVnaW4sIGVuZClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiB0b2tlbiAodHlwZSkge1xuXHRzd2l0Y2ggKHR5cGUpIHtcblx0XHQvLyBcXDAgXFx0IFxcbiBcXHIgXFxzIHdoaXRlc3BhY2UgdG9rZW5cblx0XHRjYXNlIDA6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcblx0XHRcdHJldHVybiA1XG5cdFx0Ly8gISArICwgLyA+IEAgfiBpc29sYXRlIHRva2VuXG5cdFx0Y2FzZSAzMzogY2FzZSA0MzogY2FzZSA0NDogY2FzZSA0NzogY2FzZSA2MjogY2FzZSA2NDogY2FzZSAxMjY6XG5cdFx0Ly8gOyB7IH0gYnJlYWtwb2ludCB0b2tlblxuXHRcdGNhc2UgNTk6IGNhc2UgMTIzOiBjYXNlIDEyNTpcblx0XHRcdHJldHVybiA0XG5cdFx0Ly8gOiBhY2NvbXBhbmllZCB0b2tlblxuXHRcdGNhc2UgNTg6XG5cdFx0XHRyZXR1cm4gM1xuXHRcdC8vIFwiICcgKCBbIG9wZW5pbmcgZGVsaW1pdCB0b2tlblxuXHRcdGNhc2UgMzQ6IGNhc2UgMzk6IGNhc2UgNDA6IGNhc2UgOTE6XG5cdFx0XHRyZXR1cm4gMlxuXHRcdC8vICkgXSBjbG9zaW5nIGRlbGltaXQgdG9rZW5cblx0XHRjYXNlIDQxOiBjYXNlIDkzOlxuXHRcdFx0cmV0dXJuIDFcblx0fVxuXG5cdHJldHVybiAwXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJuIHthbnlbXX1cbiAqL1xuZnVuY3Rpb24gYWxsb2MgKHZhbHVlKSB7XG5cdHJldHVybiBsaW5lID0gY29sdW1uID0gMSwgbGVuZ3RoID0gc3RybGVuKGNoYXJhY3RlcnMgPSB2YWx1ZSksIHBvc2l0aW9uID0gMCwgW11cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm4ge2FueX1cbiAqL1xuZnVuY3Rpb24gZGVhbGxvYyAodmFsdWUpIHtcblx0cmV0dXJuIGNoYXJhY3RlcnMgPSAnJywgdmFsdWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBkZWxpbWl0ICh0eXBlKSB7XG5cdHJldHVybiB0cmltKHNsaWNlKHBvc2l0aW9uIC0gMSwgZGVsaW1pdGVyKHR5cGUgPT09IDkxID8gdHlwZSArIDIgOiB0eXBlID09PSA0MCA/IHR5cGUgKyAxIDogdHlwZSkpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHdoaXRlc3BhY2UgKHR5cGUpIHtcblx0d2hpbGUgKGNoYXJhY3RlciA9IHBlZWsoKSlcblx0XHRpZiAoY2hhcmFjdGVyIDwgMzMpXG5cdFx0XHRuZXh0KCk7XG5cdFx0ZWxzZVxuXHRcdFx0YnJlYWtcblxuXHRyZXR1cm4gdG9rZW4odHlwZSkgPiAyIHx8IHRva2VuKGNoYXJhY3RlcikgPiAzID8gJycgOiAnICdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBlc2NhcGluZyAoaW5kZXgsIGNvdW50KSB7XG5cdHdoaWxlICgtLWNvdW50ICYmIG5leHQoKSlcblx0XHQvLyBub3QgMC05IEEtRiBhLWZcblx0XHRpZiAoY2hhcmFjdGVyIDwgNDggfHwgY2hhcmFjdGVyID4gMTAyIHx8IChjaGFyYWN0ZXIgPiA1NyAmJiBjaGFyYWN0ZXIgPCA2NSkgfHwgKGNoYXJhY3RlciA+IDcwICYmIGNoYXJhY3RlciA8IDk3KSlcblx0XHRcdGJyZWFrXG5cblx0cmV0dXJuIHNsaWNlKGluZGV4LCBjYXJldCgpICsgKGNvdW50IDwgNiAmJiBwZWVrKCkgPT0gMzIgJiYgbmV4dCgpID09IDMyKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdHlwZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBkZWxpbWl0ZXIgKHR5cGUpIHtcblx0d2hpbGUgKG5leHQoKSlcblx0XHRzd2l0Y2ggKGNoYXJhY3Rlcikge1xuXHRcdFx0Ly8gXSApIFwiICdcblx0XHRcdGNhc2UgdHlwZTpcblx0XHRcdFx0cmV0dXJuIHBvc2l0aW9uXG5cdFx0XHQvLyBcIiAnXG5cdFx0XHRjYXNlIDM0OiBjYXNlIDM5OlxuXHRcdFx0XHRpZiAodHlwZSAhPT0gMzQgJiYgdHlwZSAhPT0gMzkpXG5cdFx0XHRcdFx0ZGVsaW1pdGVyKGNoYXJhY3Rlcik7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyAoXG5cdFx0XHRjYXNlIDQwOlxuXHRcdFx0XHRpZiAodHlwZSA9PT0gNDEpXG5cdFx0XHRcdFx0ZGVsaW1pdGVyKHR5cGUpO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gXFxcblx0XHRcdGNhc2UgOTI6XG5cdFx0XHRcdG5leHQoKTtcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0cmV0dXJuIHBvc2l0aW9uXG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBjb21tZW50ZXIgKHR5cGUsIGluZGV4KSB7XG5cdHdoaWxlIChuZXh0KCkpXG5cdFx0Ly8gLy9cblx0XHRpZiAodHlwZSArIGNoYXJhY3RlciA9PT0gNDcgKyAxMClcblx0XHRcdGJyZWFrXG5cdFx0Ly8gLypcblx0XHRlbHNlIGlmICh0eXBlICsgY2hhcmFjdGVyID09PSA0MiArIDQyICYmIHBlZWsoKSA9PT0gNDcpXG5cdFx0XHRicmVha1xuXG5cdHJldHVybiAnLyonICsgc2xpY2UoaW5kZXgsIHBvc2l0aW9uIC0gMSkgKyAnKicgKyBmcm9tKHR5cGUgPT09IDQ3ID8gdHlwZSA6IG5leHQoKSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaWRlbnRpZmllciAoaW5kZXgpIHtcblx0d2hpbGUgKCF0b2tlbihwZWVrKCkpKVxuXHRcdG5leHQoKTtcblxuXHRyZXR1cm4gc2xpY2UoaW5kZXgsIHBvc2l0aW9uKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybiB7b2JqZWN0W119XG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGUgKHZhbHVlKSB7XG5cdHJldHVybiBkZWFsbG9jKHBhcnNlKCcnLCBudWxsLCBudWxsLCBudWxsLCBbJyddLCB2YWx1ZSA9IGFsbG9jKHZhbHVlKSwgMCwgWzBdLCB2YWx1ZSkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nW119IHJ1bGVzXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBydWxlc2V0c1xuICogQHBhcmFtIHtudW1iZXJbXX0gcHNldWRvXG4gKiBAcGFyYW0ge251bWJlcltdfSBwb2ludHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGRlY2xhcmF0aW9uc1xuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBwYXJzZSAodmFsdWUsIHJvb3QsIHBhcmVudCwgcnVsZSwgcnVsZXMsIHJ1bGVzZXRzLCBwc2V1ZG8sIHBvaW50cywgZGVjbGFyYXRpb25zKSB7XG5cdHZhciBpbmRleCA9IDA7XG5cdHZhciBvZmZzZXQgPSAwO1xuXHR2YXIgbGVuZ3RoID0gcHNldWRvO1xuXHR2YXIgYXRydWxlID0gMDtcblx0dmFyIHByb3BlcnR5ID0gMDtcblx0dmFyIHByZXZpb3VzID0gMDtcblx0dmFyIHZhcmlhYmxlID0gMTtcblx0dmFyIHNjYW5uaW5nID0gMTtcblx0dmFyIGFtcGVyc2FuZCA9IDE7XG5cdHZhciBjaGFyYWN0ZXIgPSAwO1xuXHR2YXIgdHlwZSA9ICcnO1xuXHR2YXIgcHJvcHMgPSBydWxlcztcblx0dmFyIGNoaWxkcmVuID0gcnVsZXNldHM7XG5cdHZhciByZWZlcmVuY2UgPSBydWxlO1xuXHR2YXIgY2hhcmFjdGVycyA9IHR5cGU7XG5cblx0d2hpbGUgKHNjYW5uaW5nKVxuXHRcdHN3aXRjaCAocHJldmlvdXMgPSBjaGFyYWN0ZXIsIGNoYXJhY3RlciA9IG5leHQoKSkge1xuXHRcdFx0Ly8gKFxuXHRcdFx0Y2FzZSA0MDpcblx0XHRcdFx0aWYgKHByZXZpb3VzICE9IDEwOCAmJiBjaGFyYXQoY2hhcmFjdGVycywgbGVuZ3RoIC0gMSkgPT0gNTgpIHtcblx0XHRcdFx0XHRpZiAoaW5kZXhvZihjaGFyYWN0ZXJzICs9IHJlcGxhY2UoZGVsaW1pdChjaGFyYWN0ZXIpLCAnJicsICcmXFxmJyksICcmXFxmJykgIT0gLTEpXG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSAtMTtcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHR9XG5cdFx0XHQvLyBcIiAnIFtcblx0XHRcdGNhc2UgMzQ6IGNhc2UgMzk6IGNhc2UgOTE6XG5cdFx0XHRcdGNoYXJhY3RlcnMgKz0gZGVsaW1pdChjaGFyYWN0ZXIpO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gXFx0IFxcbiBcXHIgXFxzXG5cdFx0XHRjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG5cdFx0XHRcdGNoYXJhY3RlcnMgKz0gd2hpdGVzcGFjZShwcmV2aW91cyk7XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyBcXFxuXHRcdFx0Y2FzZSA5Mjpcblx0XHRcdFx0Y2hhcmFjdGVycyArPSBlc2NhcGluZyhjYXJldCgpIC0gMSwgNyk7XG5cdFx0XHRcdGNvbnRpbnVlXG5cdFx0XHQvLyAvXG5cdFx0XHRjYXNlIDQ3OlxuXHRcdFx0XHRzd2l0Y2ggKHBlZWsoKSkge1xuXHRcdFx0XHRcdGNhc2UgNDI6IGNhc2UgNDc6XG5cdFx0XHRcdFx0XHRhcHBlbmQoY29tbWVudChjb21tZW50ZXIobmV4dCgpLCBjYXJldCgpKSwgcm9vdCwgcGFyZW50KSwgZGVjbGFyYXRpb25zKTtcblx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdGNoYXJhY3RlcnMgKz0gJy8nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrXG5cdFx0XHQvLyB7XG5cdFx0XHRjYXNlIDEyMyAqIHZhcmlhYmxlOlxuXHRcdFx0XHRwb2ludHNbaW5kZXgrK10gPSBzdHJsZW4oY2hhcmFjdGVycykgKiBhbXBlcnNhbmQ7XG5cdFx0XHQvLyB9IDsgXFwwXG5cdFx0XHRjYXNlIDEyNSAqIHZhcmlhYmxlOiBjYXNlIDU5OiBjYXNlIDA6XG5cdFx0XHRcdHN3aXRjaCAoY2hhcmFjdGVyKSB7XG5cdFx0XHRcdFx0Ly8gXFwwIH1cblx0XHRcdFx0XHRjYXNlIDA6IGNhc2UgMTI1OiBzY2FubmluZyA9IDA7XG5cdFx0XHRcdFx0Ly8gO1xuXHRcdFx0XHRcdGNhc2UgNTkgKyBvZmZzZXQ6XG5cdFx0XHRcdFx0XHRpZiAocHJvcGVydHkgPiAwICYmIChzdHJsZW4oY2hhcmFjdGVycykgLSBsZW5ndGgpKVxuXHRcdFx0XHRcdFx0XHRhcHBlbmQocHJvcGVydHkgPiAzMiA/IGRlY2xhcmF0aW9uKGNoYXJhY3RlcnMgKyAnOycsIHJ1bGUsIHBhcmVudCwgbGVuZ3RoIC0gMSkgOiBkZWNsYXJhdGlvbihyZXBsYWNlKGNoYXJhY3RlcnMsICcgJywgJycpICsgJzsnLCBydWxlLCBwYXJlbnQsIGxlbmd0aCAtIDIpLCBkZWNsYXJhdGlvbnMpO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyBAIDtcblx0XHRcdFx0XHRjYXNlIDU5OiBjaGFyYWN0ZXJzICs9ICc7Jztcblx0XHRcdFx0XHQvLyB7IHJ1bGUvYXQtcnVsZVxuXHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRhcHBlbmQocmVmZXJlbmNlID0gcnVsZXNldChjaGFyYWN0ZXJzLCByb290LCBwYXJlbnQsIGluZGV4LCBvZmZzZXQsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHByb3BzID0gW10sIGNoaWxkcmVuID0gW10sIGxlbmd0aCksIHJ1bGVzZXRzKTtcblxuXHRcdFx0XHRcdFx0aWYgKGNoYXJhY3RlciA9PT0gMTIzKVxuXHRcdFx0XHRcdFx0XHRpZiAob2Zmc2V0ID09PSAwKVxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlKGNoYXJhY3RlcnMsIHJvb3QsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBwcm9wcywgcnVsZXNldHMsIGxlbmd0aCwgcG9pbnRzLCBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdFx0XHRzd2l0Y2ggKGF0cnVsZSA9PT0gOTkgJiYgY2hhcmF0KGNoYXJhY3RlcnMsIDMpID09PSAxMTAgPyAxMDAgOiBhdHJ1bGUpIHtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGQgbSBzXG5cdFx0XHRcdFx0XHRcdFx0XHRjYXNlIDEwMDogY2FzZSAxMDk6IGNhc2UgMTE1OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZSh2YWx1ZSwgcmVmZXJlbmNlLCByZWZlcmVuY2UsIHJ1bGUgJiYgYXBwZW5kKHJ1bGVzZXQodmFsdWUsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCAwLCAwLCBydWxlcywgcG9pbnRzLCB0eXBlLCBydWxlcywgcHJvcHMgPSBbXSwgbGVuZ3RoKSwgY2hpbGRyZW4pLCBydWxlcywgY2hpbGRyZW4sIGxlbmd0aCwgcG9pbnRzLCBydWxlID8gcHJvcHMgOiBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwYXJzZShjaGFyYWN0ZXJzLCByZWZlcmVuY2UsIHJlZmVyZW5jZSwgcmVmZXJlbmNlLCBbJyddLCBjaGlsZHJlbiwgMCwgcG9pbnRzLCBjaGlsZHJlbik7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aW5kZXggPSBvZmZzZXQgPSBwcm9wZXJ0eSA9IDAsIHZhcmlhYmxlID0gYW1wZXJzYW5kID0gMSwgdHlwZSA9IGNoYXJhY3RlcnMgPSAnJywgbGVuZ3RoID0gcHNldWRvO1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Ly8gOlxuXHRcdFx0Y2FzZSA1ODpcblx0XHRcdFx0bGVuZ3RoID0gMSArIHN0cmxlbihjaGFyYWN0ZXJzKSwgcHJvcGVydHkgPSBwcmV2aW91cztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdGlmICh2YXJpYWJsZSA8IDEpXG5cdFx0XHRcdFx0aWYgKGNoYXJhY3RlciA9PSAxMjMpXG5cdFx0XHRcdFx0XHQtLXZhcmlhYmxlO1xuXHRcdFx0XHRcdGVsc2UgaWYgKGNoYXJhY3RlciA9PSAxMjUgJiYgdmFyaWFibGUrKyA9PSAwICYmIHByZXYoKSA9PSAxMjUpXG5cdFx0XHRcdFx0XHRjb250aW51ZVxuXG5cdFx0XHRcdHN3aXRjaCAoY2hhcmFjdGVycyArPSBmcm9tKGNoYXJhY3RlciksIGNoYXJhY3RlciAqIHZhcmlhYmxlKSB7XG5cdFx0XHRcdFx0Ly8gJlxuXHRcdFx0XHRcdGNhc2UgMzg6XG5cdFx0XHRcdFx0XHRhbXBlcnNhbmQgPSBvZmZzZXQgPiAwID8gMSA6IChjaGFyYWN0ZXJzICs9ICdcXGYnLCAtMSk7XG5cdFx0XHRcdFx0XHRicmVha1xuXHRcdFx0XHRcdC8vICxcblx0XHRcdFx0XHRjYXNlIDQ0OlxuXHRcdFx0XHRcdFx0cG9pbnRzW2luZGV4KytdID0gKHN0cmxlbihjaGFyYWN0ZXJzKSAtIDEpICogYW1wZXJzYW5kLCBhbXBlcnNhbmQgPSAxO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyBAXG5cdFx0XHRcdFx0Y2FzZSA2NDpcblx0XHRcdFx0XHRcdC8vIC1cblx0XHRcdFx0XHRcdGlmIChwZWVrKCkgPT09IDQ1KVxuXHRcdFx0XHRcdFx0XHRjaGFyYWN0ZXJzICs9IGRlbGltaXQobmV4dCgpKTtcblxuXHRcdFx0XHRcdFx0YXRydWxlID0gcGVlaygpLCBvZmZzZXQgPSBsZW5ndGggPSBzdHJsZW4odHlwZSA9IGNoYXJhY3RlcnMgKz0gaWRlbnRpZmllcihjYXJldCgpKSksIGNoYXJhY3RlcisrO1xuXHRcdFx0XHRcdFx0YnJlYWtcblx0XHRcdFx0XHQvLyAtXG5cdFx0XHRcdFx0Y2FzZSA0NTpcblx0XHRcdFx0XHRcdGlmIChwcmV2aW91cyA9PT0gNDUgJiYgc3RybGVuKGNoYXJhY3RlcnMpID09IDIpXG5cdFx0XHRcdFx0XHRcdHZhcmlhYmxlID0gMDtcblx0XHRcdFx0fVxuXHRcdH1cblxuXHRyZXR1cm4gcnVsZXNldHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBydWxlc1xuICogQHBhcmFtIHtudW1iZXJbXX0gcG9pbnRzXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtzdHJpbmdbXX0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nW119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHJ1bGVzZXQgKHZhbHVlLCByb290LCBwYXJlbnQsIGluZGV4LCBvZmZzZXQsIHJ1bGVzLCBwb2ludHMsIHR5cGUsIHByb3BzLCBjaGlsZHJlbiwgbGVuZ3RoKSB7XG5cdHZhciBwb3N0ID0gb2Zmc2V0IC0gMTtcblx0dmFyIHJ1bGUgPSBvZmZzZXQgPT09IDAgPyBydWxlcyA6IFsnJ107XG5cdHZhciBzaXplID0gc2l6ZW9mKHJ1bGUpO1xuXG5cdGZvciAodmFyIGkgPSAwLCBqID0gMCwgayA9IDA7IGkgPCBpbmRleDsgKytpKVxuXHRcdGZvciAodmFyIHggPSAwLCB5ID0gc3Vic3RyKHZhbHVlLCBwb3N0ICsgMSwgcG9zdCA9IGFicyhqID0gcG9pbnRzW2ldKSksIHogPSB2YWx1ZTsgeCA8IHNpemU7ICsreClcblx0XHRcdGlmICh6ID0gdHJpbShqID4gMCA/IHJ1bGVbeF0gKyAnICcgKyB5IDogcmVwbGFjZSh5LCAvJlxcZi9nLCBydWxlW3hdKSkpXG5cdFx0XHRcdHByb3BzW2srK10gPSB6O1xuXG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIG9mZnNldCA9PT0gMCA/IFJVTEVTRVQgOiB0eXBlLCBwcm9wcywgY2hpbGRyZW4sIGxlbmd0aClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7b2JqZWN0fSByb290XG4gKiBAcGFyYW0ge29iamVjdD99IHBhcmVudFxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb21tZW50ICh2YWx1ZSwgcm9vdCwgcGFyZW50KSB7XG5cdHJldHVybiBub2RlKHZhbHVlLCByb290LCBwYXJlbnQsIENPTU1FTlQsIGZyb20oY2hhcigpKSwgc3Vic3RyKHZhbHVlLCAyLCAtMiksIDApXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcGFyYW0ge29iamVjdH0gcm9vdFxuICogQHBhcmFtIHtvYmplY3Q/fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZGVjbGFyYXRpb24gKHZhbHVlLCByb290LCBwYXJlbnQsIGxlbmd0aCkge1xuXHRyZXR1cm4gbm9kZSh2YWx1ZSwgcm9vdCwgcGFyZW50LCBERUNMQVJBVElPTiwgc3Vic3RyKHZhbHVlLCAwLCBsZW5ndGgpLCBzdWJzdHIodmFsdWUsIGxlbmd0aCArIDEsIC0xKSwgbGVuZ3RoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0W119IGNoaWxkcmVuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuXHR2YXIgb3V0cHV0ID0gJyc7XG5cdHZhciBsZW5ndGggPSBzaXplb2YoY2hpbGRyZW4pO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0b3V0cHV0ICs9IGNhbGxiYWNrKGNoaWxkcmVuW2ldLCBpLCBjaGlsZHJlbiwgY2FsbGJhY2spIHx8ICcnO1xuXG5cdHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge29iamVjdFtdfSBjaGlsZHJlblxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5IChlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG5cdHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG5cdFx0Y2FzZSBJTVBPUlQ6IGNhc2UgREVDTEFSQVRJT046IHJldHVybiBlbGVtZW50LnJldHVybiA9IGVsZW1lbnQucmV0dXJuIHx8IGVsZW1lbnQudmFsdWVcblx0XHRjYXNlIENPTU1FTlQ6IHJldHVybiAnJ1xuXHRcdGNhc2UgS0VZRlJBTUVTOiByZXR1cm4gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnZhbHVlICsgJ3snICsgc2VyaWFsaXplKGVsZW1lbnQuY2hpbGRyZW4sIGNhbGxiYWNrKSArICd9J1xuXHRcdGNhc2UgUlVMRVNFVDogZWxlbWVudC52YWx1ZSA9IGVsZW1lbnQucHJvcHMuam9pbignLCcpO1xuXHR9XG5cblx0cmV0dXJuIHN0cmxlbihjaGlsZHJlbiA9IHNlcmlhbGl6ZShlbGVtZW50LmNoaWxkcmVuLCBjYWxsYmFjaykpID8gZWxlbWVudC5yZXR1cm4gPSBlbGVtZW50LnZhbHVlICsgJ3snICsgY2hpbGRyZW4gKyAnfScgOiAnJ1xufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb25bXX0gY29sbGVjdGlvblxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIG1pZGRsZXdhcmUgKGNvbGxlY3Rpb24pIHtcblx0dmFyIGxlbmd0aCA9IHNpemVvZihjb2xsZWN0aW9uKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQsIGluZGV4LCBjaGlsZHJlbiwgY2FsbGJhY2spIHtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0b3V0cHV0ICs9IGNvbGxlY3Rpb25baV0oZWxlbWVudCwgaW5kZXgsIGNoaWxkcmVuLCBjYWxsYmFjaykgfHwgJyc7XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIHJ1bGVzaGVldCAoY2FsbGJhY2spIHtcblx0cmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50KSB7XG5cdFx0aWYgKCFlbGVtZW50LnJvb3QpXG5cdFx0XHRpZiAoZWxlbWVudCA9IGVsZW1lbnQucmV0dXJuKVxuXHRcdFx0XHRjYWxsYmFjayhlbGVtZW50KTtcblx0fVxufVxuXG52YXIgd2Vha01lbW9pemUgPSBmdW5jdGlvbiB3ZWFrTWVtb2l6ZShmdW5jKSB7XG4gIC8vICRGbG93Rml4TWUgZmxvdyBkb2Vzbid0IGluY2x1ZGUgYWxsIG5vbi1wcmltaXRpdmUgdHlwZXMgYXMgYWxsb3dlZCBmb3Igd2Vha21hcHNcbiAgdmFyIGNhY2hlID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChhcmcpIHtcbiAgICBpZiAoY2FjaGUuaGFzKGFyZykpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIHJldHVybiBjYWNoZS5nZXQoYXJnKTtcbiAgICB9XG5cbiAgICB2YXIgcmV0ID0gZnVuYyhhcmcpO1xuICAgIGNhY2hlLnNldChhcmcsIHJldCk7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcbn07XG5cbnZhciBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcgPSBmdW5jdGlvbiBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcoYmVnaW4sIHBvaW50cywgaW5kZXgpIHtcbiAgdmFyIHByZXZpb3VzID0gMDtcbiAgdmFyIGNoYXJhY3RlciA9IDA7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBwcmV2aW91cyA9IGNoYXJhY3RlcjtcbiAgICBjaGFyYWN0ZXIgPSBwZWVrKCk7IC8vICZcXGZcblxuICAgIGlmIChwcmV2aW91cyA9PT0gMzggJiYgY2hhcmFjdGVyID09PSAxMikge1xuICAgICAgcG9pbnRzW2luZGV4XSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHRva2VuKGNoYXJhY3RlcikpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5leHQoKTtcbiAgfVxuXG4gIHJldHVybiBzbGljZShiZWdpbiwgcG9zaXRpb24pO1xufTtcblxudmFyIHRvUnVsZXMgPSBmdW5jdGlvbiB0b1J1bGVzKHBhcnNlZCwgcG9pbnRzKSB7XG4gIC8vIHByZXRlbmQgd2UndmUgc3RhcnRlZCB3aXRoIGEgY29tbWFcbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBjaGFyYWN0ZXIgPSA0NDtcblxuICBkbyB7XG4gICAgc3dpdGNoICh0b2tlbihjaGFyYWN0ZXIpKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIC8vICZcXGZcbiAgICAgICAgaWYgKGNoYXJhY3RlciA9PT0gMzggJiYgcGVlaygpID09PSAxMikge1xuICAgICAgICAgIC8vIHRoaXMgaXMgbm90IDEwMCUgY29ycmVjdCwgd2UgZG9uJ3QgYWNjb3VudCBmb3IgbGl0ZXJhbCBzZXF1ZW5jZXMgaGVyZSAtIGxpa2UgZm9yIGV4YW1wbGUgcXVvdGVkIHN0cmluZ3NcbiAgICAgICAgICAvLyBzdHlsaXMgaW5zZXJ0cyBcXGYgYWZ0ZXIgJiB0byBrbm93IHdoZW4gJiB3aGVyZSBpdCBzaG91bGQgcmVwbGFjZSB0aGlzIHNlcXVlbmNlIHdpdGggdGhlIGNvbnRleHQgc2VsZWN0b3JcbiAgICAgICAgICAvLyBhbmQgd2hlbiBpdCBzaG91bGQganVzdCBjb25jYXRlbmF0ZSB0aGUgb3V0ZXIgYW5kIGlubmVyIHNlbGVjdG9yc1xuICAgICAgICAgIC8vIGl0J3MgdmVyeSB1bmxpa2VseSBmb3IgdGhpcyBzZXF1ZW5jZSB0byBhY3R1YWxseSBhcHBlYXIgaW4gYSBkaWZmZXJlbnQgY29udGV4dCwgc28gd2UganVzdCBsZXZlcmFnZSB0aGlzIGZhY3QgaGVyZVxuICAgICAgICAgIHBvaW50c1tpbmRleF0gPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyc2VkW2luZGV4XSArPSBpZGVudGlmaWVyV2l0aFBvaW50VHJhY2tpbmcocG9zaXRpb24gLSAxLCBwb2ludHMsIGluZGV4KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjpcbiAgICAgICAgcGFyc2VkW2luZGV4XSArPSBkZWxpbWl0KGNoYXJhY3Rlcik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDQ6XG4gICAgICAgIC8vIGNvbW1hXG4gICAgICAgIGlmIChjaGFyYWN0ZXIgPT09IDQ0KSB7XG4gICAgICAgICAgLy8gY29sb25cbiAgICAgICAgICBwYXJzZWRbKytpbmRleF0gPSBwZWVrKCkgPT09IDU4ID8gJyZcXGYnIDogJyc7XG4gICAgICAgICAgcG9pbnRzW2luZGV4XSA9IHBhcnNlZFtpbmRleF0ubGVuZ3RoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIC8vIGZhbGx0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHBhcnNlZFtpbmRleF0gKz0gZnJvbShjaGFyYWN0ZXIpO1xuICAgIH1cbiAgfSB3aGlsZSAoY2hhcmFjdGVyID0gbmV4dCgpKTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxudmFyIGdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXModmFsdWUsIHBvaW50cykge1xuICByZXR1cm4gZGVhbGxvYyh0b1J1bGVzKGFsbG9jKHZhbHVlKSwgcG9pbnRzKSk7XG59OyAvLyBXZWFrU2V0IHdvdWxkIGJlIG1vcmUgYXBwcm9wcmlhdGUsIGJ1dCBvbmx5IFdlYWtNYXAgaXMgc3VwcG9ydGVkIGluIElFMTFcblxuXG52YXIgZml4ZWRFbGVtZW50cyA9IC8qICNfX1BVUkVfXyAqL25ldyBXZWFrTWFwKCk7XG52YXIgY29tcGF0ID0gZnVuY3Rpb24gY29tcGF0KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQudHlwZSAhPT0gJ3J1bGUnIHx8ICFlbGVtZW50LnBhcmVudCB8fCAvLyBwb3NpdGl2ZSAubGVuZ3RoIGluZGljYXRlcyB0aGF0IHRoaXMgcnVsZSBjb250YWlucyBwc2V1ZG9cbiAgLy8gbmVnYXRpdmUgLmxlbmd0aCBpbmRpY2F0ZXMgdGhhdCB0aGlzIHJ1bGUgaGFzIGJlZW4gYWxyZWFkeSBwcmVmaXhlZFxuICBlbGVtZW50Lmxlbmd0aCA8IDEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdmFsdWUgPSBlbGVtZW50LnZhbHVlLFxuICAgICAgcGFyZW50ID0gZWxlbWVudC5wYXJlbnQ7XG4gIHZhciBpc0ltcGxpY2l0UnVsZSA9IGVsZW1lbnQuY29sdW1uID09PSBwYXJlbnQuY29sdW1uICYmIGVsZW1lbnQubGluZSA9PT0gcGFyZW50LmxpbmU7XG5cbiAgd2hpbGUgKHBhcmVudC50eXBlICE9PSAncnVsZScpIHtcbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gIH0gLy8gc2hvcnQtY2lyY3VpdCBmb3IgdGhlIHNpbXBsZXN0IGNhc2VcblxuXG4gIGlmIChlbGVtZW50LnByb3BzLmxlbmd0aCA9PT0gMSAmJiB2YWx1ZS5jaGFyQ29kZUF0KDApICE9PSA1OFxuICAvKiBjb2xvbiAqL1xuICAmJiAhZml4ZWRFbGVtZW50cy5nZXQocGFyZW50KSkge1xuICAgIHJldHVybjtcbiAgfSAvLyBpZiB0aGlzIGlzIGFuIGltcGxpY2l0bHkgaW5zZXJ0ZWQgcnVsZSAodGhlIG9uZSBlYWdlcmx5IGluc2VydGVkIGF0IHRoZSBlYWNoIG5ldyBuZXN0ZWQgbGV2ZWwpXG4gIC8vIHRoZW4gdGhlIHByb3BzIGhhcyBhbHJlYWR5IGJlZW4gbWFuaXB1bGF0ZWQgYmVmb3JlaGFuZCBhcyB0aGV5IHRoYXQgYXJyYXkgaXMgc2hhcmVkIGJldHdlZW4gaXQgYW5kIGl0cyBcInJ1bGUgcGFyZW50XCJcblxuXG4gIGlmIChpc0ltcGxpY2l0UnVsZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZpeGVkRWxlbWVudHMuc2V0KGVsZW1lbnQsIHRydWUpO1xuICB2YXIgcG9pbnRzID0gW107XG4gIHZhciBydWxlcyA9IGdldFJ1bGVzKHZhbHVlLCBwb2ludHMpO1xuICB2YXIgcGFyZW50UnVsZXMgPSBwYXJlbnQucHJvcHM7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgcnVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmVudFJ1bGVzLmxlbmd0aDsgaisrLCBrKyspIHtcbiAgICAgIGVsZW1lbnQucHJvcHNba10gPSBwb2ludHNbaV0gPyBydWxlc1tpXS5yZXBsYWNlKC8mXFxmL2csIHBhcmVudFJ1bGVzW2pdKSA6IHBhcmVudFJ1bGVzW2pdICsgXCIgXCIgKyBydWxlc1tpXTtcbiAgICB9XG4gIH1cbn07XG52YXIgcmVtb3ZlTGFiZWwgPSBmdW5jdGlvbiByZW1vdmVMYWJlbChlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnR5cGUgPT09ICdkZWNsJykge1xuICAgIHZhciB2YWx1ZSA9IGVsZW1lbnQudmFsdWU7XG5cbiAgICBpZiAoIC8vIGNoYXJjb2RlIGZvciBsXG4gICAgdmFsdWUuY2hhckNvZGVBdCgwKSA9PT0gMTA4ICYmIC8vIGNoYXJjb2RlIGZvciBiXG4gICAgdmFsdWUuY2hhckNvZGVBdCgyKSA9PT0gOTgpIHtcbiAgICAgIC8vIHRoaXMgaWdub3JlcyBsYWJlbFxuICAgICAgZWxlbWVudFtcInJldHVyblwiXSA9ICcnO1xuICAgICAgZWxlbWVudC52YWx1ZSA9ICcnO1xuICAgIH1cbiAgfVxufTtcbnZhciBpZ25vcmVGbGFnID0gJ2Vtb3Rpb24tZGlzYWJsZS1zZXJ2ZXItcmVuZGVyaW5nLXVuc2FmZS1zZWxlY3Rvci13YXJuaW5nLXBsZWFzZS1kby1ub3QtdXNlLXRoaXMtdGhlLXdhcm5pbmctZXhpc3RzLWZvci1hLXJlYXNvbic7XG5cbnZhciBpc0lnbm9yaW5nQ29tbWVudCA9IGZ1bmN0aW9uIGlzSWdub3JpbmdDb21tZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQudHlwZSA9PT0gJ2NvbW0nICYmIGVsZW1lbnQuY2hpbGRyZW4uaW5kZXhPZihpZ25vcmVGbGFnKSA+IC0xO1xufTtcblxudmFyIGNyZWF0ZVVuc2FmZVNlbGVjdG9yc0FsYXJtID0gZnVuY3Rpb24gY3JlYXRlVW5zYWZlU2VsZWN0b3JzQWxhcm0oY2FjaGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4pIHtcbiAgICBpZiAoZWxlbWVudC50eXBlICE9PSAncnVsZScgfHwgY2FjaGUuY29tcGF0KSByZXR1cm47XG4gICAgdmFyIHVuc2FmZVBzZXVkb0NsYXNzZXMgPSBlbGVtZW50LnZhbHVlLm1hdGNoKC8oOmZpcnN0fDpudGh8Om50aC1sYXN0KS1jaGlsZC9nKTtcblxuICAgIGlmICh1bnNhZmVQc2V1ZG9DbGFzc2VzKSB7XG4gICAgICB2YXIgaXNOZXN0ZWQgPSBlbGVtZW50LnBhcmVudCA9PT0gY2hpbGRyZW5bMF07IC8vIGluIG5lc3RlZCBydWxlcyBjb21tZW50cyBiZWNvbWUgY2hpbGRyZW4gb2YgdGhlIFwiYXV0by1pbnNlcnRlZFwiIHJ1bGVcbiAgICAgIC8vXG4gICAgICAvLyBjb25zaWRlcmluZyB0aGlzIGlucHV0OlxuICAgICAgLy8gLmEge1xuICAgICAgLy8gICAuYiAvKiBjb21tICovIHt9XG4gICAgICAvLyAgIGNvbG9yOiBob3RwaW5rO1xuICAgICAgLy8gfVxuICAgICAgLy8gd2UgZ2V0IG91dHB1dCBjb3JyZXNwb25kaW5nIHRvIHRoaXM6XG4gICAgICAvLyAuYSB7XG4gICAgICAvLyAgICYge1xuICAgICAgLy8gICAgIC8qIGNvbW0gKi9cbiAgICAgIC8vICAgICBjb2xvcjogaG90cGluaztcbiAgICAgIC8vICAgfVxuICAgICAgLy8gICAuYiB7fVxuICAgICAgLy8gfVxuXG4gICAgICB2YXIgY29tbWVudENvbnRhaW5lciA9IGlzTmVzdGVkID8gY2hpbGRyZW5bMF0uY2hpbGRyZW4gOiAvLyBnbG9iYWwgcnVsZSBhdCB0aGUgcm9vdCBsZXZlbFxuICAgICAgY2hpbGRyZW47XG5cbiAgICAgIGZvciAodmFyIGkgPSBjb21tZW50Q29udGFpbmVyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciBub2RlID0gY29tbWVudENvbnRhaW5lcltpXTtcblxuICAgICAgICBpZiAobm9kZS5saW5lIDwgZWxlbWVudC5saW5lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gaXQgaXMgcXVpdGUgd2VpcmQgYnV0IGNvbW1lbnRzIGFyZSAqdXN1YWxseSogcHV0IGF0IGBjb2x1bW46IGVsZW1lbnQuY29sdW1uIC0gMWBcbiAgICAgICAgLy8gc28gd2Ugc2VlayAqZnJvbSB0aGUgZW5kKiBmb3IgdGhlIG5vZGUgdGhhdCBpcyBlYXJsaWVyIHRoYW4gdGhlIHJ1bGUncyBgZWxlbWVudGAgYW5kIGNoZWNrIHRoYXRcbiAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gbWF0Y2ggaW5wdXRzIGxpa2UgdGhpczpcbiAgICAgICAgLy8gLmEge1xuICAgICAgICAvLyAgIC8qIGNvbW0gKi9cbiAgICAgICAgLy8gICAuYiB7fVxuICAgICAgICAvLyB9XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGJ1dCB0aGF0IGlzIGZpbmVcbiAgICAgICAgLy9cbiAgICAgICAgLy8gaXQgd291bGQgYmUgdGhlIGVhc2llc3QgdG8gY2hhbmdlIHRoZSBwbGFjZW1lbnQgb2YgdGhlIGNvbW1lbnQgdG8gYmUgdGhlIGZpcnN0IGNoaWxkIG9mIHRoZSBydWxlOlxuICAgICAgICAvLyAuYSB7XG4gICAgICAgIC8vICAgLmIgeyAvKiBjb21tICovIH1cbiAgICAgICAgLy8gfVxuICAgICAgICAvLyB3aXRoIHN1Y2ggaW5wdXRzIHdlIHdvdWxkbid0IGhhdmUgdG8gc2VhcmNoIGZvciB0aGUgY29tbWVudCBhdCBhbGxcbiAgICAgICAgLy8gVE9ETzogY29uc2lkZXIgY2hhbmdpbmcgdGhpcyBjb21tZW50IHBsYWNlbWVudCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uXG5cblxuICAgICAgICBpZiAobm9kZS5jb2x1bW4gPCBlbGVtZW50LmNvbHVtbikge1xuICAgICAgICAgIGlmIChpc0lnbm9yaW5nQ29tbWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVuc2FmZVBzZXVkb0NsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAodW5zYWZlUHNldWRvQ2xhc3MpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIlRoZSBwc2V1ZG8gY2xhc3MgXFxcIlwiICsgdW5zYWZlUHNldWRvQ2xhc3MgKyBcIlxcXCIgaXMgcG90ZW50aWFsbHkgdW5zYWZlIHdoZW4gZG9pbmcgc2VydmVyLXNpZGUgcmVuZGVyaW5nLiBUcnkgY2hhbmdpbmcgaXQgdG8gXFxcIlwiICsgdW5zYWZlUHNldWRvQ2xhc3Muc3BsaXQoJy1jaGlsZCcpWzBdICsgXCItb2YtdHlwZVxcXCIuXCIpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIGlzSW1wb3J0UnVsZSA9IGZ1bmN0aW9uIGlzSW1wb3J0UnVsZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LnR5cGUuY2hhckNvZGVBdCgxKSA9PT0gMTA1ICYmIGVsZW1lbnQudHlwZS5jaGFyQ29kZUF0KDApID09PSA2NDtcbn07XG5cbnZhciBpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMgPSBmdW5jdGlvbiBpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMoaW5kZXgsIGNoaWxkcmVuKSB7XG4gIGZvciAodmFyIGkgPSBpbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKCFpc0ltcG9ydFJ1bGUoY2hpbGRyZW5baV0pKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59OyAvLyB1c2UgdGhpcyB0byByZW1vdmUgaW5jb3JyZWN0IGVsZW1lbnRzIGZyb20gZnVydGhlciBwcm9jZXNzaW5nXG4vLyBzbyB0aGV5IGRvbid0IGdldCBoYW5kZWQgdG8gdGhlIGBzaGVldGAgKG9yIGFueXRoaW5nIGVsc2UpXG4vLyBhcyB0aGF0IGNvdWxkIHBvdGVudGlhbGx5IGxlYWQgdG8gYWRkaXRpb25hbCBsb2dzIHdoaWNoIGluIHR1cm4gY291bGQgYmUgb3ZlcmhlbG1pbmcgdG8gdGhlIHVzZXJcblxuXG52YXIgbnVsbGlmeUVsZW1lbnQgPSBmdW5jdGlvbiBudWxsaWZ5RWxlbWVudChlbGVtZW50KSB7XG4gIGVsZW1lbnQudHlwZSA9ICcnO1xuICBlbGVtZW50LnZhbHVlID0gJyc7XG4gIGVsZW1lbnRbXCJyZXR1cm5cIl0gPSAnJztcbiAgZWxlbWVudC5jaGlsZHJlbiA9ICcnO1xuICBlbGVtZW50LnByb3BzID0gJyc7XG59O1xuXG52YXIgaW5jb3JyZWN0SW1wb3J0QWxhcm0gPSBmdW5jdGlvbiBpbmNvcnJlY3RJbXBvcnRBbGFybShlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4pIHtcbiAgaWYgKCFpc0ltcG9ydFJ1bGUoZWxlbWVudCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZWxlbWVudC5wYXJlbnQpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiYEBpbXBvcnRgIHJ1bGVzIGNhbid0IGJlIG5lc3RlZCBpbnNpZGUgb3RoZXIgcnVsZXMuIFBsZWFzZSBtb3ZlIGl0IHRvIHRoZSB0b3AgbGV2ZWwgYW5kIHB1dCBpdCBiZWZvcmUgcmVndWxhciBydWxlcy4gS2VlcCBpbiBtaW5kIHRoYXQgdGhleSBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiBnbG9iYWwgc3R5bGVzLlwiKTtcbiAgICBudWxsaWZ5RWxlbWVudChlbGVtZW50KTtcbiAgfSBlbHNlIGlmIChpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMoaW5kZXgsIGNoaWxkcmVuKSkge1xuICAgIGNvbnNvbGUuZXJyb3IoXCJgQGltcG9ydGAgcnVsZXMgY2FuJ3QgYmUgYWZ0ZXIgb3RoZXIgcnVsZXMuIFBsZWFzZSBwdXQgeW91ciBgQGltcG9ydGAgcnVsZXMgYmVmb3JlIHlvdXIgb3RoZXIgcnVsZXMuXCIpO1xuICAgIG51bGxpZnlFbGVtZW50KGVsZW1lbnQpO1xuICB9XG59O1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG5mdW5jdGlvbiBwcmVmaXgodmFsdWUsIGxlbmd0aCkge1xuICBzd2l0Y2ggKGhhc2gkMih2YWx1ZSwgbGVuZ3RoKSkge1xuICAgIC8vIGNvbG9yLWFkanVzdFxuICAgIGNhc2UgNTEwMzpcbiAgICAgIHJldHVybiBXRUJLSVQgKyAncHJpbnQtJyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gYW5pbWF0aW9uLCBhbmltYXRpb24tKGRlbGF5fGRpcmVjdGlvbnxkdXJhdGlvbnxmaWxsLW1vZGV8aXRlcmF0aW9uLWNvdW50fG5hbWV8cGxheS1zdGF0ZXx0aW1pbmctZnVuY3Rpb24pXG5cbiAgICBjYXNlIDU3Mzc6XG4gICAgY2FzZSA0MjAxOlxuICAgIGNhc2UgMzE3NzpcbiAgICBjYXNlIDM0MzM6XG4gICAgY2FzZSAxNjQxOlxuICAgIGNhc2UgNDQ1NzpcbiAgICBjYXNlIDI5MjE6IC8vIHRleHQtZGVjb3JhdGlvbiwgZmlsdGVyLCBjbGlwLXBhdGgsIGJhY2tmYWNlLXZpc2liaWxpdHksIGNvbHVtbiwgYm94LWRlY29yYXRpb24tYnJlYWtcblxuICAgIGNhc2UgNTU3MjpcbiAgICBjYXNlIDYzNTY6XG4gICAgY2FzZSA1ODQ0OlxuICAgIGNhc2UgMzE5MTpcbiAgICBjYXNlIDY2NDU6XG4gICAgY2FzZSAzMDA1OiAvLyBtYXNrLCBtYXNrLWltYWdlLCBtYXNrLShtb2RlfGNsaXB8c2l6ZSksIG1hc2stKHJlcGVhdHxvcmlnaW4pLCBtYXNrLXBvc2l0aW9uLCBtYXNrLWNvbXBvc2l0ZSxcblxuICAgIGNhc2UgNjM5MTpcbiAgICBjYXNlIDU4Nzk6XG4gICAgY2FzZSA1NjIzOlxuICAgIGNhc2UgNjEzNTpcbiAgICBjYXNlIDQ1OTk6XG4gICAgY2FzZSA0ODU1OiAvLyBiYWNrZ3JvdW5kLWNsaXAsIGNvbHVtbnMsIGNvbHVtbi0oY291bnR8ZmlsbHxnYXB8cnVsZXxydWxlLWNvbG9yfHJ1bGUtc3R5bGV8cnVsZS13aWR0aHxzcGFufHdpZHRoKVxuXG4gICAgY2FzZSA0MjE1OlxuICAgIGNhc2UgNjM4OTpcbiAgICBjYXNlIDUxMDk6XG4gICAgY2FzZSA1MzY1OlxuICAgIGNhc2UgNTYyMTpcbiAgICBjYXNlIDM4Mjk6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyB2YWx1ZTtcbiAgICAvLyBhcHBlYXJhbmNlLCB1c2VyLXNlbGVjdCwgdHJhbnNmb3JtLCBoeXBoZW5zLCB0ZXh0LXNpemUtYWRqdXN0XG5cbiAgICBjYXNlIDUzNDk6XG4gICAgY2FzZSA0MjQ2OlxuICAgIGNhc2UgNDgxMDpcbiAgICBjYXNlIDY5Njg6XG4gICAgY2FzZSAyNzU2OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTU9aICsgdmFsdWUgKyBNUyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gZmxleCwgZmxleC1kaXJlY3Rpb25cblxuICAgIGNhc2UgNjgyODpcbiAgICBjYXNlIDQyNjg6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gb3JkZXJcblxuICAgIGNhc2UgNjE2NTpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtJyArIHZhbHVlICsgdmFsdWU7XG4gICAgLy8gYWxpZ24taXRlbXNcblxuICAgIGNhc2UgNTE4NzpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIHJlcGxhY2UodmFsdWUsIC8oXFx3KykuKyg6W15dKykvLCBXRUJLSVQgKyAnYm94LSQxJDInICsgTVMgKyAnZmxleC0kMSQyJykgKyB2YWx1ZTtcbiAgICAvLyBhbGlnbi1zZWxmXG5cbiAgICBjYXNlIDU0NDM6XG4gICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArICdmbGV4LWl0ZW0tJyArIHJlcGxhY2UodmFsdWUsIC9mbGV4LXwtc2VsZi8sICcnKSArIHZhbHVlO1xuICAgIC8vIGFsaWduLWNvbnRlbnRcblxuICAgIGNhc2UgNDY3NTpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgJ2ZsZXgtbGluZS1wYWNrJyArIHJlcGxhY2UodmFsdWUsIC9hbGlnbi1jb250ZW50fGZsZXgtfC1zZWxmLywgJycpICsgdmFsdWU7XG4gICAgLy8gZmxleC1zaHJpbmtcblxuICAgIGNhc2UgNTU0ODpcbiAgICAgIHJldHVybiBXRUJLSVQgKyB2YWx1ZSArIE1TICsgcmVwbGFjZSh2YWx1ZSwgJ3NocmluaycsICduZWdhdGl2ZScpICsgdmFsdWU7XG4gICAgLy8gZmxleC1iYXNpc1xuXG4gICAgY2FzZSA1MjkyOlxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnYmFzaXMnLCAncHJlZmVycmVkLXNpemUnKSArIHZhbHVlO1xuICAgIC8vIGZsZXgtZ3Jvd1xuXG4gICAgY2FzZSA2MDYwOlxuICAgICAgcmV0dXJuIFdFQktJVCArICdib3gtJyArIHJlcGxhY2UodmFsdWUsICctZ3JvdycsICcnKSArIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAnZ3JvdycsICdwb3NpdGl2ZScpICsgdmFsdWU7XG4gICAgLy8gdHJhbnNpdGlvblxuXG4gICAgY2FzZSA0NTU0OlxuICAgICAgcmV0dXJuIFdFQktJVCArIHJlcGxhY2UodmFsdWUsIC8oW14tXSkodHJhbnNmb3JtKS9nLCAnJDEnICsgV0VCS0lUICsgJyQyJykgKyB2YWx1ZTtcbiAgICAvLyBjdXJzb3JcblxuICAgIGNhc2UgNjE4NzpcbiAgICAgIHJldHVybiByZXBsYWNlKHJlcGxhY2UocmVwbGFjZSh2YWx1ZSwgLyh6b29tLXxncmFiKS8sIFdFQktJVCArICckMScpLCAvKGltYWdlLXNldCkvLCBXRUJLSVQgKyAnJDEnKSwgdmFsdWUsICcnKSArIHZhbHVlO1xuICAgIC8vIGJhY2tncm91bmQsIGJhY2tncm91bmQtaW1hZ2VcblxuICAgIGNhc2UgNTQ5NTpcbiAgICBjYXNlIDM5NTk6XG4gICAgICByZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyhpbWFnZS1zZXRcXChbXl0qKS8sIFdFQktJVCArICckMScgKyAnJGAkMScpO1xuICAgIC8vIGp1c3RpZnktY29udGVudFxuXG4gICAgY2FzZSA0OTY4OlxuICAgICAgcmV0dXJuIHJlcGxhY2UocmVwbGFjZSh2YWx1ZSwgLyguKzopKGZsZXgtKT8oLiopLywgV0VCS0lUICsgJ2JveC1wYWNrOiQzJyArIE1TICsgJ2ZsZXgtcGFjazokMycpLCAvcy4rLWJbXjtdKy8sICdqdXN0aWZ5JykgKyBXRUJLSVQgKyB2YWx1ZSArIHZhbHVlO1xuICAgIC8vIChtYXJnaW58cGFkZGluZyktaW5saW5lLShzdGFydHxlbmQpXG5cbiAgICBjYXNlIDQwOTU6XG4gICAgY2FzZSAzNTgzOlxuICAgIGNhc2UgNDA2ODpcbiAgICBjYXNlIDI1MzI6XG4gICAgICByZXR1cm4gcmVwbGFjZSh2YWx1ZSwgLyguKyktaW5saW5lKC4rKS8sIFdFQktJVCArICckMSQyJykgKyB2YWx1ZTtcbiAgICAvLyAobWlufG1heCk/KHdpZHRofGhlaWdodHxpbmxpbmUtc2l6ZXxibG9jay1zaXplKVxuXG4gICAgY2FzZSA4MTE2OlxuICAgIGNhc2UgNzA1OTpcbiAgICBjYXNlIDU3NTM6XG4gICAgY2FzZSA1NTM1OlxuICAgIGNhc2UgNTQ0NTpcbiAgICBjYXNlIDU3MDE6XG4gICAgY2FzZSA0OTMzOlxuICAgIGNhc2UgNDY3NzpcbiAgICBjYXNlIDU1MzM6XG4gICAgY2FzZSA1Nzg5OlxuICAgIGNhc2UgNTAyMTpcbiAgICBjYXNlIDQ3NjU6XG4gICAgICAvLyBzdHJldGNoLCBtYXgtY29udGVudCwgbWluLWNvbnRlbnQsIGZpbGwtYXZhaWxhYmxlXG4gICAgICBpZiAoc3RybGVuKHZhbHVlKSAtIDEgLSBsZW5ndGggPiA2KSBzd2l0Y2ggKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgMSkpIHtcbiAgICAgICAgLy8gKG0pYXgtY29udGVudCwgKG0paW4tY29udGVudFxuICAgICAgICBjYXNlIDEwOTpcbiAgICAgICAgICAvLyAtXG4gICAgICAgICAgaWYgKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgNCkgIT09IDQ1KSBicmVhaztcbiAgICAgICAgLy8gKGYpaWxsLWF2YWlsYWJsZSwgKGYpaXQtY29udGVudFxuXG4gICAgICAgIGNhc2UgMTAyOlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoLispLShbXl0rKS8sICckMScgKyBXRUJLSVQgKyAnJDItJDMnICsgJyQxJyArIE1PWiArIChjaGFyYXQodmFsdWUsIGxlbmd0aCArIDMpID09IDEwOCA/ICckMycgOiAnJDItJDMnKSkgKyB2YWx1ZTtcbiAgICAgICAgLy8gKHMpdHJldGNoXG5cbiAgICAgICAgY2FzZSAxMTU6XG4gICAgICAgICAgcmV0dXJuIH5pbmRleG9mKHZhbHVlLCAnc3RyZXRjaCcpID8gcHJlZml4KHJlcGxhY2UodmFsdWUsICdzdHJldGNoJywgJ2ZpbGwtYXZhaWxhYmxlJyksIGxlbmd0aCkgKyB2YWx1ZSA6IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgLy8gcG9zaXRpb246IHN0aWNreVxuXG4gICAgY2FzZSA0OTQ5OlxuICAgICAgLy8gKHMpdGlja3k/XG4gICAgICBpZiAoY2hhcmF0KHZhbHVlLCBsZW5ndGggKyAxKSAhPT0gMTE1KSBicmVhaztcbiAgICAvLyBkaXNwbGF5OiAoZmxleHxpbmxpbmUtZmxleClcblxuICAgIGNhc2UgNjQ0NDpcbiAgICAgIHN3aXRjaCAoY2hhcmF0KHZhbHVlLCBzdHJsZW4odmFsdWUpIC0gMyAtICh+aW5kZXhvZih2YWx1ZSwgJyFpbXBvcnRhbnQnKSAmJiAxMCkpKSB7XG4gICAgICAgIC8vIHN0aWMoayl5XG4gICAgICAgIGNhc2UgMTA3OlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAnOicsICc6JyArIFdFQktJVCkgKyB2YWx1ZTtcbiAgICAgICAgLy8gKGlubGluZS0pP2ZsKGUpeFxuXG4gICAgICAgIGNhc2UgMTAxOlxuICAgICAgICAgIHJldHVybiByZXBsYWNlKHZhbHVlLCAvKC4rOikoW147IV0rKSg7fCEuKyk/LywgJyQxJyArIFdFQktJVCArIChjaGFyYXQodmFsdWUsIDE0KSA9PT0gNDUgPyAnaW5saW5lLScgOiAnJykgKyAnYm94JDMnICsgJyQxJyArIFdFQktJVCArICckMiQzJyArICckMScgKyBNUyArICckMmJveCQzJykgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgLy8gd3JpdGluZy1tb2RlXG5cbiAgICBjYXNlIDU5MzY6XG4gICAgICBzd2l0Y2ggKGNoYXJhdCh2YWx1ZSwgbGVuZ3RoICsgMTEpKSB7XG4gICAgICAgIC8vIHZlcnRpY2FsLWwocilcbiAgICAgICAgY2FzZSAxMTQ6XG4gICAgICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyByZXBsYWNlKHZhbHVlLCAvW3N2aF1cXHcrLVt0YmxyXXsyfS8sICd0YicpICsgdmFsdWU7XG4gICAgICAgIC8vIHZlcnRpY2FsLXIobClcblxuICAgICAgICBjYXNlIDEwODpcbiAgICAgICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgJ3RiLXJsJykgKyB2YWx1ZTtcbiAgICAgICAgLy8gaG9yaXpvbnRhbCgtKXRiXG5cbiAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICByZXR1cm4gV0VCS0lUICsgdmFsdWUgKyBNUyArIHJlcGxhY2UodmFsdWUsIC9bc3ZoXVxcdystW3RibHJdezJ9LywgJ2xyJykgKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFdFQktJVCArIHZhbHVlICsgTVMgKyB2YWx1ZSArIHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgcHJlZml4ZXIgPSBmdW5jdGlvbiBwcmVmaXhlcihlbGVtZW50LCBpbmRleCwgY2hpbGRyZW4sIGNhbGxiYWNrKSB7XG4gIGlmIChlbGVtZW50Lmxlbmd0aCA+IC0xKSBpZiAoIWVsZW1lbnRbXCJyZXR1cm5cIl0pIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XG4gICAgY2FzZSBERUNMQVJBVElPTjpcbiAgICAgIGVsZW1lbnRbXCJyZXR1cm5cIl0gPSBwcmVmaXgoZWxlbWVudC52YWx1ZSwgZWxlbWVudC5sZW5ndGgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIEtFWUZSQU1FUzpcbiAgICAgIHJldHVybiBzZXJpYWxpemUoW2NvcHkoZWxlbWVudCwge1xuICAgICAgICB2YWx1ZTogcmVwbGFjZShlbGVtZW50LnZhbHVlLCAnQCcsICdAJyArIFdFQktJVClcbiAgICAgIH0pXSwgY2FsbGJhY2spO1xuXG4gICAgY2FzZSBSVUxFU0VUOlxuICAgICAgaWYgKGVsZW1lbnQubGVuZ3RoKSByZXR1cm4gY29tYmluZShlbGVtZW50LnByb3BzLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgc3dpdGNoIChtYXRjaCh2YWx1ZSwgLyg6OnBsYWNcXHcrfDpyZWFkLVxcdyspLykpIHtcbiAgICAgICAgICAvLyA6cmVhZC0ob25seXx3cml0ZSlcbiAgICAgICAgICBjYXNlICc6cmVhZC1vbmx5JzpcbiAgICAgICAgICBjYXNlICc6cmVhZC13cml0ZSc6XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFtjb3B5KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgcHJvcHM6IFtyZXBsYWNlKHZhbHVlLCAvOihyZWFkLVxcdyspLywgJzonICsgTU9aICsgJyQxJyldXG4gICAgICAgICAgICB9KV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAvLyA6cGxhY2Vob2xkZXJcblxuICAgICAgICAgIGNhc2UgJzo6cGxhY2Vob2xkZXInOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShbY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgV0VCS0lUICsgJ2lucHV0LSQxJyldXG4gICAgICAgICAgICB9KSwgY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgJzonICsgTU9aICsgJyQxJyldXG4gICAgICAgICAgICB9KSwgY29weShlbGVtZW50LCB7XG4gICAgICAgICAgICAgIHByb3BzOiBbcmVwbGFjZSh2YWx1ZSwgLzoocGxhY1xcdyspLywgTVMgKyAnaW5wdXQtJDEnKV1cbiAgICAgICAgICAgIH0pXSwgY2FsbGJhY2spO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfSk7XG4gIH1cbn07XG5cbnZhciBpc0Jyb3dzZXIkNSA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgZ2V0U2VydmVyU3R5bGlzQ2FjaGUgPSBpc0Jyb3dzZXIkNSA/IHVuZGVmaW5lZCA6IHdlYWtNZW1vaXplKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG1lbW9pemUoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYWNoZSA9IHt9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgcmV0dXJuIGNhY2hlW25hbWVdO1xuICAgIH07XG4gIH0pO1xufSk7XG52YXIgZGVmYXVsdFN0eWxpc1BsdWdpbnMgPSBbcHJlZml4ZXJdO1xuXG52YXIgY3JlYXRlQ2FjaGUgPSBmdW5jdGlvbiBjcmVhdGVDYWNoZShvcHRpb25zKSB7XG4gIHZhciBrZXkgPSBvcHRpb25zLmtleTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAha2V5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGhhdmUgdG8gY29uZmlndXJlIGBrZXlgIGZvciB5b3VyIGNhY2hlLiBQbGVhc2UgbWFrZSBzdXJlIGl0J3MgdW5pcXVlIChhbmQgbm90IGVxdWFsIHRvICdjc3MnKSBhcyBpdCdzIHVzZWQgZm9yIGxpbmtpbmcgc3R5bGVzIHRvIHlvdXIgY2FjaGUuXFxuXCIgKyBcIklmIG11bHRpcGxlIGNhY2hlcyBzaGFyZSB0aGUgc2FtZSBrZXkgdGhleSBtaWdodCBcXFwiZmlnaHRcXFwiIGZvciBlYWNoIG90aGVyJ3Mgc3R5bGUgZWxlbWVudHMuXCIpO1xuICB9XG5cbiAgaWYgKGlzQnJvd3NlciQ1ICYmIGtleSA9PT0gJ2NzcycpIHtcbiAgICB2YXIgc3NyU3R5bGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtZW1vdGlvbl06bm90KFtkYXRhLXNdKVwiKTsgLy8gZ2V0IFNTUmVkIHN0eWxlcyBvdXQgb2YgdGhlIHdheSBvZiBSZWFjdCdzIGh5ZHJhdGlvblxuICAgIC8vIGRvY3VtZW50LmhlYWQgaXMgYSBzYWZlIHBsYWNlIHRvIG1vdmUgdGhlbSB0byh0aG91Z2ggbm90ZSBkb2N1bWVudC5oZWFkIGlzIG5vdCBuZWNlc3NhcmlseSB0aGUgbGFzdCBwbGFjZSB0aGV5IHdpbGwgYmUpXG4gICAgLy8gbm90ZSB0aGlzIHZlcnkgdmVyeSBpbnRlbnRpb25hbGx5IHRhcmdldHMgYWxsIHN0eWxlIGVsZW1lbnRzIHJlZ2FyZGxlc3Mgb2YgdGhlIGtleSB0byBlbnN1cmVcbiAgICAvLyB0aGF0IGNyZWF0aW5nIGEgY2FjaGUgd29ya3MgaW5zaWRlIG9mIHJlbmRlciBvZiBhIFJlYWN0IGNvbXBvbmVudFxuXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChzc3JTdHlsZXMsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAvLyB3ZSB3YW50IHRvIG9ubHkgbW92ZSBlbGVtZW50cyB3aGljaCBoYXZlIGEgc3BhY2UgaW4gdGhlIGRhdGEtZW1vdGlvbiBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgIC8vIGJlY2F1c2UgdGhhdCBpbmRpY2F0ZXMgdGhhdCBpdCBpcyBhbiBFbW90aW9uIDExIHNlcnZlci1zaWRlIHJlbmRlcmVkIHN0eWxlIGVsZW1lbnRzXG4gICAgICAvLyB3aGlsZSB3ZSB3aWxsIGFscmVhZHkgaWdub3JlIEVtb3Rpb24gMTEgY2xpZW50LXNpZGUgaW5zZXJ0ZWQgc3R5bGVzIGJlY2F1c2Ugb2YgdGhlIDpub3QoW2RhdGEtc10pIHBhcnQgaW4gdGhlIHNlbGVjdG9yXG4gICAgICAvLyBFbW90aW9uIDEwIGNsaWVudC1zaWRlIGluc2VydGVkIHN0eWxlcyBkaWQgbm90IGhhdmUgZGF0YS1zIChidXQgaW1wb3J0YW50bHkgZGlkIG5vdCBoYXZlIGEgc3BhY2UgaW4gdGhlaXIgZGF0YS1lbW90aW9uIGF0dHJpYnV0ZXMpXG4gICAgICAvLyBzbyBjaGVja2luZyBmb3IgdGhlIHNwYWNlIGVuc3VyZXMgdGhhdCBsb2FkaW5nIEVtb3Rpb24gMTEgYWZ0ZXIgRW1vdGlvbiAxMCBoYXMgaW5zZXJ0ZWQgc29tZSBzdHlsZXNcbiAgICAgIC8vIHdpbGwgbm90IHJlc3VsdCBpbiB0aGUgRW1vdGlvbiAxMCBzdHlsZXMgYmVpbmcgZGVzdHJveWVkXG4gICAgICB2YXIgZGF0YUVtb3Rpb25BdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1lbW90aW9uJyk7XG5cbiAgICAgIGlmIChkYXRhRW1vdGlvbkF0dHJpYnV0ZS5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1zJywgJycpO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHN0eWxpc1BsdWdpbnMgPSBvcHRpb25zLnN0eWxpc1BsdWdpbnMgfHwgZGVmYXVsdFN0eWxpc1BsdWdpbnM7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lXG4gICAgaWYgKC9bXmEtei1dLy50ZXN0KGtleSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkVtb3Rpb24ga2V5IG11c3Qgb25seSBjb250YWluIGxvd2VyIGNhc2UgYWxwaGFiZXRpY2FsIGNoYXJhY3RlcnMgYW5kIC0gYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcGFzc2VkXCIpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbnNlcnRlZCA9IHt9O1xuICB2YXIgY29udGFpbmVyO1xuICB2YXIgbm9kZXNUb0h5ZHJhdGUgPSBbXTtcblxuICBpZiAoaXNCcm93c2VyJDUpIHtcbiAgICBjb250YWluZXIgPSBvcHRpb25zLmNvbnRhaW5lciB8fCBkb2N1bWVudC5oZWFkO1xuICAgIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLmNhbGwoIC8vIHRoaXMgbWVhbnMgd2Ugd2lsbCBpZ25vcmUgZWxlbWVudHMgd2hpY2ggZG9uJ3QgaGF2ZSBhIHNwYWNlIGluIHRoZW0gd2hpY2hcbiAgICAvLyBtZWFucyB0aGF0IHRoZSBzdHlsZSBlbGVtZW50cyB3ZSdyZSBsb29raW5nIGF0IGFyZSBvbmx5IEVtb3Rpb24gMTEgc2VydmVyLXJlbmRlcmVkIHN0eWxlIGVsZW1lbnRzXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2RhdGEtZW1vdGlvbl49XFxcIlwiICsga2V5ICsgXCIgXFxcIl1cIiksIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICB2YXIgYXR0cmliID0gbm9kZS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWVtb3Rpb25cIikuc3BsaXQoJyAnKTsgLy8gJEZsb3dGaXhNZVxuXG4gICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGF0dHJpYi5sZW5ndGg7IGkrKykge1xuICAgICAgICBpbnNlcnRlZFthdHRyaWJbaV1dID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZXNUb0h5ZHJhdGUucHVzaChub2RlKTtcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBfaW5zZXJ0O1xuXG4gIHZhciBvbW5pcHJlc2VudFBsdWdpbnMgPSBbY29tcGF0LCByZW1vdmVMYWJlbF07XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBvbW5pcHJlc2VudFBsdWdpbnMucHVzaChjcmVhdGVVbnNhZmVTZWxlY3RvcnNBbGFybSh7XG4gICAgICBnZXQgY29tcGF0KCkge1xuICAgICAgICByZXR1cm4gY2FjaGUuY29tcGF0O1xuICAgICAgfVxuXG4gICAgfSksIGluY29ycmVjdEltcG9ydEFsYXJtKTtcbiAgfVxuXG4gIGlmIChpc0Jyb3dzZXIkNSkge1xuICAgIHZhciBjdXJyZW50U2hlZXQ7XG4gICAgdmFyIGZpbmFsaXppbmdQbHVnaW5zID0gW3N0cmluZ2lmeSwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQucm9vdCkge1xuICAgICAgICBpZiAoZWxlbWVudFtcInJldHVyblwiXSkge1xuICAgICAgICAgIGN1cnJlbnRTaGVldC5pbnNlcnQoZWxlbWVudFtcInJldHVyblwiXSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC52YWx1ZSAmJiBlbGVtZW50LnR5cGUgIT09IENPTU1FTlQpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgZW1wdHkgcnVsZSBpbiBub24tcHJvZHVjdGlvbiBlbnZpcm9ubWVudHNcbiAgICAgICAgICAvLyBzbyBAZW1vdGlvbi9qZXN0IGNhbiBncmFiIGBrZXlgIGZyb20gdGhlIChKUylET00gZm9yIGNhY2hlcyB3aXRob3V0IGFueSBydWxlcyBpbnNlcnRlZCB5ZXRcbiAgICAgICAgICBjdXJyZW50U2hlZXQuaW5zZXJ0KGVsZW1lbnQudmFsdWUgKyBcInt9XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA6IHJ1bGVzaGVldChmdW5jdGlvbiAocnVsZSkge1xuICAgICAgY3VycmVudFNoZWV0Lmluc2VydChydWxlKTtcbiAgICB9KV07XG4gICAgdmFyIHNlcmlhbGl6ZXIgPSBtaWRkbGV3YXJlKG9tbmlwcmVzZW50UGx1Z2lucy5jb25jYXQoc3R5bGlzUGx1Z2lucywgZmluYWxpemluZ1BsdWdpbnMpKTtcblxuICAgIHZhciBzdHlsaXMgPSBmdW5jdGlvbiBzdHlsaXMoc3R5bGVzKSB7XG4gICAgICByZXR1cm4gc2VyaWFsaXplKGNvbXBpbGUoc3R5bGVzKSwgc2VyaWFsaXplcik7XG4gICAgfTtcblxuICAgIF9pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQoc2VsZWN0b3IsIHNlcmlhbGl6ZWQsIHNoZWV0LCBzaG91bGRDYWNoZSkge1xuICAgICAgY3VycmVudFNoZWV0ID0gc2hlZXQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHNlcmlhbGl6ZWQubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY3VycmVudFNoZWV0ID0ge1xuICAgICAgICAgIGluc2VydDogZnVuY3Rpb24gaW5zZXJ0KHJ1bGUpIHtcbiAgICAgICAgICAgIHNoZWV0Lmluc2VydChydWxlICsgc2VyaWFsaXplZC5tYXApO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgc3R5bGlzKHNlbGVjdG9yID8gc2VsZWN0b3IgKyBcIntcIiArIHNlcmlhbGl6ZWQuc3R5bGVzICsgXCJ9XCIgOiBzZXJpYWxpemVkLnN0eWxlcyk7XG5cbiAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICBjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHZhciBfZmluYWxpemluZ1BsdWdpbnMgPSBbc3RyaW5naWZ5XTtcblxuICAgIHZhciBfc2VyaWFsaXplciA9IG1pZGRsZXdhcmUob21uaXByZXNlbnRQbHVnaW5zLmNvbmNhdChzdHlsaXNQbHVnaW5zLCBfZmluYWxpemluZ1BsdWdpbnMpKTtcblxuICAgIHZhciBfc3R5bGlzID0gZnVuY3Rpb24gX3N0eWxpcyhzdHlsZXMpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemUoY29tcGlsZShzdHlsZXMpLCBfc2VyaWFsaXplcik7XG4gICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICB2YXIgc2VydmVyU3R5bGlzQ2FjaGUgPSBnZXRTZXJ2ZXJTdHlsaXNDYWNoZShzdHlsaXNQbHVnaW5zKShrZXkpO1xuXG4gICAgdmFyIGdldFJ1bGVzID0gZnVuY3Rpb24gZ2V0UnVsZXMoc2VsZWN0b3IsIHNlcmlhbGl6ZWQpIHtcbiAgICAgIHZhciBuYW1lID0gc2VyaWFsaXplZC5uYW1lO1xuXG4gICAgICBpZiAoc2VydmVyU3R5bGlzQ2FjaGVbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZXJ2ZXJTdHlsaXNDYWNoZVtuYW1lXSA9IF9zdHlsaXMoc2VsZWN0b3IgPyBzZWxlY3RvciArIFwie1wiICsgc2VyaWFsaXplZC5zdHlsZXMgKyBcIn1cIiA6IHNlcmlhbGl6ZWQuc3R5bGVzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlcnZlclN0eWxpc0NhY2hlW25hbWVdO1xuICAgIH07XG5cbiAgICBfaW5zZXJ0ID0gZnVuY3Rpb24gX2luc2VydChzZWxlY3Rvciwgc2VyaWFsaXplZCwgc2hlZXQsIHNob3VsZENhY2hlKSB7XG4gICAgICB2YXIgbmFtZSA9IHNlcmlhbGl6ZWQubmFtZTtcbiAgICAgIHZhciBydWxlcyA9IGdldFJ1bGVzKHNlbGVjdG9yLCBzZXJpYWxpemVkKTtcblxuICAgICAgaWYgKGNhY2hlLmNvbXBhdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGluIHJlZ3VsYXIgbW9kZSwgd2UgZG9uJ3Qgc2V0IHRoZSBzdHlsZXMgb24gdGhlIGluc2VydGVkIGNhY2hlXG4gICAgICAgIC8vIHNpbmNlIHdlIGRvbid0IG5lZWQgdG8gYW5kIHRoYXQgd291bGQgYmUgd2FzdGluZyBtZW1vcnlcbiAgICAgICAgLy8gd2UgcmV0dXJuIHRoZW0gc28gdGhhdCB0aGV5IGFyZSByZW5kZXJlZCBpbiBhIHN0eWxlIHRhZ1xuICAgICAgICBpZiAoc2hvdWxkQ2FjaGUpIHtcbiAgICAgICAgICBjYWNoZS5pbnNlcnRlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIC8vIHVzaW5nID09PSBkZXZlbG9wbWVudCBpbnN0ZWFkIG9mICE9PSBwcm9kdWN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgaWYgcGVvcGxlIGRvIHNzciBpbiB0ZXN0cywgdGhlIHNvdXJjZSBtYXBzIHNob3dpbmcgdXAgd291bGQgYmUgYW5ub3lpbmdcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcgJiYgc2VyaWFsaXplZC5tYXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBydWxlcyArIHNlcmlhbGl6ZWQubWFwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW4gY29tcGF0IG1vZGUsIHdlIHB1dCB0aGUgc3R5bGVzIG9uIHRoZSBpbnNlcnRlZCBjYWNoZSBzb1xuICAgICAgICAvLyB0aGF0IGVtb3Rpb24tc2VydmVyIGNhbiBwdWxsIG91dCB0aGUgc3R5bGVzXG4gICAgICAgIC8vIGV4Y2VwdCB3aGVuIHdlIGRvbid0IHdhbnQgdG8gY2FjaGUgaXQgd2hpY2ggd2FzIGluIEdsb2JhbCBidXQgbm93XG4gICAgICAgIC8vIGlzIG5vd2hlcmUgYnV0IHdlIGRvbid0IHdhbnQgdG8gZG8gYSBtYWpvciByaWdodCBub3dcbiAgICAgICAgLy8gYW5kIGp1c3QgaW4gY2FzZSB3ZSdyZSBnb2luZyB0byBsZWF2ZSB0aGUgY2FzZSBoZXJlXG4gICAgICAgIC8vIGl0J3MgYWxzbyBub3QgYWZmZWN0aW5nIGNsaWVudCBzaWRlIGJ1bmRsZSBzaXplXG4gICAgICAgIC8vIHNvIGl0J3MgcmVhbGx5IG5vdCBhIGJpZyBkZWFsXG4gICAgICAgIGlmIChzaG91bGRDYWNoZSkge1xuICAgICAgICAgIGNhY2hlLmluc2VydGVkW25hbWVdID0gcnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHJ1bGVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYWNoZSA9IHtcbiAgICBrZXk6IGtleSxcbiAgICBzaGVldDogbmV3IFN0eWxlU2hlZXQoe1xuICAgICAga2V5OiBrZXksXG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIG5vbmNlOiBvcHRpb25zLm5vbmNlLFxuICAgICAgc3BlZWR5OiBvcHRpb25zLnNwZWVkeSxcbiAgICAgIHByZXBlbmQ6IG9wdGlvbnMucHJlcGVuZCxcbiAgICAgIGluc2VydGlvblBvaW50OiBvcHRpb25zLmluc2VydGlvblBvaW50XG4gICAgfSksXG4gICAgbm9uY2U6IG9wdGlvbnMubm9uY2UsXG4gICAgaW5zZXJ0ZWQ6IGluc2VydGVkLFxuICAgIHJlZ2lzdGVyZWQ6IHt9LFxuICAgIGluc2VydDogX2luc2VydFxuICB9O1xuICBjYWNoZS5zaGVldC5oeWRyYXRlKG5vZGVzVG9IeWRyYXRlKTtcbiAgcmV0dXJuIGNhY2hlO1xufTtcblxudmFyIGlzQnJvd3NlciQ0ID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRTdHlsZXMkMShyZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWVzKSB7XG4gIHZhciByYXdDbGFzc05hbWUgPSAnJztcbiAgY2xhc3NOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChyZWdpc3RlcmVkW2NsYXNzTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSArIFwiO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3Q2xhc3NOYW1lICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdDbGFzc05hbWU7XG59XG52YXIgcmVnaXN0ZXJTdHlsZXMkMSA9IGZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZykge1xuICB2YXIgY2xhc3NOYW1lID0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgaWYgKCAvLyB3ZSBvbmx5IG5lZWQgdG8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIHJlZ2lzdGVyZWQgY2FjaGUgaWYgdGhlXG4gIC8vIGNsYXNzIG5hbWUgY291bGQgYmUgdXNlZCBmdXJ0aGVyIGRvd25cbiAgLy8gdGhlIHRyZWUgYnV0IGlmIGl0J3MgYSBzdHJpbmcgdGFnLCB3ZSBrbm93IGl0IHdvbid0XG4gIC8vIHNvIHdlIGRvbid0IGhhdmUgdG8gYWRkIGl0IHRvIHJlZ2lzdGVyZWQgY2FjaGUuXG4gIC8vIHRoaXMgaW1wcm92ZXMgbWVtb3J5IHVzYWdlIHNpbmNlIHdlIGNhbiBhdm9pZCBzdG9yaW5nIHRoZSB3aG9sZSBzdHlsZSBzdHJpbmdcbiAgKGlzU3RyaW5nVGFnID09PSBmYWxzZSB8fCAvLyB3ZSBuZWVkIHRvIGFsd2F5cyBzdG9yZSBpdCBpZiB3ZSdyZSBpbiBjb21wYXQgbW9kZSBhbmRcbiAgLy8gaW4gbm9kZSBzaW5jZSBlbW90aW9uLXNlcnZlciByZWxpZXMgb24gd2hldGhlciBhIHN0eWxlIGlzIGluXG4gIC8vIHRoZSByZWdpc3RlcmVkIGNhY2hlIHRvIGtub3cgd2hldGhlciBhIHN0eWxlIGlzIGdsb2JhbCBvciBub3RcbiAgLy8gYWxzbywgbm90ZSB0aGF0IHRoaXMgY2hlY2sgd2lsbCBiZSBkZWFkIGNvZGUgZWxpbWluYXRlZCBpbiB0aGUgYnJvd3NlclxuICBpc0Jyb3dzZXIkNCA9PT0gZmFsc2UgJiYgY2FjaGUuY29tcGF0ICE9PSB1bmRlZmluZWQpICYmIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2FjaGUucmVnaXN0ZXJlZFtjbGFzc05hbWVdID0gc2VyaWFsaXplZC5zdHlsZXM7XG4gIH1cbn07XG52YXIgaW5zZXJ0U3R5bGVzJDEgPSBmdW5jdGlvbiBpbnNlcnRTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKSB7XG4gIHJlZ2lzdGVyU3R5bGVzJDEoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmIChjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3R5bGVzRm9yU1NSID0gJyc7XG4gICAgdmFyIGN1cnJlbnQgPSBzZXJpYWxpemVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG1heWJlU3R5bGVzID0gY2FjaGUuaW5zZXJ0KHNlcmlhbGl6ZWQgPT09IGN1cnJlbnQgPyBcIi5cIiArIGNsYXNzTmFtZSA6ICcnLCBjdXJyZW50LCBjYWNoZS5zaGVldCwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNCcm93c2VyJDQgJiYgbWF5YmVTdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZXNGb3JTU1IgKz0gbWF5YmVTdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcblxuICAgIGlmICghaXNCcm93c2VyJDQgJiYgc3R5bGVzRm9yU1NSLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxlc0ZvclNTUjtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L211cm11cmhhc2gtanNcbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hYXBwbGVieS9zbWhhc2hlci9ibG9iLzYxYTA1MzBmMjgyNzdmMmU4NTBiZmMzOTYwMGNlNjFkMDJiNTE4ZGUvc3JjL011cm11ckhhc2gyLmNwcCNMMzctTDg2XG5mdW5jdGlvbiBtdXJtdXIyJDEoc3RyKSB7XG4gIC8vICdtJyBhbmQgJ3InIGFyZSBtaXhpbmcgY29uc3RhbnRzIGdlbmVyYXRlZCBvZmZsaW5lLlxuICAvLyBUaGV5J3JlIG5vdCByZWFsbHkgJ21hZ2ljJywgdGhleSBqdXN0IGhhcHBlbiB0byB3b3JrIHdlbGwuXG4gIC8vIGNvbnN0IG0gPSAweDViZDFlOTk1O1xuICAvLyBjb25zdCByID0gMjQ7XG4gIC8vIEluaXRpYWxpemUgdGhlIGhhc2hcbiAgdmFyIGggPSAwOyAvLyBNaXggNCBieXRlcyBhdCBhIHRpbWUgaW50byB0aGUgaGFzaFxuXG4gIHZhciBrLFxuICAgICAgaSA9IDAsXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xuXG4gIGZvciAoOyBsZW4gPj0gNDsgKytpLCBsZW4gLT0gNCkge1xuICAgIGsgPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYgfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDggfCAoc3RyLmNoYXJDb2RlQXQoKytpKSAmIDB4ZmYpIDw8IDE2IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAyNDtcbiAgICBrID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgICBrIF49XG4gICAgLyogayA+Pj4gcjogKi9cbiAgICBrID4+PiAyNDtcbiAgICBoID1cbiAgICAvKiBNYXRoLmltdWwoaywgbSk6ICovXG4gICAgKGsgJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoayA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KSBeXG4gICAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gSGFuZGxlIHRoZSBsYXN0IGZldyBieXRlcyBvZiB0aGUgaW5wdXQgYXJyYXlcblxuXG4gIHN3aXRjaCAobGVuKSB7XG4gICAgY2FzZSAzOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDIpICYgMHhmZikgPDwgMTY7XG5cbiAgICBjYXNlIDI6XG4gICAgICBoIF49IChzdHIuY2hhckNvZGVBdChpICsgMSkgJiAweGZmKSA8PCA4O1xuXG4gICAgY2FzZSAxOlxuICAgICAgaCBePSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gICAgICBoID1cbiAgICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAgIChoICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGggPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gIH0gLy8gRG8gYSBmZXcgZmluYWwgbWl4ZXMgb2YgdGhlIGhhc2ggdG8gZW5zdXJlIHRoZSBsYXN0IGZld1xuICAvLyBieXRlcyBhcmUgd2VsbC1pbmNvcnBvcmF0ZWQuXG5cblxuICBoIF49IGggPj4+IDEzO1xuICBoID1cbiAgLyogTWF0aC5pbXVsKGgsIG0pOiAqL1xuICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICByZXR1cm4gKChoIF4gaCA+Pj4gMTUpID4+PiAwKS50b1N0cmluZygzNik7XG59XG5cbnZhciB1bml0bGVzc0tleXMkMSA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IDEsXG4gIGJvcmRlckltYWdlT3V0c2V0OiAxLFxuICBib3JkZXJJbWFnZVNsaWNlOiAxLFxuICBib3JkZXJJbWFnZVdpZHRoOiAxLFxuICBib3hGbGV4OiAxLFxuICBib3hGbGV4R3JvdXA6IDEsXG4gIGJveE9yZGluYWxHcm91cDogMSxcbiAgY29sdW1uQ291bnQ6IDEsXG4gIGNvbHVtbnM6IDEsXG4gIGZsZXg6IDEsXG4gIGZsZXhHcm93OiAxLFxuICBmbGV4UG9zaXRpdmU6IDEsXG4gIGZsZXhTaHJpbms6IDEsXG4gIGZsZXhOZWdhdGl2ZTogMSxcbiAgZmxleE9yZGVyOiAxLFxuICBncmlkUm93OiAxLFxuICBncmlkUm93RW5kOiAxLFxuICBncmlkUm93U3BhbjogMSxcbiAgZ3JpZFJvd1N0YXJ0OiAxLFxuICBncmlkQ29sdW1uOiAxLFxuICBncmlkQ29sdW1uRW5kOiAxLFxuICBncmlkQ29sdW1uU3BhbjogMSxcbiAgZ3JpZENvbHVtblN0YXJ0OiAxLFxuICBtc0dyaWRSb3c6IDEsXG4gIG1zR3JpZFJvd1NwYW46IDEsXG4gIG1zR3JpZENvbHVtbjogMSxcbiAgbXNHcmlkQ29sdW1uU3BhbjogMSxcbiAgZm9udFdlaWdodDogMSxcbiAgbGluZUhlaWdodDogMSxcbiAgb3BhY2l0eTogMSxcbiAgb3JkZXI6IDEsXG4gIG9ycGhhbnM6IDEsXG4gIHRhYlNpemU6IDEsXG4gIHdpZG93czogMSxcbiAgekluZGV4OiAxLFxuICB6b29tOiAxLFxuICBXZWJraXRMaW5lQ2xhbXA6IDEsXG4gIC8vIFNWRy1yZWxhdGVkIHByb3BlcnRpZXNcbiAgZmlsbE9wYWNpdHk6IDEsXG4gIGZsb29kT3BhY2l0eTogMSxcbiAgc3RvcE9wYWNpdHk6IDEsXG4gIHN0cm9rZURhc2hhcnJheTogMSxcbiAgc3Ryb2tlRGFzaG9mZnNldDogMSxcbiAgc3Ryb2tlTWl0ZXJsaW1pdDogMSxcbiAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgc3Ryb2tlV2lkdGg6IDFcbn07XG5cbnZhciBJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyID0gXCJZb3UgaGF2ZSBpbGxlZ2FsIGVzY2FwZSBzZXF1ZW5jZSBpbiB5b3VyIHRlbXBsYXRlIGxpdGVyYWwsIG1vc3QgbGlrZWx5IGluc2lkZSBjb250ZW50J3MgcHJvcGVydHkgdmFsdWUuXFxuQmVjYXVzZSB5b3Ugd3JpdGUgeW91ciBDU1MgaW5zaWRlIGEgSmF2YVNjcmlwdCBzdHJpbmcgeW91IGFjdHVhbGx5IGhhdmUgdG8gZG8gZG91YmxlIGVzY2FwaW5nLCBzbyBmb3IgZXhhbXBsZSBcXFwiY29udGVudDogJ1xcXFwwMGQ3JztcXFwiIHNob3VsZCBiZWNvbWUgXFxcImNvbnRlbnQ6ICdcXFxcXFxcXDAwZDcnO1xcXCIuXFxuWW91IGNhbiByZWFkIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxcbmh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL1RlbXBsYXRlX2xpdGVyYWxzI0VTMjAxOF9yZXZpc2lvbl9vZl9pbGxlZ2FsX2VzY2FwZV9zZXF1ZW5jZXNcIjtcbnZhciBVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiQxID0gXCJZb3UgaGF2ZSBwYXNzZWQgaW4gZmFsc3kgdmFsdWUgYXMgc3R5bGUgb2JqZWN0J3Mga2V5IChjYW4gaGFwcGVuIHdoZW4gaW4gZXhhbXBsZSB5b3UgcGFzcyB1bmV4cG9ydGVkIGNvbXBvbmVudCBhcyBjb21wdXRlZCBrZXkpLlwiO1xudmFyIGh5cGhlbmF0ZVJlZ2V4JDEgPSAvW0EtWl18Xm1zL2c7XG52YXIgYW5pbWF0aW9uUmVnZXgkMSA9IC9fRU1PXyhbXl9dKz8pXyhbXl0qPylfRU1PXy9nO1xuXG52YXIgaXNDdXN0b21Qcm9wZXJ0eSQxID0gZnVuY3Rpb24gaXNDdXN0b21Qcm9wZXJ0eShwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcGVydHkuY2hhckNvZGVBdCgxKSA9PT0gNDU7XG59O1xuXG52YXIgaXNQcm9jZXNzYWJsZVZhbHVlJDEgPSBmdW5jdGlvbiBpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlICE9PSAnYm9vbGVhbic7XG59O1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSQxID0gLyogI19fUFVSRV9fICovbWVtb2l6ZShmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XG4gIHJldHVybiBpc0N1c3RvbVByb3BlcnR5JDEoc3R5bGVOYW1lKSA/IHN0eWxlTmFtZSA6IHN0eWxlTmFtZS5yZXBsYWNlKGh5cGhlbmF0ZVJlZ2V4JDEsICctJCYnKS50b0xvd2VyQ2FzZSgpO1xufSk7XG5cbnZhciBwcm9jZXNzU3R5bGVWYWx1ZSQxID0gZnVuY3Rpb24gcHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSkge1xuICBzd2l0Y2ggKGtleSkge1xuICAgIGNhc2UgJ2FuaW1hdGlvbic6XG4gICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnJlcGxhY2UoYW5pbWF0aW9uUmVnZXgkMSwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIGN1cnNvciQxID0ge1xuICAgICAgICAgICAgICBuYW1lOiBwMSxcbiAgICAgICAgICAgICAgc3R5bGVzOiBwMixcbiAgICAgICAgICAgICAgbmV4dDogY3Vyc29yJDFcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcDE7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIGlmICh1bml0bGVzc0tleXMkMVtrZXldICE9PSAxICYmICFpc0N1c3RvbVByb3BlcnR5JDEoa2V5KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlICE9PSAwKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JztcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBjb250ZW50VmFsdWVQYXR0ZXJuJDEgPSAvKHZhcnxhdHRyfGNvdW50ZXJzP3x1cmx8ZWxlbWVudHwoKChyZXBlYXRpbmctKT8obGluZWFyfHJhZGlhbCkpfGNvbmljKS1ncmFkaWVudClcXCh8KG5vLSk/KG9wZW58Y2xvc2UpLXF1b3RlLztcbiAgdmFyIGNvbnRlbnRWYWx1ZXMkMSA9IFsnbm9ybWFsJywgJ25vbmUnLCAnaW5pdGlhbCcsICdpbmhlcml0JywgJ3Vuc2V0J107XG4gIHZhciBvbGRQcm9jZXNzU3R5bGVWYWx1ZSQxID0gcHJvY2Vzc1N0eWxlVmFsdWUkMTtcbiAgdmFyIG1zUGF0dGVybiQxID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4kMSA9IC8tKC4pL2c7XG4gIHZhciBoeXBoZW5hdGVkQ2FjaGUkMSA9IHt9O1xuXG4gIHByb2Nlc3NTdHlsZVZhbHVlJDEgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBjb250ZW50VmFsdWVzJDEuaW5kZXhPZih2YWx1ZSkgPT09IC0xICYmICFjb250ZW50VmFsdWVQYXR0ZXJuJDEudGVzdCh2YWx1ZSkgJiYgKHZhbHVlLmNoYXJBdCgwKSAhPT0gdmFsdWUuY2hhckF0KHZhbHVlLmxlbmd0aCAtIDEpIHx8IHZhbHVlLmNoYXJBdCgwKSAhPT0gJ1wiJyAmJiB2YWx1ZS5jaGFyQXQoMCkgIT09IFwiJ1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3Ugc2VlbSB0byBiZSB1c2luZyBhIHZhbHVlIGZvciAnY29udGVudCcgd2l0aG91dCBxdW90ZXMsIHRyeSByZXBsYWNpbmcgaXQgd2l0aCBgY29udGVudDogJ1xcXCJcIiArIHZhbHVlICsgXCJcXFwiJ2BcIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByb2Nlc3NlZCA9IG9sZFByb2Nlc3NTdHlsZVZhbHVlJDEoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocHJvY2Vzc2VkICE9PSAnJyAmJiAhaXNDdXN0b21Qcm9wZXJ0eSQxKGtleSkgJiYga2V5LmluZGV4T2YoJy0nKSAhPT0gLTEgJiYgaHlwaGVuYXRlZENhY2hlJDFba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBoeXBoZW5hdGVkQ2FjaGUkMVtrZXldID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVc2luZyBrZWJhYi1jYXNlIGZvciBjc3MgcHJvcGVydGllcyBpbiBvYmplY3RzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiBcIiArIGtleS5yZXBsYWNlKG1zUGF0dGVybiQxLCAnbXMtJykucmVwbGFjZShoeXBoZW5QYXR0ZXJuJDEsIGZ1bmN0aW9uIChzdHIsIF9jaGFyKSB7XG4gICAgICAgIHJldHVybiBfY2hhci50b1VwcGVyQ2FzZSgpO1xuICAgICAgfSkgKyBcIj9cIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgfTtcbn1cblxudmFyIG5vQ29tcG9uZW50U2VsZWN0b3JNZXNzYWdlJDEgPSAnQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggJyArICdAZW1vdGlvbi9iYWJlbC1wbHVnaW4sIHRoZSBzd2MgRW1vdGlvbiBwbHVnaW4sIG9yIGFub3RoZXIgRW1vdGlvbi1hd2FyZSAnICsgJ2NvbXBpbGVyIHRyYW5zZm9ybS4nO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnBvbGF0aW9uJDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pIHtcbiAgaWYgKGludGVycG9sYXRpb24gPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChpbnRlcnBvbGF0aW9uLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24udG9TdHJpbmcoKSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSQxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZW9mIGludGVycG9sYXRpb24pIHtcbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHtcbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uYW5pbSA9PT0gMSkge1xuICAgICAgICAgIGN1cnNvciQxID0ge1xuICAgICAgICAgICAgbmFtZTogaW50ZXJwb2xhdGlvbi5uYW1lLFxuICAgICAgICAgICAgc3R5bGVzOiBpbnRlcnBvbGF0aW9uLnN0eWxlcyxcbiAgICAgICAgICAgIG5leHQ6IGN1cnNvciQxXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGlvbi5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGludGVycG9sYXRpb24uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2YXIgbmV4dCA9IGludGVycG9sYXRpb24ubmV4dDtcblxuICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIG5vdCB0aGUgbW9zdCBlZmZpY2llbnQgdGhpbmcgZXZlciBidXQgdGhpcyBpcyBhIHByZXR0eSByYXJlIGNhc2VcbiAgICAgICAgICAgIC8vIGFuZCB0aGVyZSB3aWxsIGJlIHZlcnkgZmV3IGl0ZXJhdGlvbnMgb2YgdGhpcyBnZW5lcmFsbHlcbiAgICAgICAgICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY3Vyc29yJDEgPSB7XG4gICAgICAgICAgICAgICAgbmFtZTogbmV4dC5uYW1lLFxuICAgICAgICAgICAgICAgIHN0eWxlczogbmV4dC5zdHlsZXMsXG4gICAgICAgICAgICAgICAgbmV4dDogY3Vyc29yJDFcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVzID0gaW50ZXJwb2xhdGlvbi5zdHlsZXMgKyBcIjtcIjtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QkMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgaW50ZXJwb2xhdGlvbik7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIGlmIChtZXJnZWRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ3Vyc29yID0gY3Vyc29yJDE7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGludGVycG9sYXRpb24obWVyZ2VkUHJvcHMpO1xuICAgICAgICAgIGN1cnNvciQxID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgcmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcignRnVuY3Rpb25zIHRoYXQgYXJlIGludGVycG9sYXRlZCBpbiBjc3MgY2FsbHMgd2lsbCBiZSBzdHJpbmdpZmllZC5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIGhhdmUgYSBjc3MgY2FsbCBiYXNlZCBvbiBwcm9wcywgY3JlYXRlIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgY3NzIGNhbGwgbGlrZSB0aGlzXFxuJyArICdsZXQgZHluYW1pY1N0eWxlID0gKHByb3BzKSA9PiBjc3NgY29sb3I6ICR7cHJvcHMuY29sb3J9YFxcbicgKyAnSXQgY2FuIGJlIGNhbGxlZCBkaXJlY3RseSB3aXRoIHByb3BzIG9yIGludGVycG9sYXRlZCBpbiBhIHN0eWxlZCBjYWxsIGxpa2UgdGhpc1xcbicgKyBcImxldCBTb21lQ29tcG9uZW50ID0gc3R5bGVkKCdkaXYnKWAke2R5bmFtaWNTdHlsZX1gXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBbXTtcbiAgICAgICAgdmFyIHJlcGxhY2VkID0gaW50ZXJwb2xhdGlvbi5yZXBsYWNlKGFuaW1hdGlvblJlZ2V4JDEsIGZ1bmN0aW9uIChtYXRjaCwgcDEsIHAyKSB7XG4gICAgICAgICAgdmFyIGZha2VWYXJOYW1lID0gXCJhbmltYXRpb25cIiArIG1hdGNoZWQubGVuZ3RoO1xuICAgICAgICAgIG1hdGNoZWQucHVzaChcImNvbnN0IFwiICsgZmFrZVZhck5hbWUgKyBcIiA9IGtleWZyYW1lc2BcIiArIHAyLnJlcGxhY2UoL15Aa2V5ZnJhbWVzIGFuaW1hdGlvbi1cXHcrLywgJycpICsgXCJgXCIpO1xuICAgICAgICAgIHJldHVybiBcIiR7XCIgKyBmYWtlVmFyTmFtZSArIFwifVwiO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWF0Y2hlZC5sZW5ndGgpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdga2V5ZnJhbWVzYCBvdXRwdXQgZ290IGludGVycG9sYXRlZCBpbnRvIHBsYWluIHN0cmluZywgcGxlYXNlIHdyYXAgaXQgd2l0aCBgY3NzYC5cXG5cXG4nICsgJ0luc3RlYWQgb2YgZG9pbmcgdGhpczpcXG5cXG4nICsgW10uY29uY2F0KG1hdGNoZWQsIFtcImBcIiArIHJlcGxhY2VkICsgXCJgXCJdKS5qb2luKCdcXG4nKSArICdcXG5cXG5Zb3Ugc2hvdWxkIHdyYXAgaXQgd2l0aCBgY3NzYCBsaWtlIHRoaXM6XFxuXFxuJyArIChcImNzc2BcIiArIHJlcGxhY2VkICsgXCJgXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfSAvLyBmaW5hbGl6ZSBzdHJpbmcgdmFsdWVzIChyZWd1bGFyIHN0cmluZ3MgYW5kIGZ1bmN0aW9ucyBpbnRlcnBvbGF0ZWQgaW50byBjc3MgY2FsbHMpXG5cblxuICBpZiAocmVnaXN0ZXJlZCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRpb247XG4gIH1cblxuICB2YXIgY2FjaGVkID0gcmVnaXN0ZXJlZFtpbnRlcnBvbGF0aW9uXTtcbiAgcmV0dXJuIGNhY2hlZCAhPT0gdW5kZWZpbmVkID8gY2FjaGVkIDogaW50ZXJwb2xhdGlvbjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nRnJvbU9iamVjdCQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmopIHtcbiAgdmFyIHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyaW5nICs9IGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgb2JqW2ldKSArIFwiO1wiO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfa2V5IGluIG9iaikge1xuICAgICAgdmFyIHZhbHVlID0gb2JqW19rZXldO1xuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZCAhPSBudWxsICYmIHJlZ2lzdGVyZWRbdmFsdWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgcmVnaXN0ZXJlZFt2YWx1ZV0gKyBcIn1cIjtcbiAgICAgICAgfSBlbHNlIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUkMSh2YWx1ZSkpIHtcbiAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZSQxKF9rZXksIHZhbHVlKSArIFwiO1wiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoX2tleSA9PT0gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUicgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSQxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWVbMF0gPT09ICdzdHJpbmcnICYmIChyZWdpc3RlcmVkID09IG51bGwgfHwgcmVnaXN0ZXJlZFt2YWx1ZVswXV0gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdmFsdWUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzYWJsZVZhbHVlJDEodmFsdWVbX2ldKSkge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZSQxKF9rZXksIHZhbHVlW19pXSkgKyBcIjtcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGludGVycG9sYXRlZCA9IGhhbmRsZUludGVycG9sYXRpb24kMShtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgdmFsdWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChfa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZSQxKF9rZXkpICsgXCI6XCIgKyBpbnRlcnBvbGF0ZWQgKyBcIjtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2tleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoVU5ERUZJTkVEX0FTX09CSkVDVF9LRVlfRVJST1IkMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIGludGVycG9sYXRlZCArIFwifVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cmluZztcbn1cblxudmFyIGxhYmVsUGF0dGVybiQxID0gL2xhYmVsOlxccyooW15cXHM7XFxue10rKVxccyooO3wkKS9nO1xudmFyIHNvdXJjZU1hcFBhdHRlcm4kMTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgc291cmNlTWFwUGF0dGVybiQxID0gL1xcL1xcKiNcXHNzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb25cXC9qc29uO1xcUytcXHMrXFwqXFwvL2c7XG59IC8vIHRoaXMgaXMgdGhlIGN1cnNvciBmb3Iga2V5ZnJhbWVzXG4vLyBrZXlmcmFtZXMgYXJlIHN0b3JlZCBvbiB0aGUgU2VyaWFsaXplZFN0eWxlcyBvYmplY3QgYXMgYSBsaW5rZWQgbGlzdFxuXG5cbnZhciBjdXJzb3IkMTtcbnZhciBzZXJpYWxpemVTdHlsZXMkMSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZVN0eWxlcyhhcmdzLCByZWdpc3RlcmVkLCBtZXJnZWRQcm9wcykge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGFyZ3NbMF0gPT09ICdvYmplY3QnICYmIGFyZ3NbMF0gIT09IG51bGwgJiYgYXJnc1swXS5zdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBhcmdzWzBdO1xuICB9XG5cbiAgdmFyIHN0cmluZ01vZGUgPSB0cnVlO1xuICB2YXIgc3R5bGVzID0gJyc7XG4gIGN1cnNvciQxID0gdW5kZWZpbmVkO1xuICB2YXIgc3RyaW5ncyA9IGFyZ3NbMF07XG5cbiAgaWYgKHN0cmluZ3MgPT0gbnVsbCB8fCBzdHJpbmdzLnJhdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaW5nTW9kZSA9IGZhbHNlO1xuICAgIHN0eWxlcyArPSBoYW5kbGVJbnRlcnBvbGF0aW9uJDEobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHN0cmluZ3MpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0cmluZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyKTtcbiAgICB9XG5cbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbiQxKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBhcmdzW2ldKTtcblxuICAgIGlmIChzdHJpbmdNb2RlKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdHJpbmdzW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQyKTtcbiAgICAgIH1cblxuICAgICAgc3R5bGVzICs9IHN0cmluZ3NbaV07XG4gICAgfVxuICB9XG5cbiAgdmFyIHNvdXJjZU1hcDtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHN0eWxlcyA9IHN0eWxlcy5yZXBsYWNlKHNvdXJjZU1hcFBhdHRlcm4kMSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICBzb3VyY2VNYXAgPSBtYXRjaDtcbiAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgfSAvLyB1c2luZyBhIGdsb2JhbCByZWdleCB3aXRoIC5leGVjIGlzIHN0YXRlZnVsIHNvIGxhc3RJbmRleCBoYXMgdG8gYmUgcmVzZXQgZWFjaCB0aW1lXG5cblxuICBsYWJlbFBhdHRlcm4kMS5sYXN0SW5kZXggPSAwO1xuICB2YXIgaWRlbnRpZmllck5hbWUgPSAnJztcbiAgdmFyIG1hdGNoOyAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViODA5YzJjZjI5NDk4MDBhMGY2MWZiNVxuXG4gIHdoaWxlICgobWF0Y2ggPSBsYWJlbFBhdHRlcm4kMS5leGVjKHN0eWxlcykpICE9PSBudWxsKSB7XG4gICAgaWRlbnRpZmllck5hbWUgKz0gJy0nICsgLy8gJEZsb3dGaXhNZSB3ZSBrbm93IGl0J3Mgbm90IG51bGxcbiAgICBtYXRjaFsxXTtcbiAgfVxuXG4gIHZhciBuYW1lID0gbXVybXVyMiQxKHN0eWxlcykgKyBpZGVudGlmaWVyTmFtZTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vICRGbG93Rml4TWUgU2VyaWFsaXplZFN0eWxlcyB0eXBlIGRvZXNuJ3QgaGF2ZSB0b1N0cmluZyBwcm9wZXJ0eSAoYW5kIHdlIGRvbid0IHdhbnQgdG8gYWRkIGl0KVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgc3R5bGVzOiBzdHlsZXMsXG4gICAgICBtYXA6IHNvdXJjZU1hcCxcbiAgICAgIG5leHQ6IGN1cnNvciQxLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgaGF2ZSB0cmllZCB0byBzdHJpbmdpZnkgb2JqZWN0IHJldHVybmVkIGZyb20gYGNzc2AgZnVuY3Rpb24uIEl0IGlzbid0IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkgKGUuZy4gYXMgdmFsdWUgb2YgdGhlIGBjbGFzc05hbWVgIHByb3ApLCBidXQgcmF0aGVyIGhhbmRlZCB0byBlbW90aW9uIHNvIGl0IGNhbiBoYW5kbGUgaXQgKGUuZy4gYXMgdmFsdWUgb2YgYGNzc2AgcHJvcCkuXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICBuZXh0OiBjdXJzb3IkMVxuICB9O1xufTtcblxudmFyIGlzQnJvd3NlciQzID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxudmFyIHN5bmNGYWxsYmFjayA9IGZ1bmN0aW9uIHN5bmNGYWxsYmFjayhjcmVhdGUpIHtcbiAgcmV0dXJuIGNyZWF0ZSgpO1xufTtcblxudmFyIHVzZUluc2VydGlvbkVmZmVjdCA9IFJlYWN0Wyd1c2VJbnNlcnRpb24nICsgJ0VmZmVjdCddID8gUmVhY3RbJ3VzZUluc2VydGlvbicgKyAnRWZmZWN0J10gOiBmYWxzZTtcbnZhciB1c2VJbnNlcnRpb25FZmZlY3RBbHdheXNXaXRoU3luY0ZhbGxiYWNrID0gIWlzQnJvd3NlciQzID8gc3luY0ZhbGxiYWNrIDogdXNlSW5zZXJ0aW9uRWZmZWN0IHx8IHN5bmNGYWxsYmFjaztcblxudmFyIGlzQnJvd3NlciQyID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5O1xuXG52YXIgRW1vdGlvbkNhY2hlQ29udGV4dCA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNvbnRleHQoIC8vIHdlJ3JlIGRvaW5nIHRoaXMgdG8gYXZvaWQgcHJlY29uc3RydWN0J3MgZGVhZCBjb2RlIGVsaW1pbmF0aW9uIGluIHRoaXMgb25lIGNhc2Vcbi8vIGJlY2F1c2UgdGhpcyBtb2R1bGUgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvciB0aGUgYnJvd3NlciBhbmQgbm9kZVxuLy8gYnV0IGl0J3MgYWxzbyByZXF1aXJlZCBpbiByZWFjdCBuYXRpdmUgYW5kIHNpbWlsYXIgZW52aXJvbm1lbnRzIHNvbWV0aW1lc1xuLy8gYW5kIHdlIGNvdWxkIGhhdmUgYSBzcGVjaWFsIGJ1aWxkIGp1c3QgZm9yIHRoYXRcbi8vIGJ1dCB0aGlzIGlzIG11Y2ggZWFzaWVyIGFuZCB0aGUgbmF0aXZlIHBhY2thZ2VzXG4vLyBtaWdodCB1c2UgYSBkaWZmZXJlbnQgdGhlbWUgY29udGV4dCBpbiB0aGUgZnV0dXJlIGFueXdheVxudHlwZW9mIEhUTUxFbGVtZW50ICE9PSAndW5kZWZpbmVkJyA/IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNhY2hlKHtcbiAga2V5OiAnY3NzJ1xufSkgOiBudWxsKTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgRW1vdGlvbkNhY2hlQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdFbW90aW9uQ2FjaGVDb250ZXh0Jztcbn1cblxuRW1vdGlvbkNhY2hlQ29udGV4dC5Qcm92aWRlcjtcblxudmFyIHdpdGhFbW90aW9uQ2FjaGUgPSBmdW5jdGlvbiB3aXRoRW1vdGlvbkNhY2hlKGZ1bmMpIHtcbiAgLy8gJEZsb3dGaXhNZVxuICByZXR1cm4gLyojX19QVVJFX18qL2ZvcndhcmRSZWYoZnVuY3Rpb24gKHByb3BzLCByZWYpIHtcbiAgICAvLyB0aGUgY2FjaGUgd2lsbCBuZXZlciBiZSBudWxsIGluIHRoZSBicm93c2VyXG4gICAgdmFyIGNhY2hlID0gdXNlQ29udGV4dChFbW90aW9uQ2FjaGVDb250ZXh0KTtcbiAgICByZXR1cm4gZnVuYyhwcm9wcywgY2FjaGUsIHJlZik7XG4gIH0pO1xufTtcblxuaWYgKCFpc0Jyb3dzZXIkMikge1xuICB3aXRoRW1vdGlvbkNhY2hlID0gZnVuY3Rpb24gd2l0aEVtb3Rpb25DYWNoZShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgdmFyIGNhY2hlID0gdXNlQ29udGV4dChFbW90aW9uQ2FjaGVDb250ZXh0KTtcblxuICAgICAgaWYgKGNhY2hlID09PSBudWxsKSB7XG4gICAgICAgIC8vIHllcywgd2UncmUgcG90ZW50aWFsbHkgY3JlYXRpbmcgdGhpcyBvbiBldmVyeSByZW5kZXJcbiAgICAgICAgLy8gaXQgZG9lc24ndCBhY3R1YWxseSBtYXR0ZXIgdGhvdWdoIHNpbmNlIGl0J3Mgb25seSBvbiB0aGUgc2VydmVyXG4gICAgICAgIC8vIHNvIHRoZXJlIHdpbGwgb25seSBldmVyeSBiZSBhIHNpbmdsZSByZW5kZXJcbiAgICAgICAgLy8gdGhhdCBjb3VsZCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSBiZWNhdXNlIG9mIHN1c3BlbnNlIGFuZCBldGMuIGJ1dCBmb3Igbm93LFxuICAgICAgICAvLyB0aGlzIHdvcmtzIGFuZCBpIGRvbid0IHdhbnQgdG8gb3B0aW1pc2UgZm9yIGEgZnV0dXJlIHRoaW5nIHRoYXQgd2UgYXJlbid0IHN1cmUgYWJvdXRcbiAgICAgICAgY2FjaGUgPSBjcmVhdGVDYWNoZSh7XG4gICAgICAgICAga2V5OiAnY3NzJ1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEVtb3Rpb25DYWNoZUNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICAgICAgICB2YWx1ZTogY2FjaGVcbiAgICAgICAgfSwgZnVuYyhwcm9wcywgY2FjaGUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jKHByb3BzLCBjYWNoZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbn1cblxudmFyIFRoZW1lQ29udGV4dCA9IC8qICNfX1BVUkVfXyAqL2NyZWF0ZUNvbnRleHQoe30pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUaGVtZUNvbnRleHQuZGlzcGxheU5hbWUgPSAnRW1vdGlvblRoZW1lQ29udGV4dCc7XG59XG5cbnZhciB0eXBlUHJvcE5hbWUgPSAnX19FTU9USU9OX1RZUEVfUExFQVNFX0RPX05PVF9VU0VfXyc7XG52YXIgbGFiZWxQcm9wTmFtZSA9ICdfX0VNT1RJT05fTEFCRUxfUExFQVNFX0RPX05PVF9VU0VfXyc7XG5cbnZhciBJbnNlcnRpb24kMSA9IGZ1bmN0aW9uIEluc2VydGlvbihfcmVmKSB7XG4gIHZhciBjYWNoZSA9IF9yZWYuY2FjaGUsXG4gICAgICBzZXJpYWxpemVkID0gX3JlZi5zZXJpYWxpemVkLFxuICAgICAgaXNTdHJpbmdUYWcgPSBfcmVmLmlzU3RyaW5nVGFnO1xuICByZWdpc3RlclN0eWxlcyQxKGNhY2hlLCBzZXJpYWxpemVkLCBpc1N0cmluZ1RhZyk7XG4gIHZhciBydWxlcyA9IHVzZUluc2VydGlvbkVmZmVjdEFsd2F5c1dpdGhTeW5jRmFsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbnNlcnRTdHlsZXMkMShjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB9KTtcblxuICBpZiAoIWlzQnJvd3NlciQyICYmIHJ1bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgX3JlZjI7XG5cbiAgICB2YXIgc2VyaWFsaXplZE5hbWVzID0gc2VyaWFsaXplZC5uYW1lO1xuICAgIHZhciBuZXh0ID0gc2VyaWFsaXplZC5uZXh0O1xuXG4gICAgd2hpbGUgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc2VyaWFsaXplZE5hbWVzICs9ICcgJyArIG5leHQubmFtZTtcbiAgICAgIG5leHQgPSBuZXh0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KFwic3R5bGVcIiwgKF9yZWYyID0ge30sIF9yZWYyW1wiZGF0YS1lbW90aW9uXCJdID0gY2FjaGUua2V5ICsgXCIgXCIgKyBzZXJpYWxpemVkTmFtZXMsIF9yZWYyLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID0ge1xuICAgICAgX19odG1sOiBydWxlc1xuICAgIH0sIF9yZWYyLm5vbmNlID0gY2FjaGUuc2hlZXQubm9uY2UsIF9yZWYyKSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbnZhciBFbW90aW9uID0gLyogI19fUFVSRV9fICovd2l0aEVtb3Rpb25DYWNoZShmdW5jdGlvbiAocHJvcHMsIGNhY2hlLCByZWYpIHtcbiAgdmFyIGNzc1Byb3AgPSBwcm9wcy5jc3M7IC8vIHNvIHRoYXQgdXNpbmcgYGNzc2AgZnJvbSBgZW1vdGlvbmAgYW5kIHBhc3NpbmcgdGhlIHJlc3VsdCB0byB0aGUgY3NzIHByb3Agd29ya3NcbiAgLy8gbm90IHBhc3NpbmcgdGhlIHJlZ2lzdGVyZWQgY2FjaGUgdG8gc2VyaWFsaXplU3R5bGVzIGJlY2F1c2UgaXQgd291bGRcbiAgLy8gbWFrZSBjZXJ0YWluIGJhYmVsIG9wdGltaXNhdGlvbnMgbm90IHBvc3NpYmxlXG5cbiAgaWYgKHR5cGVvZiBjc3NQcm9wID09PSAnc3RyaW5nJyAmJiBjYWNoZS5yZWdpc3RlcmVkW2Nzc1Byb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBjc3NQcm9wID0gY2FjaGUucmVnaXN0ZXJlZFtjc3NQcm9wXTtcbiAgfVxuXG4gIHZhciBXcmFwcGVkQ29tcG9uZW50ID0gcHJvcHNbdHlwZVByb3BOYW1lXTtcbiAgdmFyIHJlZ2lzdGVyZWRTdHlsZXMgPSBbY3NzUHJvcF07XG4gIHZhciBjbGFzc05hbWUgPSAnJztcblxuICBpZiAodHlwZW9mIHByb3BzLmNsYXNzTmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICBjbGFzc05hbWUgPSBnZXRSZWdpc3RlcmVkU3R5bGVzJDEoY2FjaGUucmVnaXN0ZXJlZCwgcmVnaXN0ZXJlZFN0eWxlcywgcHJvcHMuY2xhc3NOYW1lKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5jbGFzc05hbWUgIT0gbnVsbCkge1xuICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArIFwiIFwiO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWQgPSBzZXJpYWxpemVTdHlsZXMkMShyZWdpc3RlcmVkU3R5bGVzLCB1bmRlZmluZWQsIHVzZUNvbnRleHQoVGhlbWVDb250ZXh0KSk7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2VyaWFsaXplZC5uYW1lLmluZGV4T2YoJy0nKSA9PT0gLTEpIHtcbiAgICB2YXIgbGFiZWxGcm9tU3RhY2sgPSBwcm9wc1tsYWJlbFByb3BOYW1lXTtcblxuICAgIGlmIChsYWJlbEZyb21TdGFjaykge1xuICAgICAgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyQxKFtzZXJpYWxpemVkLCAnbGFiZWw6JyArIGxhYmVsRnJvbVN0YWNrICsgJzsnXSk7XG4gICAgfVxuICB9XG5cbiAgY2xhc3NOYW1lICs9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChwcm9wcywga2V5KSAmJiBrZXkgIT09ICdjc3MnICYmIGtleSAhPT0gdHlwZVByb3BOYW1lICYmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nIHx8IGtleSAhPT0gbGFiZWxQcm9wTmFtZSkpIHtcbiAgICAgIG5ld1Byb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIG5ld1Byb3BzLnJlZiA9IHJlZjtcbiAgbmV3UHJvcHMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICByZXR1cm4gLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9jcmVhdGVFbGVtZW50KEluc2VydGlvbiQxLCB7XG4gICAgY2FjaGU6IGNhY2hlLFxuICAgIHNlcmlhbGl6ZWQ6IHNlcmlhbGl6ZWQsXG4gICAgaXNTdHJpbmdUYWc6IHR5cGVvZiBXcmFwcGVkQ29tcG9uZW50ID09PSAnc3RyaW5nJ1xuICB9KSwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoV3JhcHBlZENvbXBvbmVudCwgbmV3UHJvcHMpKTtcbn0pO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBFbW90aW9uLmRpc3BsYXlOYW1lID0gJ0Vtb3Rpb25Dc3NQcm9wSW50ZXJuYWwnO1xufVxuXG52YXIgaXNCcm93c2VyJDEgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnO1xuZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZFN0eWxlcyhyZWdpc3RlcmVkLCByZWdpc3RlcmVkU3R5bGVzLCBjbGFzc05hbWVzKSB7XG4gIHZhciByYXdDbGFzc05hbWUgPSAnJztcbiAgY2xhc3NOYW1lcy5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIGlmIChyZWdpc3RlcmVkW2NsYXNzTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKHJlZ2lzdGVyZWRbY2xhc3NOYW1lXSArIFwiO1wiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmF3Q2xhc3NOYW1lICs9IGNsYXNzTmFtZSArIFwiIFwiO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByYXdDbGFzc05hbWU7XG59XG52YXIgcmVnaXN0ZXJTdHlsZXMgPSBmdW5jdGlvbiByZWdpc3RlclN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmICggLy8gd2Ugb25seSBuZWVkIHRvIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSByZWdpc3RlcmVkIGNhY2hlIGlmIHRoZVxuICAvLyBjbGFzcyBuYW1lIGNvdWxkIGJlIHVzZWQgZnVydGhlciBkb3duXG4gIC8vIHRoZSB0cmVlIGJ1dCBpZiBpdCdzIGEgc3RyaW5nIHRhZywgd2Uga25vdyBpdCB3b24ndFxuICAvLyBzbyB3ZSBkb24ndCBoYXZlIHRvIGFkZCBpdCB0byByZWdpc3RlcmVkIGNhY2hlLlxuICAvLyB0aGlzIGltcHJvdmVzIG1lbW9yeSB1c2FnZSBzaW5jZSB3ZSBjYW4gYXZvaWQgc3RvcmluZyB0aGUgd2hvbGUgc3R5bGUgc3RyaW5nXG4gIChpc1N0cmluZ1RhZyA9PT0gZmFsc2UgfHwgLy8gd2UgbmVlZCB0byBhbHdheXMgc3RvcmUgaXQgaWYgd2UncmUgaW4gY29tcGF0IG1vZGUgYW5kXG4gIC8vIGluIG5vZGUgc2luY2UgZW1vdGlvbi1zZXJ2ZXIgcmVsaWVzIG9uIHdoZXRoZXIgYSBzdHlsZSBpcyBpblxuICAvLyB0aGUgcmVnaXN0ZXJlZCBjYWNoZSB0byBrbm93IHdoZXRoZXIgYSBzdHlsZSBpcyBnbG9iYWwgb3Igbm90XG4gIC8vIGFsc28sIG5vdGUgdGhhdCB0aGlzIGNoZWNrIHdpbGwgYmUgZGVhZCBjb2RlIGVsaW1pbmF0ZWQgaW4gdGhlIGJyb3dzZXJcbiAgaXNCcm93c2VyJDEgPT09IGZhbHNlICYmIGNhY2hlLmNvbXBhdCAhPT0gdW5kZWZpbmVkKSAmJiBjYWNoZS5yZWdpc3RlcmVkW2NsYXNzTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlLnJlZ2lzdGVyZWRbY2xhc3NOYW1lXSA9IHNlcmlhbGl6ZWQuc3R5bGVzO1xuICB9XG59O1xudmFyIGluc2VydFN0eWxlcyA9IGZ1bmN0aW9uIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpIHtcbiAgcmVnaXN0ZXJTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIGNsYXNzTmFtZSA9IGNhY2hlLmtleSArIFwiLVwiICsgc2VyaWFsaXplZC5uYW1lO1xuXG4gIGlmIChjYWNoZS5pbnNlcnRlZFtzZXJpYWxpemVkLm5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc3R5bGVzRm9yU1NSID0gJyc7XG4gICAgdmFyIGN1cnJlbnQgPSBzZXJpYWxpemVkO1xuXG4gICAgZG8ge1xuICAgICAgdmFyIG1heWJlU3R5bGVzID0gY2FjaGUuaW5zZXJ0KHNlcmlhbGl6ZWQgPT09IGN1cnJlbnQgPyBcIi5cIiArIGNsYXNzTmFtZSA6ICcnLCBjdXJyZW50LCBjYWNoZS5zaGVldCwgdHJ1ZSk7XG5cbiAgICAgIGlmICghaXNCcm93c2VyJDEgJiYgbWF5YmVTdHlsZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzdHlsZXNGb3JTU1IgKz0gbWF5YmVTdHlsZXM7XG4gICAgICB9XG5cbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgfSB3aGlsZSAoY3VycmVudCAhPT0gdW5kZWZpbmVkKTtcblxuICAgIGlmICghaXNCcm93c2VyJDEgJiYgc3R5bGVzRm9yU1NSLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIHN0eWxlc0ZvclNTUjtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlICovXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZ2FyeWNvdXJ0L211cm11cmhhc2gtanNcbi8vIFBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9hYXBwbGVieS9zbWhhc2hlci9ibG9iLzYxYTA1MzBmMjgyNzdmMmU4NTBiZmMzOTYwMGNlNjFkMDJiNTE4ZGUvc3JjL011cm11ckhhc2gyLmNwcCNMMzctTDg2XG5mdW5jdGlvbiBtdXJtdXIyKHN0cikge1xuICAvLyAnbScgYW5kICdyJyBhcmUgbWl4aW5nIGNvbnN0YW50cyBnZW5lcmF0ZWQgb2ZmbGluZS5cbiAgLy8gVGhleSdyZSBub3QgcmVhbGx5ICdtYWdpYycsIHRoZXkganVzdCBoYXBwZW4gdG8gd29yayB3ZWxsLlxuICAvLyBjb25zdCBtID0gMHg1YmQxZTk5NTtcbiAgLy8gY29uc3QgciA9IDI0O1xuICAvLyBJbml0aWFsaXplIHRoZSBoYXNoXG4gIHZhciBoID0gMDsgLy8gTWl4IDQgYnl0ZXMgYXQgYSB0aW1lIGludG8gdGhlIGhhc2hcblxuICB2YXIgayxcbiAgICAgIGkgPSAwLFxuICAgICAgbGVuID0gc3RyLmxlbmd0aDtcblxuICBmb3IgKDsgbGVuID49IDQ7ICsraSwgbGVuIC09IDQpIHtcbiAgICBrID0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCA4IHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweGZmKSA8PCAxNiB8IChzdHIuY2hhckNvZGVBdCgrK2kpICYgMHhmZikgPDwgMjQ7XG4gICAgayA9XG4gICAgLyogTWF0aC5pbXVsKGssIG0pOiAqL1xuICAgIChrICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGsgPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNik7XG4gICAgayBePVxuICAgIC8qIGsgPj4+IHI6ICovXG4gICAgayA+Pj4gMjQ7XG4gICAgaCA9XG4gICAgLyogTWF0aC5pbXVsKGssIG0pOiAqL1xuICAgIChrICYgMHhmZmZmKSAqIDB4NWJkMWU5OTUgKyAoKGsgPj4+IDE2KSAqIDB4ZTk5NSA8PCAxNikgXlxuICAgIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICB9IC8vIEhhbmRsZSB0aGUgbGFzdCBmZXcgYnl0ZXMgb2YgdGhlIGlucHV0IGFycmF5XG5cblxuICBzd2l0Y2ggKGxlbikge1xuICAgIGNhc2UgMzpcbiAgICAgIGggXj0gKHN0ci5jaGFyQ29kZUF0KGkgKyAyKSAmIDB4ZmYpIDw8IDE2O1xuXG4gICAgY2FzZSAyOlxuICAgICAgaCBePSAoc3RyLmNoYXJDb2RlQXQoaSArIDEpICYgMHhmZikgPDwgODtcblxuICAgIGNhc2UgMTpcbiAgICAgIGggXj0gc3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmO1xuICAgICAgaCA9XG4gICAgICAvKiBNYXRoLmltdWwoaCwgbSk6ICovXG4gICAgICAoaCAmIDB4ZmZmZikgKiAweDViZDFlOTk1ICsgKChoID4+PiAxNikgKiAweGU5OTUgPDwgMTYpO1xuICB9IC8vIERvIGEgZmV3IGZpbmFsIG1peGVzIG9mIHRoZSBoYXNoIHRvIGVuc3VyZSB0aGUgbGFzdCBmZXdcbiAgLy8gYnl0ZXMgYXJlIHdlbGwtaW5jb3Jwb3JhdGVkLlxuXG5cbiAgaCBePSBoID4+PiAxMztcbiAgaCA9XG4gIC8qIE1hdGguaW11bChoLCBtKTogKi9cbiAgKGggJiAweGZmZmYpICogMHg1YmQxZTk5NSArICgoaCA+Pj4gMTYpICogMHhlOTk1IDw8IDE2KTtcbiAgcmV0dXJuICgoaCBeIGggPj4+IDE1KSA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuXG52YXIgdW5pdGxlc3NLZXlzID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogMSxcbiAgYm9yZGVySW1hZ2VPdXRzZXQ6IDEsXG4gIGJvcmRlckltYWdlU2xpY2U6IDEsXG4gIGJvcmRlckltYWdlV2lkdGg6IDEsXG4gIGJveEZsZXg6IDEsXG4gIGJveEZsZXhHcm91cDogMSxcbiAgYm94T3JkaW5hbEdyb3VwOiAxLFxuICBjb2x1bW5Db3VudDogMSxcbiAgY29sdW1uczogMSxcbiAgZmxleDogMSxcbiAgZmxleEdyb3c6IDEsXG4gIGZsZXhQb3NpdGl2ZTogMSxcbiAgZmxleFNocmluazogMSxcbiAgZmxleE5lZ2F0aXZlOiAxLFxuICBmbGV4T3JkZXI6IDEsXG4gIGdyaWRSb3c6IDEsXG4gIGdyaWRSb3dFbmQ6IDEsXG4gIGdyaWRSb3dTcGFuOiAxLFxuICBncmlkUm93U3RhcnQ6IDEsXG4gIGdyaWRDb2x1bW46IDEsXG4gIGdyaWRDb2x1bW5FbmQ6IDEsXG4gIGdyaWRDb2x1bW5TcGFuOiAxLFxuICBncmlkQ29sdW1uU3RhcnQ6IDEsXG4gIG1zR3JpZFJvdzogMSxcbiAgbXNHcmlkUm93U3BhbjogMSxcbiAgbXNHcmlkQ29sdW1uOiAxLFxuICBtc0dyaWRDb2x1bW5TcGFuOiAxLFxuICBmb250V2VpZ2h0OiAxLFxuICBsaW5lSGVpZ2h0OiAxLFxuICBvcGFjaXR5OiAxLFxuICBvcmRlcjogMSxcbiAgb3JwaGFuczogMSxcbiAgdGFiU2l6ZTogMSxcbiAgd2lkb3dzOiAxLFxuICB6SW5kZXg6IDEsXG4gIHpvb206IDEsXG4gIFdlYmtpdExpbmVDbGFtcDogMSxcbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogMSxcbiAgZmxvb2RPcGFjaXR5OiAxLFxuICBzdG9wT3BhY2l0eTogMSxcbiAgc3Ryb2tlRGFzaGFycmF5OiAxLFxuICBzdHJva2VEYXNob2Zmc2V0OiAxLFxuICBzdHJva2VNaXRlcmxpbWl0OiAxLFxuICBzdHJva2VPcGFjaXR5OiAxLFxuICBzdHJva2VXaWR0aDogMVxufTtcblxudmFyIElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDEgPSBcIllvdSBoYXZlIGlsbGVnYWwgZXNjYXBlIHNlcXVlbmNlIGluIHlvdXIgdGVtcGxhdGUgbGl0ZXJhbCwgbW9zdCBsaWtlbHkgaW5zaWRlIGNvbnRlbnQncyBwcm9wZXJ0eSB2YWx1ZS5cXG5CZWNhdXNlIHlvdSB3cml0ZSB5b3VyIENTUyBpbnNpZGUgYSBKYXZhU2NyaXB0IHN0cmluZyB5b3UgYWN0dWFsbHkgaGF2ZSB0byBkbyBkb3VibGUgZXNjYXBpbmcsIHNvIGZvciBleGFtcGxlIFxcXCJjb250ZW50OiAnXFxcXDAwZDcnO1xcXCIgc2hvdWxkIGJlY29tZSBcXFwiY29udGVudDogJ1xcXFxcXFxcMDBkNyc7XFxcIi5cXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6XFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvVGVtcGxhdGVfbGl0ZXJhbHMjRVMyMDE4X3JldmlzaW9uX29mX2lsbGVnYWxfZXNjYXBlX3NlcXVlbmNlc1wiO1xudmFyIFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SID0gXCJZb3UgaGF2ZSBwYXNzZWQgaW4gZmFsc3kgdmFsdWUgYXMgc3R5bGUgb2JqZWN0J3Mga2V5IChjYW4gaGFwcGVuIHdoZW4gaW4gZXhhbXBsZSB5b3UgcGFzcyB1bmV4cG9ydGVkIGNvbXBvbmVudCBhcyBjb21wdXRlZCBrZXkpLlwiO1xudmFyIGh5cGhlbmF0ZVJlZ2V4ID0gL1tBLVpdfF5tcy9nO1xudmFyIGFuaW1hdGlvblJlZ2V4ID0gL19FTU9fKFteX10rPylfKFteXSo/KV9FTU9fL2c7XG5cbnZhciBpc0N1c3RvbVByb3BlcnR5ID0gZnVuY3Rpb24gaXNDdXN0b21Qcm9wZXJ0eShwcm9wZXJ0eSkge1xuICByZXR1cm4gcHJvcGVydHkuY2hhckNvZGVBdCgxKSA9PT0gNDU7XG59O1xuXG52YXIgaXNQcm9jZXNzYWJsZVZhbHVlID0gZnVuY3Rpb24gaXNQcm9jZXNzYWJsZVZhbHVlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ2Jvb2xlYW4nO1xufTtcblxudmFyIHByb2Nlc3NTdHlsZU5hbWUgPSAvKiAjX19QVVJFX18gKi9tZW1vaXplKGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGlzQ3VzdG9tUHJvcGVydHkoc3R5bGVOYW1lKSA/IHN0eWxlTmFtZSA6IHN0eWxlTmFtZS5yZXBsYWNlKGh5cGhlbmF0ZVJlZ2V4LCAnLSQmJykudG9Mb3dlckNhc2UoKTtcbn0pO1xuXG52YXIgcHJvY2Vzc1N0eWxlVmFsdWUgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSAnYW5pbWF0aW9uJzpcbiAgICBjYXNlICdhbmltYXRpb25OYW1lJzpcbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShhbmltYXRpb25SZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgbmFtZTogcDEsXG4gICAgICAgICAgICAgIHN0eWxlczogcDIsXG4gICAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwMTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgaWYgKHVuaXRsZXNzS2V5c1trZXldICE9PSAxICYmICFpc0N1c3RvbVByb3BlcnR5KGtleSkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCkge1xuICAgIHJldHVybiB2YWx1ZSArICdweCc7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgY29udGVudFZhbHVlUGF0dGVybiA9IC8odmFyfGF0dHJ8Y291bnRlcnM/fHVybHxlbGVtZW50fCgoKHJlcGVhdGluZy0pPyhsaW5lYXJ8cmFkaWFsKSl8Y29uaWMpLWdyYWRpZW50KVxcKHwobm8tKT8ob3BlbnxjbG9zZSktcXVvdGUvO1xuICB2YXIgY29udGVudFZhbHVlcyA9IFsnbm9ybWFsJywgJ25vbmUnLCAnaW5pdGlhbCcsICdpbmhlcml0JywgJ3Vuc2V0J107XG4gIHZhciBvbGRQcm9jZXNzU3R5bGVWYWx1ZSA9IHByb2Nlc3NTdHlsZVZhbHVlO1xuICB2YXIgbXNQYXR0ZXJuID0gL14tbXMtLztcbiAgdmFyIGh5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuICB2YXIgaHlwaGVuYXRlZENhY2hlID0ge307XG5cbiAgcHJvY2Vzc1N0eWxlVmFsdWUgPSBmdW5jdGlvbiBwcm9jZXNzU3R5bGVWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgaWYgKGtleSA9PT0gJ2NvbnRlbnQnKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyB8fCBjb250ZW50VmFsdWVzLmluZGV4T2YodmFsdWUpID09PSAtMSAmJiAhY29udGVudFZhbHVlUGF0dGVybi50ZXN0KHZhbHVlKSAmJiAodmFsdWUuY2hhckF0KDApICE9PSB2YWx1ZS5jaGFyQXQodmFsdWUubGVuZ3RoIC0gMSkgfHwgdmFsdWUuY2hhckF0KDApICE9PSAnXCInICYmIHZhbHVlLmNoYXJBdCgwKSAhPT0gXCInXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBzZWVtIHRvIGJlIHVzaW5nIGEgdmFsdWUgZm9yICdjb250ZW50JyB3aXRob3V0IHF1b3RlcywgdHJ5IHJlcGxhY2luZyBpdCB3aXRoIGBjb250ZW50OiAnXFxcIlwiICsgdmFsdWUgKyBcIlxcXCInYFwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJvY2Vzc2VkID0gb2xkUHJvY2Vzc1N0eWxlVmFsdWUoa2V5LCB2YWx1ZSk7XG5cbiAgICBpZiAocHJvY2Vzc2VkICE9PSAnJyAmJiAhaXNDdXN0b21Qcm9wZXJ0eShrZXkpICYmIGtleS5pbmRleE9mKCctJykgIT09IC0xICYmIGh5cGhlbmF0ZWRDYWNoZVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGh5cGhlbmF0ZWRDYWNoZVtrZXldID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoXCJVc2luZyBrZWJhYi1jYXNlIGZvciBjc3MgcHJvcGVydGllcyBpbiBvYmplY3RzIGlzIG5vdCBzdXBwb3J0ZWQuIERpZCB5b3UgbWVhbiBcIiArIGtleS5yZXBsYWNlKG1zUGF0dGVybiwgJ21zLScpLnJlcGxhY2UoaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKHN0ciwgX2NoYXIpIHtcbiAgICAgICAgcmV0dXJuIF9jaGFyLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KSArIFwiP1wiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICB9O1xufVxuXG52YXIgbm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UgPSAnQ29tcG9uZW50IHNlbGVjdG9ycyBjYW4gb25seSBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggJyArICdAZW1vdGlvbi9iYWJlbC1wbHVnaW4sIHRoZSBzd2MgRW1vdGlvbiBwbHVnaW4sIG9yIGFub3RoZXIgRW1vdGlvbi1hd2FyZSAnICsgJ2NvbXBpbGVyIHRyYW5zZm9ybS4nO1xuXG5mdW5jdGlvbiBoYW5kbGVJbnRlcnBvbGF0aW9uKG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBpbnRlcnBvbGF0aW9uKSB7XG4gIGlmIChpbnRlcnBvbGF0aW9uID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoaW50ZXJwb2xhdGlvbi5fX2Vtb3Rpb25fc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpbnRlcnBvbGF0aW9uLnRvU3RyaW5nKCkgPT09ICdOT19DT01QT05FTlRfU0VMRUNUT1InKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3Iobm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnRlcnBvbGF0aW9uO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlb2YgaW50ZXJwb2xhdGlvbikge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAoaW50ZXJwb2xhdGlvbi5hbmltID09PSAxKSB7XG4gICAgICAgICAgY3Vyc29yID0ge1xuICAgICAgICAgICAgbmFtZTogaW50ZXJwb2xhdGlvbi5uYW1lLFxuICAgICAgICAgICAgc3R5bGVzOiBpbnRlcnBvbGF0aW9uLnN0eWxlcyxcbiAgICAgICAgICAgIG5leHQ6IGN1cnNvclxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGludGVycG9sYXRpb24ubmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnRlcnBvbGF0aW9uLnN0eWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBpbnRlcnBvbGF0aW9uLm5leHQ7XG5cbiAgICAgICAgICBpZiAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBub3QgdGhlIG1vc3QgZWZmaWNpZW50IHRoaW5nIGV2ZXIgYnV0IHRoaXMgaXMgYSBwcmV0dHkgcmFyZSBjYXNlXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUgd2lsbCBiZSB2ZXJ5IGZldyBpdGVyYXRpb25zIG9mIHRoaXMgZ2VuZXJhbGx5XG4gICAgICAgICAgICB3aGlsZSAobmV4dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGN1cnNvciA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBuZXh0Lm5hbWUsXG4gICAgICAgICAgICAgICAgc3R5bGVzOiBuZXh0LnN0eWxlcyxcbiAgICAgICAgICAgICAgICBuZXh0OiBjdXJzb3JcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgbmV4dCA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc3R5bGVzID0gaW50ZXJwb2xhdGlvbi5zdHlsZXMgKyBcIjtcIjtcblxuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGludGVycG9sYXRpb24ubWFwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0eWxlcyArPSBpbnRlcnBvbGF0aW9uLm1hcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ0Zyb21PYmplY3QobWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIGludGVycG9sYXRpb24pO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICBpZiAobWVyZ2VkUHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhciBwcmV2aW91c0N1cnNvciA9IGN1cnNvcjtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gaW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcyk7XG4gICAgICAgICAgY3Vyc29yID0gcHJldmlvdXNDdXJzb3I7XG4gICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Z1bmN0aW9ucyB0aGF0IGFyZSBpbnRlcnBvbGF0ZWQgaW4gY3NzIGNhbGxzIHdpbGwgYmUgc3RyaW5naWZpZWQuXFxuJyArICdJZiB5b3Ugd2FudCB0byBoYXZlIGEgY3NzIGNhbGwgYmFzZWQgb24gcHJvcHMsIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGNzcyBjYWxsIGxpa2UgdGhpc1xcbicgKyAnbGV0IGR5bmFtaWNTdHlsZSA9IChwcm9wcykgPT4gY3NzYGNvbG9yOiAke3Byb3BzLmNvbG9yfWBcXG4nICsgJ0l0IGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgd2l0aCBwcm9wcyBvciBpbnRlcnBvbGF0ZWQgaW4gYSBzdHlsZWQgY2FsbCBsaWtlIHRoaXNcXG4nICsgXCJsZXQgU29tZUNvbXBvbmVudCA9IHN0eWxlZCgnZGl2JylgJHtkeW5hbWljU3R5bGV9YFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHZhciBtYXRjaGVkID0gW107XG4gICAgICAgIHZhciByZXBsYWNlZCA9IGludGVycG9sYXRpb24ucmVwbGFjZShhbmltYXRpb25SZWdleCwgZnVuY3Rpb24gKG1hdGNoLCBwMSwgcDIpIHtcbiAgICAgICAgICB2YXIgZmFrZVZhck5hbWUgPSBcImFuaW1hdGlvblwiICsgbWF0Y2hlZC5sZW5ndGg7XG4gICAgICAgICAgbWF0Y2hlZC5wdXNoKFwiY29uc3QgXCIgKyBmYWtlVmFyTmFtZSArIFwiID0ga2V5ZnJhbWVzYFwiICsgcDIucmVwbGFjZSgvXkBrZXlmcmFtZXMgYW5pbWF0aW9uLVxcdysvLCAnJykgKyBcImBcIik7XG4gICAgICAgICAgcmV0dXJuIFwiJHtcIiArIGZha2VWYXJOYW1lICsgXCJ9XCI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChtYXRjaGVkLmxlbmd0aCkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2BrZXlmcmFtZXNgIG91dHB1dCBnb3QgaW50ZXJwb2xhdGVkIGludG8gcGxhaW4gc3RyaW5nLCBwbGVhc2Ugd3JhcCBpdCB3aXRoIGBjc3NgLlxcblxcbicgKyAnSW5zdGVhZCBvZiBkb2luZyB0aGlzOlxcblxcbicgKyBbXS5jb25jYXQobWF0Y2hlZCwgW1wiYFwiICsgcmVwbGFjZWQgKyBcImBcIl0pLmpvaW4oJ1xcbicpICsgJ1xcblxcbllvdSBzaG91bGQgd3JhcCBpdCB3aXRoIGBjc3NgIGxpa2UgdGhpczpcXG5cXG4nICsgKFwiY3NzYFwiICsgcmVwbGFjZWQgKyBcImBcIikpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9IC8vIGZpbmFsaXplIHN0cmluZyB2YWx1ZXMgKHJlZ3VsYXIgc3RyaW5ncyBhbmQgZnVuY3Rpb25zIGludGVycG9sYXRlZCBpbnRvIGNzcyBjYWxscylcblxuXG4gIGlmIChyZWdpc3RlcmVkID09IG51bGwpIHtcbiAgICByZXR1cm4gaW50ZXJwb2xhdGlvbjtcbiAgfVxuXG4gIHZhciBjYWNoZWQgPSByZWdpc3RlcmVkW2ludGVycG9sYXRpb25dO1xuICByZXR1cm4gY2FjaGVkICE9PSB1bmRlZmluZWQgPyBjYWNoZWQgOiBpbnRlcnBvbGF0aW9uO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHJpbmdGcm9tT2JqZWN0KG1lcmdlZFByb3BzLCByZWdpc3RlcmVkLCBvYmopIHtcbiAgdmFyIHN0cmluZyA9ICcnO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgc3RyaW5nICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIG9ialtpXSkgKyBcIjtcIjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgX2tleSBpbiBvYmopIHtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtfa2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgaWYgKHJlZ2lzdGVyZWQgIT0gbnVsbCAmJiByZWdpc3RlcmVkW3ZhbHVlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc3RyaW5nICs9IF9rZXkgKyBcIntcIiArIHJlZ2lzdGVyZWRbdmFsdWVdICsgXCJ9XCI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNQcm9jZXNzYWJsZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgIHN0cmluZyArPSBwcm9jZXNzU3R5bGVOYW1lKF9rZXkpICsgXCI6XCIgKyBwcm9jZXNzU3R5bGVWYWx1ZShfa2V5LCB2YWx1ZSkgKyBcIjtcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKF9rZXkgPT09ICdOT19DT01QT05FTlRfU0VMRUNUT1InICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iobm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHR5cGVvZiB2YWx1ZVswXSA9PT0gJ3N0cmluZycgJiYgKHJlZ2lzdGVyZWQgPT0gbnVsbCB8fCByZWdpc3RlcmVkW3ZhbHVlWzBdXSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCB2YWx1ZS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGlmIChpc1Byb2Nlc3NhYmxlVmFsdWUodmFsdWVbX2ldKSkge1xuICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZShfa2V5KSArIFwiOlwiICsgcHJvY2Vzc1N0eWxlVmFsdWUoX2tleSwgdmFsdWVbX2ldKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkID0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgdmFsdWUpO1xuXG4gICAgICAgICAgc3dpdGNoIChfa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdhbmltYXRpb24nOlxuICAgICAgICAgICAgY2FzZSAnYW5pbWF0aW9uTmFtZSc6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gcHJvY2Vzc1N0eWxlTmFtZShfa2V5KSArIFwiOlwiICsgaW50ZXJwb2xhdGVkICsgXCI7XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIF9rZXkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gX2tleSArIFwie1wiICsgaW50ZXJwb2xhdGVkICsgXCJ9XCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyaW5nO1xufVxuXG52YXIgbGFiZWxQYXR0ZXJuID0gL2xhYmVsOlxccyooW15cXHM7XFxue10rKVxccyooO3wkKS9nO1xudmFyIHNvdXJjZU1hcFBhdHRlcm47XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHNvdXJjZU1hcFBhdHRlcm4gPSAvXFwvXFwqI1xcc3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvblxcL2pzb247XFxTK1xccytcXCpcXC8vZztcbn0gLy8gdGhpcyBpcyB0aGUgY3Vyc29yIGZvciBrZXlmcmFtZXNcbi8vIGtleWZyYW1lcyBhcmUgc3RvcmVkIG9uIHRoZSBTZXJpYWxpemVkU3R5bGVzIG9iamVjdCBhcyBhIGxpbmtlZCBsaXN0XG5cblxudmFyIGN1cnNvcjtcbnZhciBzZXJpYWxpemVTdHlsZXMgPSBmdW5jdGlvbiBzZXJpYWxpemVTdHlsZXMoYXJncywgcmVnaXN0ZXJlZCwgbWVyZ2VkUHJvcHMpIHtcbiAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBhcmdzWzBdID09PSAnb2JqZWN0JyAmJiBhcmdzWzBdICE9PSBudWxsICYmIGFyZ3NbMF0uc3R5bGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gYXJnc1swXTtcbiAgfVxuXG4gIHZhciBzdHJpbmdNb2RlID0gdHJ1ZTtcbiAgdmFyIHN0eWxlcyA9ICcnO1xuICBjdXJzb3IgPSB1bmRlZmluZWQ7XG4gIHZhciBzdHJpbmdzID0gYXJnc1swXTtcblxuICBpZiAoc3RyaW5ncyA9PSBudWxsIHx8IHN0cmluZ3MucmF3ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpbmdNb2RlID0gZmFsc2U7XG4gICAgc3R5bGVzICs9IGhhbmRsZUludGVycG9sYXRpb24obWVyZ2VkUHJvcHMsIHJlZ2lzdGVyZWQsIHN0cmluZ3MpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHN0cmluZ3NbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc29sZS5lcnJvcihJTExFR0FMX0VTQ0FQRV9TRVFVRU5DRV9FUlJPUiQxKTtcbiAgICB9XG5cbiAgICBzdHlsZXMgKz0gc3RyaW5nc1swXTtcbiAgfSAvLyB3ZSBzdGFydCBhdCAxIHNpbmNlIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgZmlyc3QgYXJnXG5cblxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBzdHlsZXMgKz0gaGFuZGxlSW50ZXJwb2xhdGlvbihtZXJnZWRQcm9wcywgcmVnaXN0ZXJlZCwgYXJnc1tpXSk7XG5cbiAgICBpZiAoc3RyaW5nTW9kZSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc3RyaW5nc1tpXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IkMSk7XG4gICAgICB9XG5cbiAgICAgIHN0eWxlcyArPSBzdHJpbmdzW2ldO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzb3VyY2VNYXA7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBzdHlsZXMgPSBzdHlsZXMucmVwbGFjZShzb3VyY2VNYXBQYXR0ZXJuLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgIHNvdXJjZU1hcCA9IG1hdGNoO1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICB9IC8vIHVzaW5nIGEgZ2xvYmFsIHJlZ2V4IHdpdGggLmV4ZWMgaXMgc3RhdGVmdWwgc28gbGFzdEluZGV4IGhhcyB0byBiZSByZXNldCBlYWNoIHRpbWVcblxuXG4gIGxhYmVsUGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICB2YXIgaWRlbnRpZmllck5hbWUgPSAnJztcbiAgdmFyIG1hdGNoOyAvLyBodHRwczovL2VzYmVuY2guY29tL2JlbmNoLzViODA5YzJjZjI5NDk4MDBhMGY2MWZiNVxuXG4gIHdoaWxlICgobWF0Y2ggPSBsYWJlbFBhdHRlcm4uZXhlYyhzdHlsZXMpKSAhPT0gbnVsbCkge1xuICAgIGlkZW50aWZpZXJOYW1lICs9ICctJyArIC8vICRGbG93Rml4TWUgd2Uga25vdyBpdCdzIG5vdCBudWxsXG4gICAgbWF0Y2hbMV07XG4gIH1cblxuICB2YXIgbmFtZSA9IG11cm11cjIoc3R5bGVzKSArIGlkZW50aWZpZXJOYW1lO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZSBTZXJpYWxpemVkU3R5bGVzIHR5cGUgZG9lc24ndCBoYXZlIHRvU3RyaW5nIHByb3BlcnR5IChhbmQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgaXQpXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICAgIG1hcDogc291cmNlTWFwLFxuICAgICAgbmV4dDogY3Vyc29yLFxuICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJZb3UgaGF2ZSB0cmllZCB0byBzdHJpbmdpZnkgb2JqZWN0IHJldHVybmVkIGZyb20gYGNzc2AgZnVuY3Rpb24uIEl0IGlzbid0IHN1cHBvc2VkIHRvIGJlIHVzZWQgZGlyZWN0bHkgKGUuZy4gYXMgdmFsdWUgb2YgdGhlIGBjbGFzc05hbWVgIHByb3ApLCBidXQgcmF0aGVyIGhhbmRlZCB0byBlbW90aW9uIHNvIGl0IGNhbiBoYW5kbGUgaXQgKGUuZy4gYXMgdmFsdWUgb2YgYGNzc2AgcHJvcCkuXCI7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgbmFtZTogbmFtZSxcbiAgICBzdHlsZXM6IHN0eWxlcyxcbiAgICBuZXh0OiBjdXJzb3JcbiAgfTtcbn07XG5cbnZhciB0ZXN0T21pdFByb3BzT25TdHJpbmdUYWcgPSBpc1Byb3BWYWxpZDtcblxudmFyIHRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudCA9IGZ1bmN0aW9uIHRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudChrZXkpIHtcbiAgcmV0dXJuIGtleSAhPT0gJ3RoZW1lJztcbn07XG5cbnZhciBnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AgPSBmdW5jdGlvbiBnZXREZWZhdWx0U2hvdWxkRm9yd2FyZFByb3AodGFnKSB7XG4gIHJldHVybiB0eXBlb2YgdGFnID09PSAnc3RyaW5nJyAmJiAvLyA5NiBpcyBvbmUgbGVzcyB0aGFuIHRoZSBjaGFyIGNvZGVcbiAgLy8gZm9yIFwiYVwiIHNvIHRoaXMgaXMgY2hlY2tpbmcgdGhhdFxuICAvLyBpdCdzIGEgbG93ZXJjYXNlIGNoYXJhY3RlclxuICB0YWcuY2hhckNvZGVBdCgwKSA+IDk2ID8gdGVzdE9taXRQcm9wc09uU3RyaW5nVGFnIDogdGVzdE9taXRQcm9wc09uQ29tcG9uZW50O1xufTtcbnZhciBjb21wb3NlU2hvdWxkRm9yd2FyZFByb3BzID0gZnVuY3Rpb24gY29tcG9zZVNob3VsZEZvcndhcmRQcm9wcyh0YWcsIG9wdGlvbnMsIGlzUmVhbCkge1xuICB2YXIgc2hvdWxkRm9yd2FyZFByb3A7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICB2YXIgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wID0gb3B0aW9ucy5zaG91bGRGb3J3YXJkUHJvcDtcbiAgICBzaG91bGRGb3J3YXJkUHJvcCA9IHRhZy5fX2Vtb3Rpb25fZm9yd2FyZFByb3AgJiYgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wID8gZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICByZXR1cm4gdGFnLl9fZW1vdGlvbl9mb3J3YXJkUHJvcChwcm9wTmFtZSkgJiYgb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wKHByb3BOYW1lKTtcbiAgICB9IDogb3B0aW9uc1Nob3VsZEZvcndhcmRQcm9wO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBzaG91bGRGb3J3YXJkUHJvcCAhPT0gJ2Z1bmN0aW9uJyAmJiBpc1JlYWwpIHtcbiAgICBzaG91bGRGb3J3YXJkUHJvcCA9IHRhZy5fX2Vtb3Rpb25fZm9yd2FyZFByb3A7XG4gIH1cblxuICByZXR1cm4gc2hvdWxkRm9yd2FyZFByb3A7XG59O1xuXG52YXIgSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IgPSBcIllvdSBoYXZlIGlsbGVnYWwgZXNjYXBlIHNlcXVlbmNlIGluIHlvdXIgdGVtcGxhdGUgbGl0ZXJhbCwgbW9zdCBsaWtlbHkgaW5zaWRlIGNvbnRlbnQncyBwcm9wZXJ0eSB2YWx1ZS5cXG5CZWNhdXNlIHlvdSB3cml0ZSB5b3VyIENTUyBpbnNpZGUgYSBKYXZhU2NyaXB0IHN0cmluZyB5b3UgYWN0dWFsbHkgaGF2ZSB0byBkbyBkb3VibGUgZXNjYXBpbmcsIHNvIGZvciBleGFtcGxlIFxcXCJjb250ZW50OiAnXFxcXDAwZDcnO1xcXCIgc2hvdWxkIGJlY29tZSBcXFwiY29udGVudDogJ1xcXFxcXFxcMDBkNyc7XFxcIi5cXG5Zb3UgY2FuIHJlYWQgbW9yZSBhYm91dCB0aGlzIGhlcmU6XFxuaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvVGVtcGxhdGVfbGl0ZXJhbHMjRVMyMDE4X3JldmlzaW9uX29mX2lsbGVnYWxfZXNjYXBlX3NlcXVlbmNlc1wiO1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbnZhciBJbnNlcnRpb24gPSBmdW5jdGlvbiBJbnNlcnRpb24oX3JlZikge1xuICB2YXIgY2FjaGUgPSBfcmVmLmNhY2hlLFxuICAgICAgc2VyaWFsaXplZCA9IF9yZWYuc2VyaWFsaXplZCxcbiAgICAgIGlzU3RyaW5nVGFnID0gX3JlZi5pc1N0cmluZ1RhZztcbiAgcmVnaXN0ZXJTdHlsZXMoY2FjaGUsIHNlcmlhbGl6ZWQsIGlzU3RyaW5nVGFnKTtcbiAgdmFyIHJ1bGVzID0gdXNlSW5zZXJ0aW9uRWZmZWN0QWx3YXlzV2l0aFN5bmNGYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGluc2VydFN0eWxlcyhjYWNoZSwgc2VyaWFsaXplZCwgaXNTdHJpbmdUYWcpO1xuICB9KTtcblxuICBpZiAoIWlzQnJvd3NlciAmJiBydWxlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIF9yZWYyO1xuXG4gICAgdmFyIHNlcmlhbGl6ZWROYW1lcyA9IHNlcmlhbGl6ZWQubmFtZTtcbiAgICB2YXIgbmV4dCA9IHNlcmlhbGl6ZWQubmV4dDtcblxuICAgIHdoaWxlIChuZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHNlcmlhbGl6ZWROYW1lcyArPSAnICcgKyBuZXh0Lm5hbWU7XG4gICAgICBuZXh0ID0gbmV4dC5uZXh0O1xuICAgIH1cblxuICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChcInN0eWxlXCIsIChfcmVmMiA9IHt9LCBfcmVmMltcImRhdGEtZW1vdGlvblwiXSA9IGNhY2hlLmtleSArIFwiIFwiICsgc2VyaWFsaXplZE5hbWVzLCBfcmVmMi5kYW5nZXJvdXNseVNldElubmVySFRNTCA9IHtcbiAgICAgIF9faHRtbDogcnVsZXNcbiAgICB9LCBfcmVmMi5ub25jZSA9IGNhY2hlLnNoZWV0Lm5vbmNlLCBfcmVmMikpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG52YXIgY3JlYXRlU3R5bGVkID0gZnVuY3Rpb24gY3JlYXRlU3R5bGVkKHRhZywgb3B0aW9ucykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgYXJlIHRyeWluZyB0byBjcmVhdGUgYSBzdHlsZWQgZWxlbWVudCB3aXRoIGFuIHVuZGVmaW5lZCBjb21wb25lbnQuXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBpbXBvcnQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGlzUmVhbCA9IHRhZy5fX2Vtb3Rpb25fcmVhbCA9PT0gdGFnO1xuICB2YXIgYmFzZVRhZyA9IGlzUmVhbCAmJiB0YWcuX19lbW90aW9uX2Jhc2UgfHwgdGFnO1xuICB2YXIgaWRlbnRpZmllck5hbWU7XG4gIHZhciB0YXJnZXRDbGFzc05hbWU7XG5cbiAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGlkZW50aWZpZXJOYW1lID0gb3B0aW9ucy5sYWJlbDtcbiAgICB0YXJnZXRDbGFzc05hbWUgPSBvcHRpb25zLnRhcmdldDtcbiAgfVxuXG4gIHZhciBzaG91bGRGb3J3YXJkUHJvcCA9IGNvbXBvc2VTaG91bGRGb3J3YXJkUHJvcHModGFnLCBvcHRpb25zLCBpc1JlYWwpO1xuICB2YXIgZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wID0gc2hvdWxkRm9yd2FyZFByb3AgfHwgZ2V0RGVmYXVsdFNob3VsZEZvcndhcmRQcm9wKGJhc2VUYWcpO1xuICB2YXIgc2hvdWxkVXNlQXMgPSAhZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wKCdhcycpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBzdHlsZXMgPSBpc1JlYWwgJiYgdGFnLl9fZW1vdGlvbl9zdHlsZXMgIT09IHVuZGVmaW5lZCA/IHRhZy5fX2Vtb3Rpb25fc3R5bGVzLnNsaWNlKDApIDogW107XG5cbiAgICBpZiAoaWRlbnRpZmllck5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVzLnB1c2goXCJsYWJlbDpcIiArIGlkZW50aWZpZXJOYW1lICsgXCI7XCIpO1xuICAgIH1cblxuICAgIGlmIChhcmdzWzBdID09IG51bGwgfHwgYXJnc1swXS5yYXcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgc3R5bGVzLnB1c2guYXBwbHkoc3R5bGVzLCBhcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXJnc1swXVswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICBzdHlsZXMucHVzaChhcmdzWzBdWzBdKTtcbiAgICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICAgIHZhciBpID0gMTtcblxuICAgICAgZm9yICg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBhcmdzWzBdW2ldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKElMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0eWxlcy5wdXNoKGFyZ3NbaV0sIGFyZ3NbMF1baV0pO1xuICAgICAgfVxuICAgIH0gLy8gJEZsb3dGaXhNZTogd2UgbmVlZCB0byBjYXN0IFN0YXRlbGVzc0Z1bmN0aW9uYWxDb21wb25lbnQgdG8gb3VyIFByaXZhdGVTdHlsZWRDb21wb25lbnQgY2xhc3NcblxuXG4gICAgdmFyIFN0eWxlZCA9IHdpdGhFbW90aW9uQ2FjaGUoZnVuY3Rpb24gKHByb3BzLCBjYWNoZSwgcmVmKSB7XG4gICAgICB2YXIgRmluYWxUYWcgPSBzaG91bGRVc2VBcyAmJiBwcm9wcy5hcyB8fCBiYXNlVGFnO1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICcnO1xuICAgICAgdmFyIGNsYXNzSW50ZXJwb2xhdGlvbnMgPSBbXTtcbiAgICAgIHZhciBtZXJnZWRQcm9wcyA9IHByb3BzO1xuXG4gICAgICBpZiAocHJvcHMudGhlbWUgPT0gbnVsbCkge1xuICAgICAgICBtZXJnZWRQcm9wcyA9IHt9O1xuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICAgIG1lcmdlZFByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgbWVyZ2VkUHJvcHMudGhlbWUgPSB1c2VDb250ZXh0KFRoZW1lQ29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBjbGFzc05hbWUgPSBnZXRSZWdpc3RlcmVkU3R5bGVzKGNhY2hlLnJlZ2lzdGVyZWQsIGNsYXNzSW50ZXJwb2xhdGlvbnMsIHByb3BzLmNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmNsYXNzTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSArIFwiIFwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZVN0eWxlcyhzdHlsZXMuY29uY2F0KGNsYXNzSW50ZXJwb2xhdGlvbnMpLCBjYWNoZS5yZWdpc3RlcmVkLCBtZXJnZWRQcm9wcyk7XG4gICAgICBjbGFzc05hbWUgKz0gY2FjaGUua2V5ICsgXCItXCIgKyBzZXJpYWxpemVkLm5hbWU7XG5cbiAgICAgIGlmICh0YXJnZXRDbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjbGFzc05hbWUgKz0gXCIgXCIgKyB0YXJnZXRDbGFzc05hbWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBmaW5hbFNob3VsZEZvcndhcmRQcm9wID0gc2hvdWxkVXNlQXMgJiYgc2hvdWxkRm9yd2FyZFByb3AgPT09IHVuZGVmaW5lZCA/IGdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcChGaW5hbFRhZykgOiBkZWZhdWx0U2hvdWxkRm9yd2FyZFByb3A7XG4gICAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgICAgZm9yICh2YXIgX2tleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2hvdWxkVXNlQXMgJiYgX2tleSA9PT0gJ2FzJykgY29udGludWU7XG5cbiAgICAgICAgaWYgKCAvLyAkRmxvd0ZpeE1lXG4gICAgICAgIGZpbmFsU2hvdWxkRm9yd2FyZFByb3AoX2tleSkpIHtcbiAgICAgICAgICBuZXdQcm9wc1tfa2V5XSA9IHByb3BzW19rZXldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG5ld1Byb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIG5ld1Byb3BzLnJlZiA9IHJlZjtcbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGcmFnbWVudCwgbnVsbCwgLyojX19QVVJFX18qL2NyZWF0ZUVsZW1lbnQoSW5zZXJ0aW9uLCB7XG4gICAgICAgIGNhY2hlOiBjYWNoZSxcbiAgICAgICAgc2VyaWFsaXplZDogc2VyaWFsaXplZCxcbiAgICAgICAgaXNTdHJpbmdUYWc6IHR5cGVvZiBGaW5hbFRhZyA9PT0gJ3N0cmluZydcbiAgICAgIH0pLCAvKiNfX1BVUkVfXyovY3JlYXRlRWxlbWVudChGaW5hbFRhZywgbmV3UHJvcHMpKTtcbiAgICB9KTtcbiAgICBTdHlsZWQuZGlzcGxheU5hbWUgPSBpZGVudGlmaWVyTmFtZSAhPT0gdW5kZWZpbmVkID8gaWRlbnRpZmllck5hbWUgOiBcIlN0eWxlZChcIiArICh0eXBlb2YgYmFzZVRhZyA9PT0gJ3N0cmluZycgPyBiYXNlVGFnIDogYmFzZVRhZy5kaXNwbGF5TmFtZSB8fCBiYXNlVGFnLm5hbWUgfHwgJ0NvbXBvbmVudCcpICsgXCIpXCI7XG4gICAgU3R5bGVkLmRlZmF1bHRQcm9wcyA9IHRhZy5kZWZhdWx0UHJvcHM7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9yZWFsID0gU3R5bGVkO1xuICAgIFN0eWxlZC5fX2Vtb3Rpb25fYmFzZSA9IGJhc2VUYWc7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9zdHlsZXMgPSBzdHlsZXM7XG4gICAgU3R5bGVkLl9fZW1vdGlvbl9mb3J3YXJkUHJvcCA9IHNob3VsZEZvcndhcmRQcm9wO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShTdHlsZWQsICd0b1N0cmluZycsIHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcbiAgICAgICAgaWYgKHRhcmdldENsYXNzTmFtZSA9PT0gdW5kZWZpbmVkICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gJ05PX0NPTVBPTkVOVF9TRUxFQ1RPUic7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZTogY29lcmNlIHVuZGVmaW5lZCB0byBzdHJpbmdcblxuXG4gICAgICAgIHJldHVybiBcIi5cIiArIHRhcmdldENsYXNzTmFtZTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIFN0eWxlZC53aXRoQ29tcG9uZW50ID0gZnVuY3Rpb24gKG5leHRUYWcsIG5leHRPcHRpb25zKSB7XG4gICAgICByZXR1cm4gY3JlYXRlU3R5bGVkKG5leHRUYWcsIF9leHRlbmRzKHt9LCBvcHRpb25zLCBuZXh0T3B0aW9ucywge1xuICAgICAgICBzaG91bGRGb3J3YXJkUHJvcDogY29tcG9zZVNob3VsZEZvcndhcmRQcm9wcyhTdHlsZWQsIG5leHRPcHRpb25zLCB0cnVlKVxuICAgICAgfSkpLmFwcGx5KHZvaWQgMCwgc3R5bGVzKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFN0eWxlZDtcbiAgfTtcbn07XG5cbnZhciB0YWdzID0gWydhJywgJ2FiYnInLCAnYWRkcmVzcycsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYXVkaW8nLCAnYicsICdiYXNlJywgJ2JkaScsICdiZG8nLCAnYmlnJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FudmFzJywgJ2NhcHRpb24nLCAnY2l0ZScsICdjb2RlJywgJ2NvbCcsICdjb2xncm91cCcsICdkYXRhJywgJ2RhdGFsaXN0JywgJ2RkJywgJ2RlbCcsICdkZXRhaWxzJywgJ2RmbicsICdkaWFsb2cnLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtJywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2knLCAnaWZyYW1lJywgJ2ltZycsICdpbnB1dCcsICdpbnMnLCAna2JkJywgJ2tleWdlbicsICdsYWJlbCcsICdsZWdlbmQnLCAnbGknLCAnbGluaycsICdtYWluJywgJ21hcCcsICdtYXJrJywgJ21hcnF1ZWUnLCAnbWVudScsICdtZW51aXRlbScsICdtZXRhJywgJ21ldGVyJywgJ25hdicsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAnb3B0Z3JvdXAnLCAnb3B0aW9uJywgJ291dHB1dCcsICdwJywgJ3BhcmFtJywgJ3BpY3R1cmUnLCAncHJlJywgJ3Byb2dyZXNzJywgJ3EnLCAncnAnLCAncnQnLCAncnVieScsICdzJywgJ3NhbXAnLCAnc2NyaXB0JywgJ3NlY3Rpb24nLCAnc2VsZWN0JywgJ3NtYWxsJywgJ3NvdXJjZScsICdzcGFuJywgJ3N0cm9uZycsICdzdHlsZScsICdzdWInLCAnc3VtbWFyeScsICdzdXAnLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGltZScsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1JywgJ3VsJywgJ3ZhcicsICd2aWRlbycsICd3YnInLCAvLyBTVkdcbidjaXJjbGUnLCAnY2xpcFBhdGgnLCAnZGVmcycsICdlbGxpcHNlJywgJ2ZvcmVpZ25PYmplY3QnLCAnZycsICdpbWFnZScsICdsaW5lJywgJ2xpbmVhckdyYWRpZW50JywgJ21hc2snLCAncGF0aCcsICdwYXR0ZXJuJywgJ3BvbHlnb24nLCAncG9seWxpbmUnLCAncmFkaWFsR3JhZGllbnQnLCAncmVjdCcsICdzdG9wJywgJ3N2ZycsICd0ZXh0JywgJ3RzcGFuJ107XG5cbnZhciBuZXdTdHlsZWQgPSBjcmVhdGVTdHlsZWQuYmluZCgpO1xudGFncy5mb3JFYWNoKGZ1bmN0aW9uICh0YWdOYW1lKSB7XG4gIC8vICRGbG93Rml4TWU6IHdlIGNhbiBpZ25vcmUgdGhpcyBiZWNhdXNlIGl0cyBleHBvc2VkIHR5cGUgaXMgZGVmaW5lZCBieSB0aGUgQ3JlYXRlU3R5bGVkIHR5cGVcbiAgbmV3U3R5bGVkW3RhZ05hbWVdID0gbmV3U3R5bGVkKHRhZ05hbWUpO1xufSk7XG5cbnZhciBjbGFzc25hbWVzJDEgPSB7ZXhwb3J0czoge319O1xuXG4vKiFcblx0Q29weXJpZ2h0IChjKSAyMDE4IEplZCBXYXRzb24uXG5cdExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZSAoTUlUKSwgc2VlXG5cdGh0dHA6Ly9qZWR3YXRzb24uZ2l0aHViLmlvL2NsYXNzbmFtZXNcbiovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG4vKiBnbG9iYWwgZGVmaW5lICovXG5cbihmdW5jdGlvbiAoKSB7XG5cblx0dmFyIGhhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuXG5cdGZ1bmN0aW9uIGNsYXNzTmFtZXMoKSB7XG5cdFx0dmFyIGNsYXNzZXMgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgYXJnID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0aWYgKCFhcmcpIGNvbnRpbnVlO1xuXG5cdFx0XHR2YXIgYXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cblx0XHRcdGlmIChhcmdUeXBlID09PSAnc3RyaW5nJyB8fCBhcmdUeXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRjbGFzc2VzLnB1c2goYXJnKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGlmIChhcmcubGVuZ3RoKSB7XG5cdFx0XHRcdFx0dmFyIGlubmVyID0gY2xhc3NOYW1lcy5hcHBseShudWxsLCBhcmcpO1xuXHRcdFx0XHRcdGlmIChpbm5lcikge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGlubmVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKGFyZy50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZyAmJiAhYXJnLnRvU3RyaW5nLnRvU3RyaW5nKCkuaW5jbHVkZXMoJ1tuYXRpdmUgY29kZV0nKSkge1xuXHRcdFx0XHRcdGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gYXJnKSB7XG5cdFx0XHRcdFx0aWYgKGhhc093bi5jYWxsKGFyZywga2V5KSAmJiBhcmdba2V5XSkge1xuXHRcdFx0XHRcdFx0Y2xhc3Nlcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNsYXNzZXMuam9pbignICcpO1xuXHR9XG5cblx0aWYgKG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Y2xhc3NOYW1lcy5kZWZhdWx0ID0gY2xhc3NOYW1lcztcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGNsYXNzTmFtZXM7XG5cdH0gZWxzZSB7XG5cdFx0d2luZG93LmNsYXNzTmFtZXMgPSBjbGFzc05hbWVzO1xuXHR9XG59KCkpO1xufShjbGFzc25hbWVzJDEpKTtcblxudmFyIGNsYXNzbmFtZXMgPSBjbGFzc25hbWVzJDEuZXhwb3J0cztcblxudmFyIExlZ2FjeVNpZGViYXJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh1bmRlZmluZWQpO1xyXG52YXIgU2lkZWJhclByb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcclxuICAgIHZhciBfYiA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKHtcclxuICAgICAgICBjb2xsYXBzZWQ6IGZhbHNlLFxyXG4gICAgICAgIHRvZ2dsZWQ6IGZhbHNlLFxyXG4gICAgICAgIGJyb2tlbjogZmFsc2UsXHJcbiAgICAgICAgcnRsOiBmYWxzZSxcclxuICAgICAgICB0cmFuc2l0aW9uRHVyYXRpb246IDMwMCxcclxuICAgIH0pLCBzaWRlYmFyU3RhdGUgPSBfYlswXSwgc2V0U2lkZWJhclN0YXRlID0gX2JbMV07XHJcbiAgICB2YXIgdXBkYXRlU2lkZWJhclN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKHZhbHVlcykge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHZhbHVlcykpOyB9KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciB1cGRhdGVDb2xsYXBzZVN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgY29sbGFwc2VkOiAhQm9vbGVhbihwcmV2U3RhdGUgPT09IG51bGwgfHwgcHJldlN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmV2U3RhdGUuY29sbGFwc2VkKSB9KSk7IH0pO1xyXG4gICAgfSwgW10pO1xyXG4gICAgdmFyIHVwZGF0ZVRvZ2dsZVN0YXRlID0gUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNldFNpZGViYXJTdGF0ZShmdW5jdGlvbiAocHJldlN0YXRlKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXZTdGF0ZSksIHsgdG9nZ2xlZDogIUJvb2xlYW4ocHJldlN0YXRlID09PSBudWxsIHx8IHByZXZTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJldlN0YXRlLnRvZ2dsZWQpIH0pKTsgfSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICB2YXIgcHJvdmlkZXJWYWx1ZSA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBzaWRlYmFyU3RhdGUpLCB7IHVwZGF0ZVNpZGViYXJTdGF0ZTogdXBkYXRlU2lkZWJhclN0YXRlLCB1cGRhdGVDb2xsYXBzZVN0YXRlOiB1cGRhdGVDb2xsYXBzZVN0YXRlLCB1cGRhdGVUb2dnbGVTdGF0ZTogdXBkYXRlVG9nZ2xlU3RhdGUgfSkpOyB9LCBbc2lkZWJhclN0YXRlLCB1cGRhdGVDb2xsYXBzZVN0YXRlLCB1cGRhdGVTaWRlYmFyU3RhdGUsIHVwZGF0ZVRvZ2dsZVN0YXRlXSk7XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGVnYWN5U2lkZWJhckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHByb3ZpZGVyVmFsdWUgfSwgY2hpbGRyZW4pKTtcclxufTtcblxudmFyIHVzZUxlZ2FjeVNpZGViYXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTGVnYWN5U2lkZWJhckNvbnRleHQpO1xyXG4gICAgcmV0dXJuIGNvbnRleHQ7XHJcbn07XG5cbnZhciB1c2VNZWRpYVF1ZXJ5ID0gZnVuY3Rpb24gKGJyZWFrcG9pbnQpIHtcclxuICAgIHZhciBfYSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKCEhYnJlYWtwb2ludCAmJiB3aW5kb3cubWF0Y2hNZWRpYShicmVha3BvaW50KS5tYXRjaGVzKSwgbWF0Y2hlcyA9IF9hWzBdLCBzZXRNYXRjaGVzID0gX2FbMV07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChicmVha3BvaW50KSB7XHJcbiAgICAgICAgICAgIHZhciBtZWRpYV8xID0gd2luZG93Lm1hdGNoTWVkaWEoYnJlYWtwb2ludCk7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGVNYXRjaF8xID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhXzEubWF0Y2hlcyAhPT0gbWF0Y2hlcykge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldE1hdGNoZXMobWVkaWFfMS5tYXRjaGVzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGFuZGxlTWF0Y2hfMSgpO1xyXG4gICAgICAgICAgICBtZWRpYV8xLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGhhbmRsZU1hdGNoXzEpO1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbWVkaWFfMS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBoYW5kbGVNYXRjaF8xKTsgfTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbbWF0Y2hlcywgYnJlYWtwb2ludF0pO1xyXG4gICAgcmV0dXJuIG1hdGNoZXM7XHJcbn07XG5cbnZhciBzaWRlYmFyQ2xhc3NlcyA9IHtcclxuICAgIHJvb3Q6ICdwcy1zaWRlYmFyLXJvb3QnLFxyXG4gICAgY29udGFpbmVyOiAncHMtc2lkZWJhci1jb250YWluZXInLFxyXG4gICAgaW1hZ2U6ICdwcy1zaWRlYmFyLWltYWdlJyxcclxuICAgIGJhY2tkcm9wOiAncHMtc2lkZWJhci1iYWNrZHJvcCcsXHJcbiAgICBjb2xsYXBzZWQ6ICdwcy1jb2xsYXBzZWQnLFxyXG4gICAgdG9nZ2xlZDogJ3BzLXRvZ2dsZWQnLFxyXG4gICAgcnRsOiAncHMtcnRsJyxcclxuICAgIGJyb2tlbjogJ3BzLWJyb2tlbicsXHJcbn07XHJcbnZhciBtZW51Q2xhc3NlcyA9IHtcclxuICAgIHJvb3Q6ICdwcy1tZW51LXJvb3QnLFxyXG4gICAgbWVudUl0ZW1Sb290OiAncHMtbWVudWl0ZW0tcm9vdCcsXHJcbiAgICBzdWJNZW51Um9vdDogJ3BzLXN1Ym1lbnUtcm9vdCcsXHJcbiAgICBidXR0b246ICdwcy1tZW51LWJ1dHRvbicsXHJcbiAgICBwcmVmaXg6ICdwcy1tZW51LXByZWZpeCcsXHJcbiAgICBzdWZmaXg6ICdwcy1tZW51LXN1ZmZpeCcsXHJcbiAgICBsYWJlbDogJ3BzLW1lbnUtbGFiZWwnLFxyXG4gICAgaWNvbjogJ3BzLW1lbnUtaWNvbicsXHJcbiAgICBzdWJNZW51Q29udGVudDogJ3BzLXN1Ym1lbnUtY29udGVudCcsXHJcbiAgICBTdWJNZW51RXhwYW5kSWNvbjogJ3BzLXN1Ym1lbnUtZXhwYW5kLWljb24nLFxyXG4gICAgZGlzYWJsZWQ6ICdwcy1kaXNhYmxlZCcsXHJcbiAgICBhY3RpdmU6ICdwcy1hY3RpdmUnLFxyXG4gICAgb3BlbjogJ3BzLW9wZW4nLFxyXG59O1xuXG52YXIgU3R5bGVkQmFja2Ryb3AgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzEkYiB8fCAodGVtcGxhdGVPYmplY3RfMSRiID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDBweDtcXG4gIHJpZ2h0OiAwcHg7XFxuICBib3R0b206IDBweDtcXG4gIGxlZnQ6IDBweDtcXG4gIHotaW5kZXg6IDE7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2IoMCwgMCwgMCwgMC4zKTtcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwcHg7XFxuICByaWdodDogMHB4O1xcbiAgYm90dG9tOiAwcHg7XFxuICBsZWZ0OiAwcHg7XFxuICB6LWluZGV4OiAxO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDAsIDAsIDAsIDAuMyk7XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSRiO1xuXG52YXIgQlJFQUtfUE9JTlRTID0ge1xyXG4gICAgeHM6ICc0ODBweCcsXHJcbiAgICBzbTogJzU3NnB4JyxcclxuICAgIG1kOiAnNzY4cHgnLFxyXG4gICAgbGc6ICc5OTJweCcsXHJcbiAgICB4bDogJzEyMDBweCcsXHJcbiAgICB4eGw6ICcxNjAwcHgnLFxyXG4gICAgYWx3YXlzOiAnYWx3YXlzJyxcclxuICAgIGFsbDogJ2FsbCcsXHJcbn07XHJcbnZhciBTdHlsZWRTaWRlYmFyID0gbmV3U3R5bGVkLmFzaWRlKHRlbXBsYXRlT2JqZWN0XzEkYSB8fCAodGVtcGxhdGVPYmplY3RfMSRhID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBib3JkZXItcmlnaHQtd2lkdGg6IDFweDtcXG4gIGJvcmRlci1yaWdodC1zdHlsZTogc29saWQ7XFxuICBib3JkZXItY29sb3I6ICNlZmVmZWY7XFxuXFxuICB0cmFuc2l0aW9uOiBcIiwgXCI7XFxuXFxuICB3aWR0aDogXCIsIFwiO1xcbiAgbWluLXdpZHRoOiBcIiwgXCI7XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiBcIiwgXCI7XFxuICAgIG1pbi13aWR0aDogXCIsIFwiO1xcbiAgfVxcblxcbiAgJi5cIiwgXCIge1xcbiAgICBkaXJlY3Rpb246IHJ0bDtcXG4gICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiBub25lO1xcbiAgICBib3JkZXItbGVmdC13aWR0aDogMXB4O1xcbiAgICBib3JkZXItcmlnaHQtc3R5bGU6IG5vbmU7XFxuICAgIGJvcmRlci1sZWZ0LXN0eWxlOiBzb2xpZDtcXG4gIH1cXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIHRvcDogMHB4O1xcbiAgICB6LWluZGV4OiAxMDA7XFxuXFxuICAgIFwiLCBcIlxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgXCIsIFwiXFxuICAgIH1cXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIFwiLCBcIlxcbiAgICB9XFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICByaWdodDogLVwiLCBcIjtcXG5cXG4gICAgICAmLlwiLCBcIiB7XFxuICAgICAgICByaWdodDogLVwiLCBcIjtcXG4gICAgICB9XFxuXFxuICAgICAgJi5cIiwgXCIge1xcbiAgICAgICAgcmlnaHQ6IDA7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBcIiwgXCJcXG5cIl0sIFtcIlxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgYm9yZGVyLXJpZ2h0LXdpZHRoOiAxcHg7XFxuICBib3JkZXItcmlnaHQtc3R5bGU6IHNvbGlkO1xcbiAgYm9yZGVyLWNvbG9yOiAjZWZlZmVmO1xcblxcbiAgdHJhbnNpdGlvbjogXCIsIFwiO1xcblxcbiAgd2lkdGg6IFwiLCBcIjtcXG4gIG1pbi13aWR0aDogXCIsIFwiO1xcblxcbiAgJi5cIiwgXCIge1xcbiAgICB3aWR0aDogXCIsIFwiO1xcbiAgICBtaW4td2lkdGg6IFwiLCBcIjtcXG4gIH1cXG5cXG4gICYuXCIsIFwiIHtcXG4gICAgZGlyZWN0aW9uOiBydGw7XFxuICAgIGJvcmRlci1yaWdodC13aWR0aDogbm9uZTtcXG4gICAgYm9yZGVyLWxlZnQtd2lkdGg6IDFweDtcXG4gICAgYm9yZGVyLXJpZ2h0LXN0eWxlOiBub25lO1xcbiAgICBib3JkZXItbGVmdC1zdHlsZTogc29saWQ7XFxuICB9XFxuXFxuICAmLlwiLCBcIiB7XFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICB0b3A6IDBweDtcXG4gICAgei1pbmRleDogMTAwO1xcblxcbiAgICBcIiwgXCJcXG5cXG4gICAgJi5cIiwgXCIge1xcbiAgICAgIFwiLCBcIlxcbiAgICB9XFxuXFxuICAgICYuXCIsIFwiIHtcXG4gICAgICBcIiwgXCJcXG4gICAgfVxcblxcbiAgICAmLlwiLCBcIiB7XFxuICAgICAgcmlnaHQ6IC1cIiwgXCI7XFxuXFxuICAgICAgJi5cIiwgXCIge1xcbiAgICAgICAgcmlnaHQ6IC1cIiwgXCI7XFxuICAgICAgfVxcblxcbiAgICAgICYuXCIsIFwiIHtcXG4gICAgICAgIHJpZ2h0OiAwO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgXCIsIFwiXFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiBcIndpZHRoLCBsZWZ0LCByaWdodCwgXCIuY29uY2F0KHRyYW5zaXRpb25EdXJhdGlvbiwgXCJtc1wiKTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy5ydGwsIHNpZGViYXJDbGFzc2VzLmJyb2tlbiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsLCB3aWR0aCA9IF9hLndpZHRoO1xyXG4gICAgcmV0dXJuICghcnRsID8gXCJsZWZ0OiAtXCIuY29uY2F0KHdpZHRoLCBcIjtcIikgOiAnJyk7XHJcbn0sIHNpZGViYXJDbGFzc2VzLmNvbGxhcHNlZCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsLCBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuICghcnRsID8gXCJsZWZ0OiAtXCIuY29uY2F0KGNvbGxhcHNlZFdpZHRoLCBcIjsgXCIpIDogJycpO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy50b2dnbGVkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gKCFydGwgPyBcImxlZnQ6IDA7XCIgOiAnJyk7XHJcbn0sIHNpZGViYXJDbGFzc2VzLnJ0bCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgd2lkdGggPSBfYS53aWR0aDtcclxuICAgIHJldHVybiB3aWR0aDtcclxufSwgc2lkZWJhckNsYXNzZXMuY29sbGFwc2VkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWRXaWR0aCA9IF9hLmNvbGxhcHNlZFdpZHRoO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZFdpZHRoO1xyXG59LCBzaWRlYmFyQ2xhc3Nlcy50b2dnbGVkLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcztcclxuICAgIHJldHVybiByb290U3R5bGVzO1xyXG59KTtcclxudmFyIFN0eWxlZFNpZGViYXJDb250YWluZXIgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzIkMSB8fCAodGVtcGxhdGVPYmplY3RfMiQxID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgei1pbmRleDogMztcXG5cXG4gIFwiLCBcIlxcblwiXSwgW1wiXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBvdmVyZmxvdy15OiBhdXRvO1xcbiAgb3ZlcmZsb3cteDogaGlkZGVuO1xcbiAgei1pbmRleDogMztcXG5cXG4gIFwiLCBcIlxcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBiYWNrZ3JvdW5kQ29sb3IgPSBfYS5iYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICByZXR1cm4gKGJhY2tncm91bmRDb2xvciA/IFwiYmFja2dyb3VuZC1jb2xvcjpcIi5jb25jYXQoYmFja2dyb3VuZENvbG9yLCBcIjtcIikgOiAnJyk7XHJcbn0pO1xyXG52YXIgU3R5bGVkU2lkZWJhckltYWdlID0gbmV3U3R5bGVkLmltZyh0ZW1wbGF0ZU9iamVjdF8zJDEgfHwgKHRlbXBsYXRlT2JqZWN0XzMkMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICB3aWR0aDogMTAwJTtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBvYmplY3QtZml0OiBjb3ZlcjtcXG4gICAgb2JqZWN0LXBvc2l0aW9uOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgbGVmdDogMDtcXG4gICAgdG9wOiAwO1xcbiAgICB6LWluZGV4OiAyO1xcbiAgfVxcblwiXSwgW1wiXFxuICAmLlwiLCBcIiB7XFxuICAgIHdpZHRoOiAxMDAlO1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG9iamVjdC1maXQ6IGNvdmVyO1xcbiAgICBvYmplY3QtcG9zaXRpb246IGNlbnRlcjtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICBsZWZ0OiAwO1xcbiAgICB0b3A6IDA7XFxuICAgIHotaW5kZXg6IDI7XFxuICB9XFxuXCJdKSksIHNpZGViYXJDbGFzc2VzLmltYWdlKTtcclxudmFyIFNpZGViYXJDb250ZXh0ID0gUmVhY3RfX2RlZmF1bHQuY3JlYXRlQ29udGV4dCh7XHJcbiAgICBjb2xsYXBzZWQ6IGZhbHNlLFxyXG4gICAgdG9nZ2xlZDogZmFsc2UsXHJcbiAgICBydGw6IGZhbHNlLFxyXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiAzMDAsXHJcbn0pO1xyXG52YXIgU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIHRvZ2dsZWQgPSBfYS50b2dnbGVkLCBvbkJhY2tkcm9wQ2xpY2sgPSBfYS5vbkJhY2tkcm9wQ2xpY2ssIG9uQnJlYWtQb2ludCA9IF9hLm9uQnJlYWtQb2ludCwgX2MgPSBfYS53aWR0aCwgd2lkdGggPSBfYyA9PT0gdm9pZCAwID8gJzI1MHB4JyA6IF9jLCBfZCA9IF9hLmNvbGxhcHNlZFdpZHRoLCBjb2xsYXBzZWRXaWR0aCA9IF9kID09PSB2b2lkIDAgPyAnODBweCcgOiBfZCwgZGVmYXVsdENvbGxhcHNlZCA9IF9hLmRlZmF1bHRDb2xsYXBzZWQsIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgYnJlYWtQb2ludCA9IF9hLmJyZWFrUG9pbnQsIGN1c3RvbUJyZWFrUG9pbnQgPSBfYS5jdXN0b21CcmVha1BvaW50LCBfZSA9IF9hLmJhY2tncm91bmRDb2xvciwgYmFja2dyb3VuZENvbG9yID0gX2UgPT09IHZvaWQgMCA/ICdyZ2IoMjQ5LCAyNDksIDI0OSwgMC43KScgOiBfZSwgX2YgPSBfYS50cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9mID09PSB2b2lkIDAgPyAzMDAgOiBfZiwgaW1hZ2UgPSBfYS5pbWFnZSwgcnRsID0gX2EucnRsLCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgcmVzdCA9IF9fcmVzdChfYSwgW1wiY29sbGFwc2VkXCIsIFwidG9nZ2xlZFwiLCBcIm9uQmFja2Ryb3BDbGlja1wiLCBcIm9uQnJlYWtQb2ludFwiLCBcIndpZHRoXCIsIFwiY29sbGFwc2VkV2lkdGhcIiwgXCJkZWZhdWx0Q29sbGFwc2VkXCIsIFwiY2xhc3NOYW1lXCIsIFwiY2hpbGRyZW5cIiwgXCJicmVha1BvaW50XCIsIFwiY3VzdG9tQnJlYWtQb2ludFwiLCBcImJhY2tncm91bmRDb2xvclwiLCBcInRyYW5zaXRpb25EdXJhdGlvblwiLCBcImltYWdlXCIsIFwicnRsXCIsIFwicm9vdFN0eWxlc1wiXSk7XHJcbiAgICB2YXIgZ2V0QnJlYWtwb2ludFZhbHVlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmIChjdXN0b21CcmVha1BvaW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBcIihtYXgtd2lkdGg6IFwiLmNvbmNhdChjdXN0b21CcmVha1BvaW50LCBcIilcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChicmVha1BvaW50KSB7XHJcbiAgICAgICAgICAgIGlmIChbJ3hzJywgJ3NtJywgJ21kJywgJ2xnJywgJ3hsJywgJ3h4bCddLmluY2x1ZGVzKGJyZWFrUG9pbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIobWF4LXdpZHRoOiBcIi5jb25jYXQoQlJFQUtfUE9JTlRTW2JyZWFrUG9pbnRdLCBcIilcIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGJyZWFrUG9pbnQgPT09ICdhbHdheXMnIHx8IGJyZWFrUG9pbnQgPT09ICdhbGwnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoYnJlYWtQb2ludCA9PT0gJ2Fsd2F5cycpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZSBcImFsd2F5c1wiIGJyZWFrUG9pbnQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGZ1dHVyZSByZWxlYXNlLiAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJ1BsZWFzZSB1c2UgdGhlIFwiYWxsXCIgYnJlYWtQb2ludCBpbnN0ZWFkLicpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2NyZWVuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIFwiKG1heC13aWR0aDogXCIuY29uY2F0KGJyZWFrUG9pbnQsIFwiKVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIGJyZWFrcG9pbnRDYWxsYmFja0ZuUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICBicmVha3BvaW50Q2FsbGJhY2tGblJlZi5jdXJyZW50ID0gZnVuY3Rpb24gKGJyb2tlbikge1xyXG4gICAgICAgIG9uQnJlYWtQb2ludCA9PT0gbnVsbCB8fCBvbkJyZWFrUG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQnJlYWtQb2ludChicm9rZW4pO1xyXG4gICAgfTtcclxuICAgIHZhciBicm9rZW4gPSB1c2VNZWRpYVF1ZXJ5KGdldEJyZWFrcG9pbnRWYWx1ZSgpKTtcclxuICAgIHZhciBfZyA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKSwgbW91bnRlZCA9IF9nWzBdLCBzZXRNb3VudGVkID0gX2dbMV07XHJcbiAgICB2YXIgbGVnYWN5U2lkZWJhckNvbnRleHQgPSB1c2VMZWdhY3lTaWRlYmFyKCk7XHJcbiAgICB2YXIgY29sbGFwc2VkVmFsdWUgPSBjb2xsYXBzZWQgIT09IG51bGwgJiYgY29sbGFwc2VkICE9PSB2b2lkIDAgPyBjb2xsYXBzZWQgOiAoIW1vdW50ZWQgJiYgZGVmYXVsdENvbGxhcHNlZCA/IHRydWUgOiBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQuY29sbGFwc2VkKTtcclxuICAgIHZhciB0b2dnbGVkVmFsdWUgPSB0b2dnbGVkICE9PSBudWxsICYmIHRvZ2dsZWQgIT09IHZvaWQgMCA/IHRvZ2dsZWQgOiBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gbnVsbCB8fCBsZWdhY3lTaWRlYmFyQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGVnYWN5U2lkZWJhckNvbnRleHQudG9nZ2xlZDtcclxuICAgIHZhciBoYW5kbGVCYWNrZHJvcENsaWNrID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIG9uQmFja2Ryb3BDbGljayA9PT0gbnVsbCB8fCBvbkJhY2tkcm9wQ2xpY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uQmFja2Ryb3BDbGljaygpO1xyXG4gICAgICAgIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoeyB0b2dnbGVkOiBmYWxzZSB9KTtcclxuICAgIH07XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYTtcclxuICAgICAgICAoX2EgPSBicmVha3BvaW50Q2FsbGJhY2tGblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChicmVha3BvaW50Q2FsbGJhY2tGblJlZiwgYnJva2VuKTtcclxuICAgIH0sIFticm9rZW5dKTtcclxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb25cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSh7IGJyb2tlbjogYnJva2VuLCBydGw6IHJ0bCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24gfSk7XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW2Jyb2tlbiwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IG51bGwgfHwgbGVnYWN5U2lkZWJhckNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlZ2FjeVNpZGViYXJDb250ZXh0LnVwZGF0ZVNpZGViYXJTdGF0ZSwgcnRsLCB0cmFuc2l0aW9uRHVyYXRpb25dKTtcclxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBuZXh0IG1ham9yIHZlcnNpb25cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCFtb3VudGVkKSB7XHJcbiAgICAgICAgICAgIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgY29sbGFwc2VkOiBkZWZhdWx0Q29sbGFwc2VkLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgfSwgW2RlZmF1bHRDb2xsYXBzZWQsIG1vdW50ZWQsIGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSBudWxsIHx8IGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGVdKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTaWRlYmFyQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZFZhbHVlLCB0b2dnbGVkOiB0b2dnbGVkVmFsdWUsIHJ0bDogcnRsLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiB9IH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTaWRlYmFyLCBfX2Fzc2lnbih7IHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KHNpZGViYXJDbGFzc2VzLnJvb3QsIFwiLXRlc3QtaWRcIiksIHJ0bDogcnRsLCByb290U3R5bGVzOiByb290U3R5bGVzLCB3aWR0aDogd2lkdGgsIGNvbGxhcHNlZFdpZHRoOiBjb2xsYXBzZWRXaWR0aCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhzaWRlYmFyQ2xhc3Nlcy5yb290LCAoX2IgPSB7fSxcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLmNvbGxhcHNlZF0gPSBjb2xsYXBzZWRWYWx1ZSxcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLnRvZ2dsZWRdID0gdG9nZ2xlZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgX2Jbc2lkZWJhckNsYXNzZXMuYnJva2VuXSA9IGJyb2tlbixcclxuICAgICAgICAgICAgICAgIF9iW3NpZGViYXJDbGFzc2VzLnJ0bF0gPSBydGwsXHJcbiAgICAgICAgICAgICAgICBfYiksIGNsYXNzTmFtZSkgfSwgcmVzdCksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkU2lkZWJhckNvbnRhaW5lciwgeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KHNpZGViYXJDbGFzc2VzLmNvbnRhaW5lciwgXCItdGVzdC1pZFwiKSwgY2xhc3NOYW1lOiBzaWRlYmFyQ2xhc3Nlcy5jb250YWluZXIsIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yIH0sIGNoaWxkcmVuKSxcclxuICAgICAgICAgICAgaW1hZ2UgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkU2lkZWJhckltYWdlLCB7IFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQoc2lkZWJhckNsYXNzZXMuaW1hZ2UsIFwiLXRlc3QtaWRcIiksIHNyYzogaW1hZ2UsIGFsdDogXCJzaWRlYmFyIGJhY2tncm91bmRcIiwgY2xhc3NOYW1lOiBzaWRlYmFyQ2xhc3Nlcy5pbWFnZSB9KSksXHJcbiAgICAgICAgICAgIGJyb2tlbiAmJiB0b2dnbGVkVmFsdWUgJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkQmFja2Ryb3AsIHsgXCJkYXRhLXRlc3RpZFwiOiBcIlwiLmNvbmNhdChzaWRlYmFyQ2xhc3Nlcy5iYWNrZHJvcCwgXCItdGVzdC1pZFwiKSwgcm9sZTogXCJidXR0b25cIiwgdGFiSW5kZXg6IDAsIFwiYXJpYS1sYWJlbFwiOiBcImJhY2tkcm9wXCIsIG9uQ2xpY2s6IGhhbmRsZUJhY2tkcm9wQ2xpY2ssIG9uS2V5UHJlc3M6IGhhbmRsZUJhY2tkcm9wQ2xpY2ssIGNsYXNzTmFtZTogc2lkZWJhckNsYXNzZXMuYmFja2Ryb3AgfSkpKSkpO1xyXG59KTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkYSwgdGVtcGxhdGVPYmplY3RfMiQxLCB0ZW1wbGF0ZU9iamVjdF8zJDE7XG5cbnZhciBTdHlsZWRVbCA9IG5ld1N0eWxlZC51bCh0ZW1wbGF0ZU9iamVjdF8xJDkgfHwgKHRlbXBsYXRlT2JqZWN0XzEkOSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG5cIl0sIFtcIlxcbiAgbGlzdC1zdHlsZS10eXBlOiBub25lO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG5cIl0pKSk7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xJDk7XG5cbnZhciBTdHlsZWRNZW51ID0gbmV3U3R5bGVkLm5hdih0ZW1wbGF0ZU9iamVjdF8xJDggfHwgKHRlbXBsYXRlT2JqZWN0XzEkOCA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICBcIiwgXCJcXG4gIH1cXG5cIl0sIFtcIlxcbiAgJi5cIiwgXCIge1xcbiAgICBcIiwgXCJcXG4gIH1cXG5cIl0pKSwgbWVudUNsYXNzZXMucm9vdCwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBNZW51Q29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQodW5kZWZpbmVkKTtcclxudmFyIExldmVsQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQoMCk7XHJcbnZhciBNZW51RlIgPSBmdW5jdGlvbiAoX2EsIHJlZikge1xyXG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgX2IgPSBfYS50cmFuc2l0aW9uRHVyYXRpb24sIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9iID09PSB2b2lkIDAgPyAzMDAgOiBfYiwgX2MgPSBfYS5jbG9zZU9uQ2xpY2ssIGNsb3NlT25DbGljayA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCByb290U3R5bGVzID0gX2Eucm9vdFN0eWxlcywgbWVudUl0ZW1TdHlsZXMgPSBfYS5tZW51SXRlbVN0eWxlcywgcmVuZGVyRXhwYW5kSWNvbiA9IF9hLnJlbmRlckV4cGFuZEljb24sIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiY2xhc3NOYW1lXCIsIFwidHJhbnNpdGlvbkR1cmF0aW9uXCIsIFwiY2xvc2VPbkNsaWNrXCIsIFwicm9vdFN0eWxlc1wiLCBcIm1lbnVJdGVtU3R5bGVzXCIsIFwicmVuZGVyRXhwYW5kSWNvblwiXSk7XHJcbiAgICB2YXIgcHJvdmlkZXJWYWx1ZSA9IFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHsgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGNsb3NlT25DbGljazogY2xvc2VPbkNsaWNrLCBtZW51SXRlbVN0eWxlczogbWVudUl0ZW1TdHlsZXMsIHJlbmRlckV4cGFuZEljb246IHJlbmRlckV4cGFuZEljb24gfSk7IH0sIFt0cmFuc2l0aW9uRHVyYXRpb24sIGNsb3NlT25DbGljaywgbWVudUl0ZW1TdHlsZXMsIHJlbmRlckV4cGFuZEljb25dKTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZW51Q29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcHJvdmlkZXJWYWx1ZSB9LFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTGV2ZWxDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiAwIH0sXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudSwgX19hc3NpZ24oeyByZWY6IHJlZiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksIHJvb3RTdHlsZXM6IHJvb3RTdHlsZXMgfSwgcmVzdCksXHJcbiAgICAgICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFVsLCBudWxsLCBjaGlsZHJlbikpKSkpO1xyXG59O1xyXG52YXIgTWVudSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoTWVudUZSKTtcclxudmFyIHRlbXBsYXRlT2JqZWN0XzEkODtcblxudmFyIHVzZU1lbnUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgY29udGV4dCA9IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoTWVudUNvbnRleHQpO1xyXG4gICAgaWYgKGNvbnRleHQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vVE9ETzogc2V0IGJldHRlciBlcnJvciBtZXNzYWdlXHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNZW51IENvbXBvbmVudCBpcyByZXF1aXJlZCEnKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjb250ZXh0O1xyXG59O1xuXG52YXIgU3R5bGVkU3ViTWVudUNvbnRlbnQgPSBuZXdTdHlsZWQuZGl2KHRlbXBsYXRlT2JqZWN0XzEkNyB8fCAodGVtcGxhdGVPYmplY3RfMSQ3ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBkaXNwbGF5OiBub25lO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHotaW5kZXg6IDk5OTtcXG4gIHRyYW5zaXRpb246IGhlaWdodCBcIiwgXCJtcztcXG4gIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG5cXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIGRpc3BsYXk6IG5vbmU7XFxuICBvdmVyZmxvdzogaGlkZGVuO1xcbiAgei1pbmRleDogOTk5O1xcbiAgdHJhbnNpdGlvbjogaGVpZ2h0IFwiLCBcIm1zO1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcblxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2EudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgcmV0dXJuIHRyYW5zaXRpb25EdXJhdGlvbjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZDtcclxuICAgIHJldHVybiBmaXJzdExldmVsICYmXHJcbiAgICAgICAgY29sbGFwc2VkICYmXHJcbiAgICAgICAgXCJcXG4gICAgIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbiAgICAgYm94LXNoYWRvdzogMCAzcHggNnB4IC00cHggIzAwMDAwMDFmLCAwIDZweCAxNnB4ICMwMDAwMDAxNCwgMCA5cHggMjhweCA4cHggIzAwMDAwMDBkO1xcbiAgICAgXCI7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGRlZmF1bHRPcGVuID0gX2EuZGVmYXVsdE9wZW47XHJcbiAgICByZXR1cm4gZGVmYXVsdE9wZW4gJiYgJ2hlaWdodDogYXV0bztkaXNwbGF5OiBibG9jazsnO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIGZpcnN0TGV2ZWwgPSBfYS5maXJzdExldmVsLCBvcGVuV2hlbkNvbGxhcHNlZCA9IF9hLm9wZW5XaGVuQ29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIGNvbGxhcHNlZCAmJiBmaXJzdExldmVsXHJcbiAgICAgICAgPyBcIlxcbiAgICAgIHBvc2l0aW9uOiBmaXhlZDtcXG4gICAgICBwYWRkaW5nLWxlZnQ6IDBweDtcXG4gICAgICB3aWR0aDogMjAwcHg7XFxuICAgICAgYm9yZGVyLXJhZGl1czogNHB4O1xcbiAgICAgIGhlaWdodDogYXV0byFpbXBvcnRhbnQ7XFxuICAgICAgZGlzcGxheTogYmxvY2shaW1wb3J0YW50OyAgICAgXFxuICAgICAgdHJhbnNpdGlvbjogbm9uZSFpbXBvcnRhbnQ7ICAgICBcXG4gICAgICB2aXNpYmlsaXR5OiBcIi5jb25jYXQob3BlbldoZW5Db2xsYXBzZWQgPyAndmlzaWJsZScgOiAnaGlkZGVuJywgXCI7XFxuICAgICBcIilcclxuICAgICAgICA6IFwiXFxuICAgICAgcG9zaXRpb246IHN0YXRpYyFpbXBvcnRhbnQ7XFxuICAgICAgdHJhbnNmb3JtOiBub25lIWltcG9ydGFudDtcXG4gICAgICBcIjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBTdWJNZW51Q29udGVudEZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBvcGVuID0gX2Eub3Blbiwgb3BlbldoZW5Db2xsYXBzZWQgPSBfYS5vcGVuV2hlbkNvbGxhcHNlZCwgZmlyc3RMZXZlbCA9IF9hLmZpcnN0TGV2ZWwsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgZGVmYXVsdE9wZW4gPSBfYS5kZWZhdWx0T3BlbiwgcmVzdCA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJvcGVuXCIsIFwib3BlbldoZW5Db2xsYXBzZWRcIiwgXCJmaXJzdExldmVsXCIsIFwiY29sbGFwc2VkXCIsIFwiZGVmYXVsdE9wZW5cIl0pO1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IHVzZU1lbnUoKS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgZGVmYXVsdE9wZW5TdGF0ZSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGRlZmF1bHRPcGVuKVswXTtcclxuICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRTdWJNZW51Q29udGVudCwgX19hc3NpZ24oeyBcImRhdGEtdGVzdGlkXCI6IFwiXCIuY29uY2F0KG1lbnVDbGFzc2VzLnN1Yk1lbnVDb250ZW50LCBcIi10ZXN0LWlkXCIpLCByZWY6IHJlZiwgZmlyc3RMZXZlbDogZmlyc3RMZXZlbCwgY29sbGFwc2VkOiBjb2xsYXBzZWQsIG9wZW46IG9wZW4sIG9wZW5XaGVuQ29sbGFwc2VkOiBvcGVuV2hlbkNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiB0cmFuc2l0aW9uRHVyYXRpb24sIGRlZmF1bHRPcGVuOiBkZWZhdWx0T3BlblN0YXRlIH0sIHJlc3QpLFxyXG4gICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkVWwsIG51bGwsIGNoaWxkcmVuKSkpO1xyXG59O1xyXG52YXIgU3ViTWVudUNvbnRlbnQgPSBSZWFjdF9fZGVmYXVsdC5mb3J3YXJkUmVmKFN1Yk1lbnVDb250ZW50RlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ3O1xuXG52YXIgU3R5bGVkTWVudUxhYmVsID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMSQ2IHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDYgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIGZsZXgtZ3JvdzogMTtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuXFxuICBcIiwgXCI7XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ2O1xuXG52YXIgU3R5bGVkTWVudUljb24gPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDUgfHwgKHRlbXBsYXRlT2JqZWN0XzEkNSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDM1cHg7XFxuICBtaW4td2lkdGg6IDM1cHg7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBsaW5lLWhlaWdodDogMzVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cIl0sIFtcIlxcbiAgd2lkdGg6IDM1cHg7XFxuICBtaW4td2lkdGg6IDM1cHg7XFxuICBoZWlnaHQ6IDM1cHg7XFxuICBsaW5lLWhlaWdodDogMzVweDtcXG4gIHRleHQtYWxpZ246IGNlbnRlcjtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIGJvcmRlci1yYWRpdXM6IDJweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuXFxuICBcIiwgXCJcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIChydGwgPyAnbWFyZ2luLWxlZnQ6IDEwcHg7JyA6ICdtYXJnaW4tcmlnaHQ6IDEwcHg7Jyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ1O1xuXG52YXIgU3R5bGVkTWVudVByZWZpeCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzEkNCB8fCAodGVtcGxhdGVPYmplY3RfMSQ0ID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBcIiwgXCJcXG4gIG9wYWNpdHk6IFwiLCBcIjtcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgXCIsIFwibXM7XFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIFwiLCBcIlxcbiAgb3BhY2l0eTogXCIsIFwiO1xcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSBcIiwgXCJtcztcXG5cXG4gIFwiLCBcIjtcXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIChydGwgPyAnbWFyZ2luLWxlZnQ6IDVweDsnIDogJ21hcmdpbi1yaWdodDogNXB4OycpO1xyXG59LCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBmaXJzdExldmVsID0gX2EuZmlyc3RMZXZlbCwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIChmaXJzdExldmVsICYmIGNvbGxhcHNlZCA/ICcwJyA6ICcxJyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQ0O1xuXG52YXIgU3R5bGVkTWVudVN1ZmZpeCA9IG5ld1N0eWxlZC5zcGFuKHRlbXBsYXRlT2JqZWN0XzEkMyB8fCAodGVtcGxhdGVPYmplY3RfMSQzID0gX19tYWtlVGVtcGxhdGVPYmplY3QoW1wiXFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBvcGFjaXR5OiBcIiwgXCI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IFwiLCBcIm1zO1xcblxcbiAgXCIsIFwiO1xcblwiXSwgW1wiXFxuICBtYXJnaW4tcmlnaHQ6IDVweDtcXG4gIG1hcmdpbi1sZWZ0OiA1cHg7XFxuICBvcGFjaXR5OiBcIiwgXCI7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IFwiLCBcIm1zO1xcblxcbiAgXCIsIFwiO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBmaXJzdExldmVsID0gX2EuZmlyc3RMZXZlbCwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkO1xyXG4gICAgcmV0dXJuIChmaXJzdExldmVsICYmIGNvbGxhcHNlZCA/ICcwJyA6ICcxJyk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHRyYW5zaXRpb25EdXJhdGlvbiA9IF9hLnRyYW5zaXRpb25EdXJhdGlvbjtcclxuICAgIHJldHVybiB0cmFuc2l0aW9uRHVyYXRpb247XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0pO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQzO1xuXG52YXIgU3R5bGVkRXhwYW5kSWNvbldyYXBwZXIgPSBuZXdTdHlsZWQuc3Bhbih0ZW1wbGF0ZU9iamVjdF8xJDIgfHwgKHRlbXBsYXRlT2JqZWN0XzEkMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgXCIsIFwiXFxuXFxuICBcIiwgXCI7XFxuXCJdLCBbXCJcXG4gIFwiLCBcIlxcblxcbiAgXCIsIFwiO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIGxldmVsID0gX2EubGV2ZWwsIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiBjb2xsYXBzZWQgJiZcclxuICAgICAgICBsZXZlbCA9PT0gMCAmJlxyXG4gICAgICAgIFwiXFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgXCIuY29uY2F0KHJ0bCA/ICdsZWZ0OiAxMHB4OycgOiAncmlnaHQ6IDEwcHg7JywgXCJcXG4gICAgdG9wOiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNTAlKTtcXG4gICAgXFxuICAgIFwiKTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSk7XHJcbnZhciBTdHlsZWRFeHBhbmRJY29uID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMiB8fCAodGVtcGxhdGVPYmplY3RfMiA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3M7XFxuICBcIiwgXCJcXG5cXG4gIHdpZHRoOiA1cHg7XFxuICBoZWlnaHQ6IDVweDtcXG4gIHRyYW5zZm9ybTogcm90YXRlKFwiLCBcIik7XFxuXCJdLCBbXCJcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzO1xcbiAgXCIsIFwiXFxuXFxuICB3aWR0aDogNXB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICB0cmFuc2Zvcm06IHJvdGF0ZShcIiwgXCIpO1xcblwiXSkpLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBydGwgPSBfYS5ydGw7XHJcbiAgICByZXR1cm4gcnRsXHJcbiAgICAgICAgPyBcIlxcbiAgICAgICAgICBib3JkZXItbGVmdDogMnB4IHNvbGlkIGN1cnJlbnRjb2xvcjtcXG4gICAgICAgICAgYm9yZGVyLXRvcDogMnB4IHNvbGlkIGN1cnJlbnRjb2xvcjtcXG4gICAgICAgIFwiXHJcbiAgICAgICAgOiBcIiBib3JkZXItcmlnaHQ6IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCBjdXJyZW50Y29sb3I7XFxuICAgICAgICBcIjtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgb3BlbiA9IF9hLm9wZW4sIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiAob3BlbiA/IChydGwgPyAnLTEzNWRlZycgOiAnNDVkZWcnKSA6ICctNDVkZWcnKTtcclxufSk7XHJcbnZhciBTdHlsZWRFeHBhbmRJY29uQ29sbGFwc2VkID0gbmV3U3R5bGVkLnNwYW4odGVtcGxhdGVPYmplY3RfMyB8fCAodGVtcGxhdGVPYmplY3RfMyA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDVweDtcXG4gIGhlaWdodDogNXB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogY3VycmVudGNvbG9yO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcblwiXSwgW1wiXFxuICB3aWR0aDogNXB4O1xcbiAgaGVpZ2h0OiA1cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiBjdXJyZW50Y29sb3I7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XFxuXCJdKSkpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQyLCB0ZW1wbGF0ZU9iamVjdF8yLCB0ZW1wbGF0ZU9iamVjdF8zO1xuXG52YXIgdG9wID0gJ3RvcCc7XG52YXIgYm90dG9tID0gJ2JvdHRvbSc7XG52YXIgcmlnaHQgPSAncmlnaHQnO1xudmFyIGxlZnQgPSAnbGVmdCc7XG52YXIgYXV0byA9ICdhdXRvJztcbnZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xudmFyIHN0YXJ0ID0gJ3N0YXJ0JztcbnZhciBlbmQgPSAnZW5kJztcbnZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcbnZhciB2aWV3cG9ydCA9ICd2aWV3cG9ydCc7XG52YXIgcG9wcGVyID0gJ3BvcHBlcic7XG52YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XG52YXIgdmFyaWF0aW9uUGxhY2VtZW50cyA9IC8qI19fUFVSRV9fKi9iYXNlUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xufSwgW10pO1xudmFyIHBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovW10uY29uY2F0KGJhc2VQbGFjZW1lbnRzLCBbYXV0b10pLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbn0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cblxudmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XG52YXIgcmVhZCA9ICdyZWFkJztcbnZhciBhZnRlclJlYWQgPSAnYWZ0ZXJSZWFkJzsgLy8gcHVyZS1sb2dpYyBtb2RpZmllcnNcblxudmFyIGJlZm9yZU1haW4gPSAnYmVmb3JlTWFpbic7XG52YXIgbWFpbiA9ICdtYWluJztcbnZhciBhZnRlck1haW4gPSAnYWZ0ZXJNYWluJzsgLy8gbW9kaWZpZXIgd2l0aCB0aGUgcHVycG9zZSB0byB3cml0ZSB0byB0aGUgRE9NIChvciB3cml0ZSBpbnRvIGEgZnJhbWV3b3JrIHN0YXRlKVxuXG52YXIgYmVmb3JlV3JpdGUgPSAnYmVmb3JlV3JpdGUnO1xudmFyIHdyaXRlID0gJ3dyaXRlJztcbnZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xudmFyIG1vZGlmaWVyUGhhc2VzID0gW2JlZm9yZVJlYWQsIHJlYWQsIGFmdGVyUmVhZCwgYmVmb3JlTWFpbiwgbWFpbiwgYWZ0ZXJNYWluLCBiZWZvcmVXcml0ZSwgd3JpdGUsIGFmdGVyV3JpdGVdO1xuXG5mdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID8gKGVsZW1lbnQubm9kZU5hbWUgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XG4gICAgdmFyIG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBpc0VsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5FbGVtZW50O1xuICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQobm9kZSkge1xuICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcbn1cblxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgLy8gSUUgMTEgaGFzIG5vIFNoYWRvd1Jvb3RcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLlNoYWRvd1Jvb3Q7XG4gIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbn1cblxuLy8gYW5kIGFwcGxpZXMgdGhlbSB0byB0aGUgSFRNTEVsZW1lbnRzIHN1Y2ggYXMgcG9wcGVyIGFuZCBhcnJvd1xuXG5mdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGU7XG4gIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEZsb3cgZG9lc24ndCBzdXBwb3J0IHRvIGV4dGVuZCB0aGlzIHByb3BlcnR5LCBidXQgaXQncyB0aGUgbW9zdFxuICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdXG5cblxuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSA9PT0gdHJ1ZSA/ICcnIDogdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDIoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGU7XG4gIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgIHBvcHBlcjoge1xuICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXG4gICAgICBsZWZ0OiAnMCcsXG4gICAgICB0b3A6ICcwJyxcbiAgICAgIG1hcmdpbjogJzAnXG4gICAgfSxcbiAgICBhcnJvdzoge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge31cbiAgfTtcbiAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcblxuICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbbmFtZV07XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHN0YXRlLmF0dHJpYnV0ZXNbbmFtZV0gfHwge307XG4gICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdHlsZVtwcm9wZXJ0eV0gPSAnJztcbiAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcblxuICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xuICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBhcHBseVN0eWxlcyQxID0ge1xuICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ3dyaXRlJyxcbiAgZm46IGFwcGx5U3R5bGVzLFxuICBlZmZlY3Q6IGVmZmVjdCQyLFxuICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cbn07XG5cbmZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbn1cblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcblxuZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcblxuICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcykge1xuICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uYnJhbmQgKyBcIi9cIiArIGl0ZW0udmVyc2lvbjtcbiAgICB9KS5qb2luKCcgJyk7XG4gIH1cblxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cblxuZnVuY3Rpb24gaXNMYXlvdXRWaWV3cG9ydCgpIHtcbiAgcmV0dXJuICEvXigoPyFjaHJvbWV8YW5kcm9pZCkuKSpzYWZhcmkvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xufVxuXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcbiAgaWYgKGluY2x1ZGVTY2FsZSA9PT0gdm9pZCAwKSB7XG4gICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gIH1cblxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IDE7XG4gIHZhciBzY2FsZVkgPSAxO1xuXG4gIGlmIChpbmNsdWRlU2NhbGUgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xuICB9XG5cbiAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICB2aXN1YWxWaWV3cG9ydCA9IF9yZWYudmlzdWFsVmlld3BvcnQ7XG5cbiAgdmFyIGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICB2YXIgeSA9IChjbGllbnRSZWN0LnRvcCArIChhZGRWaXN1YWxPZmZzZXRzICYmIHZpc3VhbFZpZXdwb3J0ID8gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wIDogMCkpIC8gc2NhbGVZO1xuICB2YXIgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGVYO1xuICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHRvcDogeSxcbiAgICByaWdodDogeCArIHdpZHRoLFxuICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICBsZWZ0OiB4LFxuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuXG4vLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbmZ1bmN0aW9uIGdldExheW91dFJlY3QoZWxlbWVudCkge1xuICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXG4gIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gIHZhciB3aWR0aCA9IGVsZW1lbnQub2Zmc2V0V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBlbGVtZW50Lm9mZnNldEhlaWdodDtcblxuICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xuICB9XG5cbiAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHg6IGVsZW1lbnQub2Zmc2V0TGVmdCxcbiAgICB5OiBlbGVtZW50Lm9mZnNldFRvcCxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xuICB2YXIgcm9vdE5vZGUgPSBjaGlsZC5nZXRSb290Tm9kZSAmJiBjaGlsZC5nZXRSb290Tm9kZSgpOyAvLyBGaXJzdCwgYXR0ZW1wdCB3aXRoIGZhc3RlciBuYXRpdmUgbWV0aG9kXG5cbiAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxuICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICB2YXIgbmV4dCA9IGNoaWxkO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddOiBuZWVkIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcy4uLlxuXG5cbiAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICB9IHdoaWxlIChuZXh0KTtcbiAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KSB7XG4gIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICByZXR1cm4gWyd0YWJsZScsICd0ZCcsICd0aCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUoZWxlbWVudCkpID49IDA7XG59XG5cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGFzc3VtZSBib2R5IGlzIGFsd2F5cyBhdmFpbGFibGVcbiAgcmV0dXJuICgoaXNFbGVtZW50KGVsZW1lbnQpID8gZWxlbWVudC5vd25lckRvY3VtZW50IDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dXG4gICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICBlbGVtZW50LnBhcmVudE5vZGUgfHwgKCAvLyBET00gRWxlbWVudCBkZXRlY3RlZFxuICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpIC8vIGZhbGxiYWNrXG5cbiAgKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzgzN1xuICBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG59IC8vIGAub2Zmc2V0UGFyZW50YCByZXBvcnRzIGBudWxsYCBmb3IgZml4ZWQgZWxlbWVudHMsIHdoaWxlIGFic29sdXRlIGVsZW1lbnRzXG4vLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG5mdW5jdGlvbiBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkge1xuICB2YXIgaXNGaXJlZm94ID0gL2ZpcmVmb3gvaS50ZXN0KGdldFVBU3RyaW5nKCkpO1xuICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgLy8gSW4gSUUgOSwgMTAgYW5kIDExIGZpeGVkIGVsZW1lbnRzIGNvbnRhaW5pbmcgYmxvY2sgaXMgYWx3YXlzIGVzdGFibGlzaGVkIGJ5IHRoZSB2aWV3cG9ydFxuICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcblxuICAgIGlmIChlbGVtZW50Q3NzLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gIGlmIChpc1NoYWRvd1Jvb3QoY3VycmVudE5vZGUpKSB7XG4gICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS5ob3N0O1xuICB9XG5cbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xuICAgIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgLy8gY3JlYXRlIGEgY29udGFpbmluZyBibG9jay5cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9DU1MvQ29udGFpbmluZ19ibG9jayNpZGVudGlmeWluZ190aGVfY29udGFpbmluZ19ibG9ja1xuXG4gICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIEdldHMgdGhlIGNsb3Nlc3QgYW5jZXN0b3IgcG9zaXRpb25lZCBlbGVtZW50LiBIYW5kbGVzIHNvbWUgZWRnZSBjYXNlcyxcbi8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXG5cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldFRydWVPZmZzZXRQYXJlbnQoZWxlbWVudCk7XG5cbiAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICBpZiAob2Zmc2V0UGFyZW50ICYmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnaHRtbCcgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gJ2JvZHknICYmIGdldENvbXB1dGVkU3R5bGUob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICByZXR1cm4gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpID49IDAgPyAneCcgOiAneSc7XG59XG5cbmZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XG4gIHJldHVybiBtYXgobWluJDEsIG1pbih2YWx1ZSwgbWF4JDEpKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xuICB2YXIgdiA9IHdpdGhpbihtaW4sIHZhbHVlLCBtYXgpO1xuICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG59XG5cbmZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcbiAgcmV0dXJuIHtcbiAgICB0b3A6IDAsXG4gICAgcmlnaHQ6IDAsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VQYWRkaW5nT2JqZWN0KHBhZGRpbmdPYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGdldEZyZXNoU2lkZU9iamVjdCgpLCBwYWRkaW5nT2JqZWN0KTtcbn1cblxuZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XG4gIHJldHVybiBrZXlzLnJlZHVjZShmdW5jdGlvbiAoaGFzaE1hcCwga2V5KSB7XG4gICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgcmV0dXJuIGhhc2hNYXA7XG4gIH0sIHt9KTtcbn1cblxudmFyIHRvUGFkZGluZ09iamVjdCA9IGZ1bmN0aW9uIHRvUGFkZGluZ09iamVjdChwYWRkaW5nLCBzdGF0ZSkge1xuICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XG4gICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSkpIDogcGFkZGluZztcbiAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XG59O1xuXG5mdW5jdGlvbiBhcnJvdyhfcmVmKSB7XG4gIHZhciBfc3RhdGUkbW9kaWZpZXJzRGF0YSQ7XG5cbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zO1xuICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KTtcbiAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XG4gIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gIHZhciBhcnJvd1JlY3QgPSBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCk7XG4gIHZhciBtaW5Qcm9wID0gYXhpcyA9PT0gJ3knID8gdG9wIDogbGVmdDtcbiAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgdmFyIGVuZERpZmYgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbbGVuXSArIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXSAtIHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5wb3BwZXJbbGVuXTtcbiAgdmFyIHN0YXJ0RGlmZiA9IHBvcHBlck9mZnNldHNbYXhpc10gLSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc107XG4gIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICB2YXIgY2xpZW50U2l6ZSA9IGFycm93T2Zmc2V0UGFyZW50ID8gYXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50SGVpZ2h0IHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRXaWR0aCB8fCAwIDogMDtcbiAgdmFyIGNlbnRlclRvUmVmZXJlbmNlID0gZW5kRGlmZiAvIDIgLSBzdGFydERpZmYgLyAyOyAvLyBNYWtlIHN1cmUgdGhlIGFycm93IGRvZXNuJ3Qgb3ZlcmZsb3cgdGhlIHBvcHBlciBpZiB0aGUgY2VudGVyIHBvaW50IGlzXG4gIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcbiAgdmFyIG1heCA9IGNsaWVudFNpemUgLSBhcnJvd1JlY3RbbGVuXSAtIHBhZGRpbmdPYmplY3RbbWF4UHJvcF07XG4gIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXG5cbiAgdmFyIGF4aXNQcm9wID0gYXhpcztcbiAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbn1cblxuZnVuY3Rpb24gZWZmZWN0JDEoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJGVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQsXG4gICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gIGlmICh0eXBlb2YgYXJyb3dFbGVtZW50ID09PSAnc3RyaW5nJykge1xuICAgIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIGVsZW1lbnQgbXVzdCBiZSBhbiBIVE1MRWxlbWVudCAobm90IGFuIFNWR0VsZW1lbnQpLicsICdUbyB1c2UgYW4gU1ZHIGFycm93LCB3cmFwIGl0IGluIGFuIEhUTUxFbGVtZW50IHRoYXQgd2lsbCBiZSB1c2VkIGFzJywgJ3RoZSBhcnJvdy4nXS5qb2luKCcgJykpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghY29udGFpbnMoc3RhdGUuZWxlbWVudHMucG9wcGVyLCBhcnJvd0VsZW1lbnQpKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogXCJhcnJvd1wiIG1vZGlmaWVyXFwncyBgZWxlbWVudGAgbXVzdCBiZSBhIGNoaWxkIG9mIHRoZSBwb3BwZXInLCAnZWxlbWVudC4nXS5qb2luKCcgJykpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGFycm93JDEgPSB7XG4gIG5hbWU6ICdhcnJvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBhcnJvdyxcbiAgZWZmZWN0OiBlZmZlY3QkMSxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG59O1xuXG5mdW5jdGlvbiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbn1cblxudmFyIHVuc2V0U2lkZXMgPSB7XG4gIHRvcDogJ2F1dG8nLFxuICByaWdodDogJ2F1dG8nLFxuICBib3R0b206ICdhdXRvJyxcbiAgbGVmdDogJ2F1dG8nXG59OyAvLyBSb3VuZCB0aGUgb2Zmc2V0cyB0byB0aGUgbmVhcmVzdCBzdWl0YWJsZSBzdWJwaXhlbCBiYXNlZCBvbiB0aGUgRFBSLlxuLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcbi8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG5mdW5jdGlvbiByb3VuZE9mZnNldHNCeURQUihfcmVmKSB7XG4gIHZhciB4ID0gX3JlZi54LFxuICAgICAgeSA9IF9yZWYueTtcbiAgdmFyIHdpbiA9IHdpbmRvdztcbiAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gIHJldHVybiB7XG4gICAgeDogcm91bmQoeCAqIGRwcikgLyBkcHIgfHwgMCxcbiAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXG4gIH07XG59XG5cbmZ1bmN0aW9uIG1hcFRvU3R5bGVzKF9yZWYyKSB7XG4gIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcbiAgICAgIHBvcHBlclJlY3QgPSBfcmVmMi5wb3BwZXJSZWN0LFxuICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxuICAgICAgb2Zmc2V0cyA9IF9yZWYyLm9mZnNldHMsXG4gICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxuICAgICAgYWRhcHRpdmUgPSBfcmVmMi5hZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xuICB2YXIgX29mZnNldHMkeCA9IG9mZnNldHMueCxcbiAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXG4gICAgICB5ID0gX29mZnNldHMkeSA9PT0gdm9pZCAwID8gMCA6IF9vZmZzZXRzJHk7XG5cbiAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH0pIDoge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xuXG4gIHggPSBfcmVmMy54O1xuICB5ID0gX3JlZjMueTtcbiAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gIHZhciBoYXNZID0gb2Zmc2V0cy5oYXNPd25Qcm9wZXJ0eSgneScpO1xuICB2YXIgc2lkZVggPSBsZWZ0O1xuICB2YXIgc2lkZVkgPSB0b3A7XG4gIHZhciB3aW4gPSB3aW5kb3c7XG5cbiAgaWYgKGFkYXB0aXZlKSB7XG4gICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XG4gICAgdmFyIHdpZHRoUHJvcCA9ICdjbGllbnRXaWR0aCc7XG5cbiAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KHBvcHBlcik7XG5cbiAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgIGhlaWdodFByb3AgPSAnc2Nyb2xsSGVpZ2h0JztcbiAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcbiAgICAgIH1cbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhc3RdOiBmb3JjZSB0eXBlIHJlZmluZW1lbnQsIHdlIGNvbXBhcmUgb2Zmc2V0UGFyZW50IHdpdGggd2luZG93IGFib3ZlLCBidXQgRmxvdyBkb2Vzbid0IGRldGVjdCBpdFxuXG5cbiAgICBvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQ7XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgc2lkZVkgPSBib3R0b207XG4gICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgeSAtPSBvZmZzZXRZIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG5cbiAgICBpZiAocGxhY2VtZW50ID09PSBsZWZ0IHx8IChwbGFjZW1lbnQgPT09IHRvcCB8fCBwbGFjZW1lbnQgPT09IGJvdHRvbSkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcbiAgICAgIHNpZGVYID0gcmlnaHQ7XG4gICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICBvZmZzZXRQYXJlbnRbd2lkdGhQcm9wXTtcbiAgICAgIHggLT0gb2Zmc2V0WCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgcG9zaXRpb246IHBvc2l0aW9uXG4gIH0sIGFkYXB0aXZlICYmIHVuc2V0U2lkZXMpO1xuXG4gIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICB4OiB4LFxuICAgIHk6IHlcbiAgfSkgOiB7XG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG5cbiAgeCA9IF9yZWY0Lng7XG4gIHkgPSBfcmVmNC55O1xuXG4gIGlmIChncHVBY2NlbGVyYXRpb24pIHtcbiAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCAoX09iamVjdCRhc3NpZ24gPSB7fSwgX09iamVjdCRhc3NpZ25bc2lkZVldID0gaGFzWSA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbltzaWRlWF0gPSBoYXNYID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduLnRyYW5zZm9ybSA9ICh3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSA8PSAxID8gXCJ0cmFuc2xhdGUoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweClcIiA6IFwidHJhbnNsYXRlM2QoXCIgKyB4ICsgXCJweCwgXCIgKyB5ICsgXCJweCwgMClcIiwgX09iamVjdCRhc3NpZ24pKTtcbiAgfVxuXG4gIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XG4gIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgb3B0aW9ucyA9IF9yZWY1Lm9wdGlvbnM7XG4gIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcbiAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgIF9vcHRpb25zJGFkYXB0aXZlID0gb3B0aW9ucy5hZGFwdGl2ZSxcbiAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcbiAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgcm91bmRPZmZzZXRzID0gX29wdGlvbnMkcm91bmRPZmZzZXRzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcm91bmRPZmZzZXRzO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICB2YXIgdHJhbnNpdGlvblByb3BlcnR5ID0gZ2V0Q29tcHV0ZWRTdHlsZShzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLnRyYW5zaXRpb25Qcm9wZXJ0eSB8fCAnJztcblxuICAgIGlmIChhZGFwdGl2ZSAmJiBbJ3RyYW5zZm9ybScsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5zb21lKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRyYW5zaXRpb25Qcm9wZXJ0eS5pbmRleE9mKHByb3BlcnR5KSA+PSAwO1xuICAgIH0pKSB7XG4gICAgICBjb25zb2xlLndhcm4oWydQb3BwZXI6IERldGVjdGVkIENTUyB0cmFuc2l0aW9ucyBvbiBhdCBsZWFzdCBvbmUgb2YgdGhlIGZvbGxvd2luZycsICdDU1MgcHJvcGVydGllczogXCJ0cmFuc2Zvcm1cIiwgXCJ0b3BcIiwgXCJyaWdodFwiLCBcImJvdHRvbVwiLCBcImxlZnRcIi4nLCAnXFxuXFxuJywgJ0Rpc2FibGUgdGhlIFwiY29tcHV0ZVN0eWxlc1wiIG1vZGlmaWVyXFwncyBgYWRhcHRpdmVgIG9wdGlvbiB0byBhbGxvdycsICdmb3Igc21vb3RoIHRyYW5zaXRpb25zLCBvciByZW1vdmUgdGhlc2UgcHJvcGVydGllcyBmcm9tIHRoZSBDU1MnLCAndHJhbnNpdGlvbiBkZWNsYXJhdGlvbiBvbiB0aGUgcG9wcGVyIGVsZW1lbnQgaWYgb25seSB0cmFuc2l0aW9uaW5nJywgJ29wYWNpdHkgb3IgYmFja2dyb3VuZC1jb2xvciBmb3IgZXhhbXBsZS4nLCAnXFxuXFxuJywgJ1dlIHJlY29tbWVuZCB1c2luZyB0aGUgcG9wcGVyIGVsZW1lbnQgYXMgYSB3cmFwcGVyIGFyb3VuZCBhbiBpbm5lcicsICdlbGVtZW50IHRoYXQgY2FuIGhhdmUgYW55IENTUyBwcm9wZXJ0eSB0cmFuc2l0aW9uZWQgZm9yIGFuaW1hdGlvbnMuJ10uam9pbignICcpKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29tbW9uU3R5bGVzID0ge1xuICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgIHZhcmlhdGlvbjogZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCksXG4gICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXG4gICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgIGdwdUFjY2VsZXJhdGlvbjogZ3B1QWNjZWxlcmF0aW9uLFxuICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcbiAgfTtcblxuICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuc3R5bGVzLnBvcHBlciwgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICBwb3NpdGlvbjogc3RhdGUub3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIGFkYXB0aXZlOiBhZGFwdGl2ZSxcbiAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgfSkpKTtcbiAgfVxuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgb2Zmc2V0czogc3RhdGUubW9kaWZpZXJzRGF0YS5hcnJvdyxcbiAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgYWRhcHRpdmU6IGZhbHNlLFxuICAgICAgcm91bmRPZmZzZXRzOiByb3VuZE9mZnNldHNcbiAgICB9KSkpO1xuICB9XG5cbiAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xuICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgY29tcHV0ZVN0eWxlcyQxID0ge1xuICBuYW1lOiAnY29tcHV0ZVN0eWxlcycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnYmVmb3JlV3JpdGUnLFxuICBmbjogY29tcHV0ZVN0eWxlcyxcbiAgZGF0YToge31cbn07XG5cbnZhciBwYXNzaXZlID0ge1xuICBwYXNzaXZlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBlZmZlY3QoX3JlZikge1xuICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgaW5zdGFuY2UgPSBfcmVmLmluc3RhbmNlLFxuICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgc2Nyb2xsID0gX29wdGlvbnMkc2Nyb2xsID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkc2Nyb2xsLFxuICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXG4gICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gIHZhciB3aW5kb3cgPSBnZXRXaW5kb3coc3RhdGUuZWxlbWVudHMucG9wcGVyKTtcbiAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcblxuICBpZiAoc2Nyb2xsKSB7XG4gICAgc2Nyb2xsUGFyZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzY3JvbGxQYXJlbnQpIHtcbiAgICAgIHNjcm9sbFBhcmVudC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH0pO1xuICB9XG5cbiAgaWYgKHJlc2l6ZSkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cbiAgfTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBldmVudExpc3RlbmVycyA9IHtcbiAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICd3cml0ZScsXG4gIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICBlZmZlY3Q6IGVmZmVjdCxcbiAgZGF0YToge31cbn07XG5cbnZhciBoYXNoJDEgPSB7XG4gIGxlZnQ6ICdyaWdodCcsXG4gIHJpZ2h0OiAnbGVmdCcsXG4gIGJvdHRvbTogJ3RvcCcsXG4gIHRvcDogJ2JvdHRvbSdcbn07XG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xuICB9KTtcbn1cblxudmFyIGhhc2ggPSB7XG4gIHN0YXJ0OiAnZW5kJyxcbiAgZW5kOiAnc3RhcnQnXG59O1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvc3RhcnR8ZW5kL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IHdpbi5wYWdlWE9mZnNldDtcbiAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBzY3JvbGxMZWZ0LFxuICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAvLyBJZiA8aHRtbD4gaGFzIGEgQ1NTIHdpZHRoIGdyZWF0ZXIgdGhhbiB0aGUgdmlld3BvcnQsIHRoZW4gdGhpcyB3aWxsIGJlXG4gIC8vIGluY29ycmVjdCBmb3IgUlRMLlxuICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAvLyBpdCdzIG5vdCBhbiBpc3N1ZS4gSSBkb24ndCB0aGluayBhbnlvbmUgZXZlciBzcGVjaWZpZXMgd2lkdGggb24gPGh0bWw+XG4gIC8vIGFueXdheS5cbiAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgLy8gdGhpcyAoZS5nLiBFZGdlIDIwMTksIElFMTEsIFNhZmFyaSlcbiAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIHZhciB3aW4gPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgdmlzdWFsVmlld3BvcnQgPSB3aW4udmlzdWFsVmlld3BvcnQ7XG4gIHZhciB3aWR0aCA9IGh0bWwuY2xpZW50V2lkdGg7XG4gIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgdmFyIHggPSAwO1xuICB2YXIgeSA9IDA7XG5cbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gJ2ZpeGVkJykge1xuICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XG4gICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgIHk6IHlcbiAgfTtcbn1cblxuLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxuXG5mdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICB2YXIgd2luU2Nyb2xsID0gZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpO1xuICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgdmFyIHdpZHRoID0gbWF4KGh0bWwuc2Nyb2xsV2lkdGgsIGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LnNjcm9sbFdpZHRoIDogMCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKTtcbiAgdmFyIGhlaWdodCA9IG1heChodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQsIGJvZHkgPyBib2R5LnNjcm9sbEhlaWdodCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudEhlaWdodCA6IDApO1xuICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gIHZhciB5ID0gLXdpblNjcm9sbC5zY3JvbGxUb3A7XG5cbiAgaWYgKGdldENvbXB1dGVkU3R5bGUoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgeCArPSBtYXgoaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuY2xpZW50V2lkdGggOiAwKSAtIHdpZHRoO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgeDogeCxcbiAgICB5OiB5XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzU2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcblxuICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KG5vZGUpIHtcbiAgaWYgKFsnaHRtbCcsICdib2R5JywgJyNkb2N1bWVudCddLmluZGV4T2YoZ2V0Tm9kZU5hbWUobm9kZSkpID49IDApIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG59XG5cbi8qXG5naXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xudW50aWwgd2UgZ2V0IHRvIHRoZSB0b3Agd2luZG93IG9iamVjdC4gVGhpcyBsaXN0IGlzIHdoYXQgd2UgYXR0YWNoIHNjcm9sbCBsaXN0ZW5lcnNcbnRvLCBiZWNhdXNlIGlmIGFueSBvZiB0aGVzZSBwYXJlbnQgZWxlbWVudHMgc2Nyb2xsLCB3ZSdsbCBuZWVkIHRvIHJlLWNhbGN1bGF0ZSB0aGVcbnJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4qL1xuXG5mdW5jdGlvbiBsaXN0U2Nyb2xsUGFyZW50cyhlbGVtZW50LCBsaXN0KSB7XG4gIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuXG4gIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCk7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQgPT09ICgoX2VsZW1lbnQkb3duZXJEb2N1bWVuID0gZWxlbWVudC5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2VsZW1lbnQkb3duZXJEb2N1bWVuLmJvZHkpO1xuICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBbd2luXS5jb25jYXQod2luLnZpc3VhbFZpZXdwb3J0IHx8IFtdLCBpc1Njcm9sbFBhcmVudChzY3JvbGxQYXJlbnQpID8gc2Nyb2xsUGFyZW50IDogW10pIDogc2Nyb2xsUGFyZW50O1xuICB2YXIgdXBkYXRlZExpc3QgPSBsaXN0LmNvbmNhdCh0YXJnZXQpO1xuICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgdXBkYXRlZExpc3QuY29uY2F0KGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUodGFyZ2V0KSkpO1xufVxuXG5mdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgdG9wOiByZWN0LnksXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgcmVjdC50b3AgPSByZWN0LnRvcCArIGVsZW1lbnQuY2xpZW50VG9wO1xuICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgcmVjdC5yaWdodCA9IHJlY3QubGVmdCArIGVsZW1lbnQuY2xpZW50V2lkdGg7XG4gIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xuICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICByZWN0LnggPSByZWN0LmxlZnQ7XG4gIHJlY3QueSA9IHJlY3QudG9wO1xuICByZXR1cm4gcmVjdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSB7XG4gIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbn0gLy8gQSBcImNsaXBwaW5nIHBhcmVudFwiIGlzIGFuIG92ZXJmbG93YWJsZSBjb250YWluZXIgd2l0aCB0aGUgY2hhcmFjdGVyaXN0aWMgb2Zcbi8vIGNsaXBwaW5nIChvciBoaWRpbmcpIG92ZXJmbG93aW5nIGVsZW1lbnRzIHdpdGggYSBwb3NpdGlvbiBkaWZmZXJlbnQgZnJvbVxuLy8gYGluaXRpYWxgXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIHtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xuICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xuICB2YXIgY2xpcHBlckVsZW1lbnQgPSBjYW5Fc2NhcGVDbGlwcGluZyAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpID8gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIDogZWxlbWVudDtcblxuICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICByZXR1cm4gW107XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcblxuXG4gIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XG4gIH0pO1xufSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4vLyBjbGlwcGluZyBwYXJlbnRzXG5cblxuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdSZWN0KGVsZW1lbnQsIGJvdW5kYXJ5LCByb290Qm91bmRhcnksIHN0cmF0ZWd5KSB7XG4gIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IFtdLmNvbmNhdChtYWluQ2xpcHBpbmdQYXJlbnRzLCBbcm9vdEJvdW5kYXJ5XSk7XG4gIHZhciBmaXJzdENsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzWzBdO1xuICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICB2YXIgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgZmlyc3RDbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpKTtcbiAgY2xpcHBpbmdSZWN0LndpZHRoID0gY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQ7XG4gIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgY2xpcHBpbmdSZWN0LnggPSBjbGlwcGluZ1JlY3QubGVmdDtcbiAgY2xpcHBpbmdSZWN0LnkgPSBjbGlwcGluZ1JlY3QudG9wO1xuICByZXR1cm4gY2xpcHBpbmdSZWN0O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlT2Zmc2V0cyhfcmVmKSB7XG4gIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXG4gICAgICBwbGFjZW1lbnQgPSBfcmVmLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xuICB2YXIgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGVsZW1lbnQud2lkdGggLyAyO1xuICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gIHZhciBvZmZzZXRzO1xuXG4gIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xuICAgIGNhc2UgdG9wOlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBib3R0b206XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiBjb21tb25YLFxuICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcmlnaHQ6XG4gICAgICBvZmZzZXRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBsZWZ0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxuICAgICAgICB5OiBjb21tb25ZXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgb2Zmc2V0cyA9IHtcbiAgICAgICAgeDogcmVmZXJlbmNlLngsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICB9O1xuICB9XG5cbiAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgaWYgKG1haW5BeGlzICE9IG51bGwpIHtcbiAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICBjYXNlIHN0YXJ0OlxuICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdIC0gKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBlbmQ6XG4gICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gKyAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zJHBsYWNlbWVudCA9PT0gdm9pZCAwID8gc3RhdGUucGxhY2VtZW50IDogX29wdGlvbnMkcGxhY2VtZW50LFxuICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXG4gICAgICBfb3B0aW9ucyRib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucyRyb290Qm91bmRhcnkgPT09IHZvaWQgMCA/IHZpZXdwb3J0IDogX29wdGlvbnMkcm9vdEJvdW5kYXJ5LFxuICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxuICAgICAgX29wdGlvbnMkYWx0Qm91bmRhcnkgPSBfb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucyRwYWRkaW5nID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkcGFkZGluZztcbiAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XG4gIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xuICB2YXIgcmVmZXJlbmNlQ2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChzdGF0ZS5lbGVtZW50cy5yZWZlcmVuY2UpO1xuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXG4gICAgZWxlbWVudDogcG9wcGVyUmVjdCxcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KTtcbiAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgdmFyIGVsZW1lbnRDbGllbnRSZWN0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHBvcHBlckNsaWVudFJlY3QgOiByZWZlcmVuY2VDbGllbnRSZWN0OyAvLyBwb3NpdGl2ZSA9IG92ZXJmbG93aW5nIHRoZSBjbGlwcGluZyByZWN0XG4gIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcblxuICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgIHRvcDogY2xpcHBpbmdDbGllbnRSZWN0LnRvcCAtIGVsZW1lbnRDbGllbnRSZWN0LnRvcCArIHBhZGRpbmdPYmplY3QudG9wLFxuICAgIGJvdHRvbTogZWxlbWVudENsaWVudFJlY3QuYm90dG9tIC0gY2xpcHBpbmdDbGllbnRSZWN0LmJvdHRvbSArIHBhZGRpbmdPYmplY3QuYm90dG9tLFxuICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICByaWdodDogZWxlbWVudENsaWVudFJlY3QucmlnaHQgLSBjbGlwcGluZ0NsaWVudFJlY3QucmlnaHQgKyBwYWRkaW5nT2JqZWN0LnJpZ2h0XG4gIH07XG4gIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XG4gICAgdmFyIG9mZnNldCA9IG9mZnNldERhdGFbcGxhY2VtZW50XTtcbiAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xuICAgICAgdmFyIGF4aXMgPSBbdG9wLCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gJ3knIDogJ3gnO1xuICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwgb3B0aW9ucykge1xuICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG5cbiAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5ID0gX29wdGlvbnMuYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcbiAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMuZmxpcFZhcmlhdGlvbnMsXG4gICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XG4gIHZhciB2YXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KTtcbiAgdmFyIHBsYWNlbWVudHMkMSA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcbiAgfSkgOiBiYXNlUGxhY2VtZW50cztcbiAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcbiAgfSk7XG5cbiAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgY29uc29sZS5lcnJvcihbJ1BvcHBlcjogVGhlIGBhbGxvd2VkQXV0b1BsYWNlbWVudHNgIG9wdGlvbiBkaWQgbm90IGFsbG93IGFueScsICdwbGFjZW1lbnRzLiBFbnN1cmUgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbiBtYXRjaGVzIHRoZSB2YXJpYXRpb24nLCAnb2YgdGhlIGFsbG93ZWQgcGxhY2VtZW50cy4nLCAnRm9yIGV4YW1wbGUsIFwiYXV0b1wiIGNhbm5vdCBiZSB1c2VkIHRvIGFsbG93IFwiYm90dG9tLXN0YXJ0XCIuJywgJ1VzZSBcImF1dG8tc3RhcnRcIiBpbnN0ZWFkLiddLmpvaW4oJyAnKSk7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXG5cblxuICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nXG4gICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCB7fSk7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMocGxhY2VtZW50KSB7XG4gIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgb3Bwb3NpdGVQbGFjZW1lbnQgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xufVxuXG5mdW5jdGlvbiBmbGlwKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgX29wdGlvbnMkYWx0QXhpcyA9IG9wdGlvbnMuYWx0QXhpcyxcbiAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgc3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzID0gb3B0aW9ucy5mYWxsYmFja1BsYWNlbWVudHMsXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgZmxpcFZhcmlhdGlvbnMgPSBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRmbGlwVmFyaWF0aW8sXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBvcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cztcbiAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocHJlZmVycmVkUGxhY2VtZW50KTtcbiAgdmFyIGlzQmFzZVBsYWNlbWVudCA9IGJhc2VQbGFjZW1lbnQgPT09IHByZWZlcnJlZFBsYWNlbWVudDtcbiAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICB2YXIgcGxhY2VtZW50cyA9IFtwcmVmZXJyZWRQbGFjZW1lbnRdLmNvbmNhdChmYWxsYmFja1BsYWNlbWVudHMpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gYWNjLmNvbmNhdChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8gPyBjb21wdXRlQXV0b1BsYWNlbWVudChzdGF0ZSwge1xuICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICBmbGlwVmFyaWF0aW9uczogZmxpcFZhcmlhdGlvbnMsXG4gICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHM6IGFsbG93ZWRBdXRvUGxhY2VtZW50c1xuICAgIH0pIDogcGxhY2VtZW50KTtcbiAgfSwgW10pO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciBjaGVja3NNYXAgPSBuZXcgTWFwKCk7XG4gIHZhciBtYWtlRmFsbGJhY2tDaGVja3MgPSB0cnVlO1xuICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGxhY2VtZW50ID0gcGxhY2VtZW50c1tpXTtcblxuICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBpc1N0YXJ0VmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHN0YXJ0O1xuICAgIHZhciBpc1ZlcnRpY2FsID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKF9iYXNlUGxhY2VtZW50KSA+PSAwO1xuICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIHZhciBvdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5LFxuICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgIH0pO1xuICAgIHZhciBtYWluVmFyaWF0aW9uU2lkZSA9IGlzVmVydGljYWwgPyBpc1N0YXJ0VmFyaWF0aW9uID8gcmlnaHQgOiBsZWZ0IDogaXNTdGFydFZhcmlhdGlvbiA/IGJvdHRvbSA6IHRvcDtcblxuICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIH1cblxuICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgIHZhciBjaGVja3MgPSBbXTtcblxuICAgIGlmIChjaGVja01haW5BeGlzKSB7XG4gICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgIH1cblxuICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XG4gICAgICByZXR1cm4gY2hlY2s7XG4gICAgfSkpIHtcbiAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcbiAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gIH1cblxuICBpZiAobWFrZUZhbGxiYWNrQ2hlY2tzKSB7XG4gICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcblxuICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XG4gICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBjaGVja3MgPSBjaGVja3NNYXAuZ2V0KHBsYWNlbWVudCk7XG5cbiAgICAgICAgaWYgKGNoZWNrcykge1xuICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKGZpdHRpbmdQbGFjZW1lbnQpIHtcbiAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgX2kgPSBudW1iZXJPZkNoZWNrczsgX2kgPiAwOyBfaS0tKSB7XG4gICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcblxuICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XG4gICAgc3RhdGUucGxhY2VtZW50ID0gZmlyc3RGaXR0aW5nUGxhY2VtZW50O1xuICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgfVxufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIGZsaXAkMSA9IHtcbiAgbmFtZTogJ2ZsaXAnLFxuICBlbmFibGVkOiB0cnVlLFxuICBwaGFzZTogJ21haW4nLFxuICBmbjogZmxpcCxcbiAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgZGF0YToge1xuICAgIF9za2lwOiBmYWxzZVxuICB9XG59O1xuXG5mdW5jdGlvbiBnZXRTaWRlT2Zmc2V0cyhvdmVyZmxvdywgcmVjdCwgcHJldmVudGVkT2Zmc2V0cykge1xuICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgcHJldmVudGVkT2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcbiAgICByaWdodDogb3ZlcmZsb3cucmlnaHQgLSByZWN0LndpZHRoICsgcHJldmVudGVkT2Zmc2V0cy54LFxuICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcbiAgfTtcbn1cblxuZnVuY3Rpb24gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKG92ZXJmbG93KSB7XG4gIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XG4gICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgdmFyIHByZXZlbnRlZE9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnByZXZlbnRPdmVyZmxvdztcbiAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBlbGVtZW50Q29udGV4dDogJ3JlZmVyZW5jZSdcbiAgfSk7XG4gIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgYWx0Qm91bmRhcnk6IHRydWVcbiAgfSk7XG4gIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gIHZhciBwb3BwZXJFc2NhcGVPZmZzZXRzID0gZ2V0U2lkZU9mZnNldHMocG9wcGVyQWx0T3ZlcmZsb3csIHBvcHBlclJlY3QsIHByZXZlbnRlZE9mZnNldHMpO1xuICB2YXIgaXNSZWZlcmVuY2VIaWRkZW4gPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzKTtcbiAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSB7XG4gICAgcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzOiByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMsXG4gICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICBpc1JlZmVyZW5jZUhpZGRlbjogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgaGFzUG9wcGVyRXNjYXBlZDogaGFzUG9wcGVyRXNjYXBlZFxuICB9O1xuICBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyLCB7XG4gICAgJ2RhdGEtcG9wcGVyLXJlZmVyZW5jZS1oaWRkZW4nOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgfSk7XG59IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG52YXIgaGlkZSQxID0ge1xuICBuYW1lOiAnaGlkZScsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsncHJldmVudE92ZXJmbG93J10sXG4gIGZuOiBoaWRlXG59O1xuXG5mdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciBpbnZlcnREaXN0YW5jZSA9IFtsZWZ0LCB0b3BdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IC0xIDogMTtcblxuICB2YXIgX3JlZiA9IHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicgPyBvZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgcmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICB9KSkgOiBvZmZzZXQsXG4gICAgICBza2lkZGluZyA9IF9yZWZbMF0sXG4gICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xuICBkaXN0YW5jZSA9IChkaXN0YW5jZSB8fCAwKSAqIGludmVydERpc3RhbmNlO1xuICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgeDogZGlzdGFuY2UsXG4gICAgeTogc2tpZGRpbmdcbiAgfSA6IHtcbiAgICB4OiBza2lkZGluZyxcbiAgICB5OiBkaXN0YW5jZVxuICB9O1xufVxuXG5mdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcbiAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICBvcHRpb25zID0gX3JlZjIub3B0aW9ucyxcbiAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xuICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICBvZmZzZXQgPSBfb3B0aW9ucyRvZmZzZXQgPT09IHZvaWQgMCA/IFswLCAwXSA6IF9vcHRpb25zJG9mZnNldDtcbiAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcbiAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgcmV0dXJuIGFjYztcbiAgfSwge30pO1xuICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgeCA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC54LFxuICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xuXG4gIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy54ICs9IHg7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnkgKz0geTtcbiAgfVxuXG4gIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xufSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxudmFyIG9mZnNldCQxID0ge1xuICBuYW1lOiAnb2Zmc2V0JyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdtYWluJyxcbiAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxuICBmbjogb2Zmc2V0XG59O1xuXG5mdW5jdGlvbiBwb3BwZXJPZmZzZXRzKF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XG4gIC8vIE9mZnNldHMgYXJlIHRoZSBhY3R1YWwgcG9zaXRpb24gdGhlIHBvcHBlciBuZWVkcyB0byBoYXZlIHRvIGJlXG4gIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgLy8gVGhpcyBpcyB0aGUgbW9zdCBiYXNpYyBwbGFjZW1lbnQsIGFuZCB3aWxsIGJlIGFkanVzdGVkIGJ5XG4gIC8vIHRoZSBtb2RpZmllcnMgaW4gdGhlIG5leHQgc3RlcFxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgIHJlZmVyZW5jZTogc3RhdGUucmVjdHMucmVmZXJlbmNlLFxuICAgIGVsZW1lbnQ6IHN0YXRlLnJlY3RzLnBvcHBlcixcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwb3BwZXJPZmZzZXRzJDEgPSB7XG4gIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgZW5hYmxlZDogdHJ1ZSxcbiAgcGhhc2U6ICdyZWFkJyxcbiAgZm46IHBvcHBlck9mZnNldHMsXG4gIGRhdGE6IHt9XG59O1xuXG5mdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgcmV0dXJuIGF4aXMgPT09ICd4JyA/ICd5JyA6ICd4Jztcbn1cblxuZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxuICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICBwYWRkaW5nID0gb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXG4gICAgICBfb3B0aW9ucyR0ZXRoZXJPZmZzZXQgPSBvcHRpb25zLnRldGhlck9mZnNldCxcbiAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICBib3VuZGFyeTogYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgcGFkZGluZzogcGFkZGluZyxcbiAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnlcbiAgfSk7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xuICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHN0YXRlLnBsYWNlbWVudCk7XG4gIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gIHZhciBhbHRBeGlzID0gZ2V0QWx0QXhpcyhtYWluQXhpcyk7XG4gIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcbiAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxuICB9KSkgOiB0ZXRoZXJPZmZzZXQ7XG4gIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcbiAgICBhbHRBeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZVxuICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgbWFpbkF4aXM6IDAsXG4gICAgYWx0QXhpczogMFxuICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcbiAgdmFyIGRhdGEgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICB2YXIgX29mZnNldE1vZGlmaWVyU3RhdGUkO1xuXG4gICAgdmFyIG1haW5TaWRlID0gbWFpbkF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG9mZnNldCA9IHBvcHBlck9mZnNldHNbbWFpbkF4aXNdO1xuICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcbiAgICB2YXIgYWRkaXRpdmUgPSB0ZXRoZXIgPyAtcG9wcGVyUmVjdFtsZW5dIC8gMiA6IDA7XG4gICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cbiAgICAvLyBvdXRzaWRlIHRoZSByZWZlcmVuY2UgYm91bmRzXG5cbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIGFycm93UmVjdCA9IHRldGhlciAmJiBhcnJvd0VsZW1lbnQgPyBnZXRMYXlvdXRSZWN0KGFycm93RWxlbWVudCkgOiB7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMFxuICAgIH07XG4gICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XG4gICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgdmFyIGFycm93UGFkZGluZ01heCA9IGFycm93UGFkZGluZ09iamVjdFthbHRTaWRlXTsgLy8gSWYgdGhlIHJlZmVyZW5jZSBsZW5ndGggaXMgc21hbGxlciB0aGFuIHRoZSBhcnJvdyBsZW5ndGgsIHdlIGRvbid0IHdhbnRcbiAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXG4gICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAvLyByZWZlcmVuY2UgaXMgbm90IG92ZXJmbG93aW5nIGFzIHdlbGwgKGUuZy4gdmlydHVhbCBlbGVtZW50cyB3aXRoIG5vXG4gICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxuXG4gICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgIHZhciBtaW5PZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gLyAyIC0gYWRkaXRpdmUgLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1pbkxlbiAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xuICAgIHZhciBtYXhPZmZzZXQgPSBpc0Jhc2VQbGFjZW1lbnQgPyAtcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiArIGFkZGl0aXZlICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtYXhMZW4gKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcbiAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgIHZhciBjbGllbnRPZmZzZXQgPSBhcnJvd09mZnNldFBhcmVudCA/IG1haW5BeGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRUb3AgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudExlZnQgfHwgMCA6IDA7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyVmFsdWUgPSAoX29mZnNldE1vZGlmaWVyU3RhdGUkID0gb2Zmc2V0TW9kaWZpZXJTdGF0ZSA9PSBudWxsID8gdm9pZCAwIDogb2Zmc2V0TW9kaWZpZXJTdGF0ZVttYWluQXhpc10pICE9IG51bGwgPyBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgOiAwO1xuICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgIHZhciB0ZXRoZXJNYXggPSBvZmZzZXQgKyBtYXhPZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXQgPSB3aXRoaW4odGV0aGVyID8gbWluKG1pbiQxLCB0ZXRoZXJNaW4pIDogbWluJDEsIG9mZnNldCwgdGV0aGVyID8gbWF4KG1heCQxLCB0ZXRoZXJNYXgpIDogbWF4JDEpO1xuICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgIGRhdGFbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0IC0gb2Zmc2V0O1xuICB9XG5cbiAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xuXG4gICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xuXG4gICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xuXG4gICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xuXG4gICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xuXG4gICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcblxuICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcbiAgICBkYXRhW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldCAtIF9vZmZzZXQ7XG4gIH1cblxuICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gZGF0YTtcbn0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbnZhciBwcmV2ZW50T3ZlcmZsb3ckMSA9IHtcbiAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXG4gIGVuYWJsZWQ6IHRydWUsXG4gIHBoYXNlOiAnbWFpbicsXG4gIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbn07XG5cbmZ1bmN0aW9uIGdldEhUTUxFbGVtZW50U2Nyb2xsKGVsZW1lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXG4gICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgIHJldHVybiBnZXRXaW5kb3dTY3JvbGwobm9kZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gIHZhciByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgdmFyIHNjYWxlWCA9IHJvdW5kKHJlY3Qud2lkdGgpIC8gZWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxO1xuICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgcmV0dXJuIHNjYWxlWCAhPT0gMSB8fCBzY2FsZVkgIT09IDE7XG59IC8vIFJldHVybnMgdGhlIGNvbXBvc2l0ZSByZWN0IG9mIGFuIGVsZW1lbnQgcmVsYXRpdmUgdG8gaXRzIG9mZnNldFBhcmVudC5cbi8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG5mdW5jdGlvbiBnZXRDb21wb3NpdGVSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnQsIGlzRml4ZWQpIHtcbiAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xuICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnRPclZpcnR1YWxFbGVtZW50LCBvZmZzZXRQYXJlbnRJc1NjYWxlZCwgaXNGaXhlZCk7XG4gIHZhciBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgdmFyIG9mZnNldHMgPSB7XG4gICAgeDogMCxcbiAgICB5OiAwXG4gIH07XG5cbiAgaWYgKGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50IHx8ICFpc09mZnNldFBhcmVudEFuRWxlbWVudCAmJiAhaXNGaXhlZCkge1xuICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcbiAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSArPSBvZmZzZXRQYXJlbnQuY2xpZW50VG9wO1xuICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuXG5mdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcbiAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XG5cbiAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xuICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgIHZhciByZXF1aXJlcyA9IFtdLmNvbmNhdChtb2RpZmllci5yZXF1aXJlcyB8fCBbXSwgbW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cyB8fCBbXSk7XG4gICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgdmFyIGRlcE1vZGlmaWVyID0gbWFwLmdldChkZXApO1xuXG4gICAgICAgIGlmIChkZXBNb2RpZmllcikge1xuICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVzdWx0LnB1c2gobW9kaWZpZXIpO1xuICB9XG5cbiAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIHZpc2l0ZWQgb2JqZWN0XG4gICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcbiAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXIobW9kaWZpZXJzKTsgLy8gb3JkZXIgYmFzZWQgb24gcGhhc2VcblxuICByZXR1cm4gbW9kaWZpZXJQaGFzZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBoYXNlKSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICByZXR1cm4gbW9kaWZpZXIucGhhc2UgPT09IHBoYXNlO1xuICAgIH0pKTtcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbikge1xuICB2YXIgcGVuZGluZztcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXBlbmRpbmcpIHtcbiAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBwZW5kaW5nID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBlbmRpbmc7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdChzdHIpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICB9XG5cbiAgcmV0dXJuIFtdLmNvbmNhdChhcmdzKS5yZWR1Y2UoZnVuY3Rpb24gKHAsIGMpIHtcbiAgICByZXR1cm4gcC5yZXBsYWNlKC8lcy8sIGMpO1xuICB9LCBzdHIpO1xufVxuXG52YXIgSU5WQUxJRF9NT0RJRklFUl9FUlJPUiA9ICdQb3BwZXI6IG1vZGlmaWVyIFwiJXNcIiBwcm92aWRlZCBhbiBpbnZhbGlkICVzIHByb3BlcnR5LCBleHBlY3RlZCAlcyBidXQgZ290ICVzJztcbnZhciBNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IgPSAnUG9wcGVyOiBtb2RpZmllciBcIiVzXCIgcmVxdWlyZXMgXCIlc1wiLCBidXQgXCIlc1wiIG1vZGlmaWVyIGlzIG5vdCBhdmFpbGFibGUnO1xudmFyIFZBTElEX1BST1BFUlRJRVMgPSBbJ25hbWUnLCAnZW5hYmxlZCcsICdwaGFzZScsICdmbicsICdlZmZlY3QnLCAncmVxdWlyZXMnLCAnb3B0aW9ucyddO1xuZnVuY3Rpb24gdmFsaWRhdGVNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIFtdLmNvbmNhdChPYmplY3Qua2V5cyhtb2RpZmllciksIFZBTElEX1BST1BFUlRJRVMpIC8vIElFMTEtY29tcGF0aWJsZSByZXBsYWNlbWVudCBmb3IgYG5ldyBTZXQoaXRlcmFibGUpYFxuICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlLCBpbmRleCwgc2VsZikge1xuICAgICAgcmV0dXJuIHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4O1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgICAgaWYgKHR5cGVvZiBtb2RpZmllci5uYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgU3RyaW5nKG1vZGlmaWVyLm5hbWUpLCAnXCJuYW1lXCInLCAnXCJzdHJpbmdcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLm5hbWUpICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdlbmFibGVkJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmVuYWJsZWQgIT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZW5hYmxlZFwiJywgJ1wiYm9vbGVhblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZW5hYmxlZCkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ3BoYXNlJzpcbiAgICAgICAgICBpZiAobW9kaWZpZXJQaGFzZXMuaW5kZXhPZihtb2RpZmllci5waGFzZSkgPCAwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJwaGFzZVwiJywgXCJlaXRoZXIgXCIgKyBtb2RpZmllclBoYXNlcy5qb2luKCcsICcpLCBcIlxcXCJcIiArIFN0cmluZyhtb2RpZmllci5waGFzZSkgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2ZuJzpcbiAgICAgICAgICBpZiAodHlwZW9mIG1vZGlmaWVyLmZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJmblwiJywgJ1wiZnVuY3Rpb25cIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLmZuKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZWZmZWN0JzpcbiAgICAgICAgICBpZiAobW9kaWZpZXIuZWZmZWN0ICE9IG51bGwgJiYgdHlwZW9mIG1vZGlmaWVyLmVmZmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihmb3JtYXQoSU5WQUxJRF9NT0RJRklFUl9FUlJPUiwgbW9kaWZpZXIubmFtZSwgJ1wiZWZmZWN0XCInLCAnXCJmdW5jdGlvblwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIuZm4pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdyZXF1aXJlcyc6XG4gICAgICAgICAgaWYgKG1vZGlmaWVyLnJlcXVpcmVzICE9IG51bGwgJiYgIUFycmF5LmlzQXJyYXkobW9kaWZpZXIucmVxdWlyZXMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc1wiJywgJ1wiYXJyYXlcIicsIFwiXFxcIlwiICsgU3RyaW5nKG1vZGlmaWVyLnJlcXVpcmVzKSArIFwiXFxcIlwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAncmVxdWlyZXNJZkV4aXN0cyc6XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGlmaWVyLnJlcXVpcmVzSWZFeGlzdHMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChJTlZBTElEX01PRElGSUVSX0VSUk9SLCBtb2RpZmllci5uYW1lLCAnXCJyZXF1aXJlc0lmRXhpc3RzXCInLCAnXCJhcnJheVwiJywgXCJcXFwiXCIgKyBTdHJpbmcobW9kaWZpZXIucmVxdWlyZXNJZkV4aXN0cykgKyBcIlxcXCJcIikpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ29wdGlvbnMnOlxuICAgICAgICBjYXNlICdkYXRhJzpcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQb3BwZXJKUzogYW4gaW52YWxpZCBwcm9wZXJ0eSBoYXMgYmVlbiBwcm92aWRlZCB0byB0aGUgXFxcIlwiICsgbW9kaWZpZXIubmFtZSArIFwiXFxcIiBtb2RpZmllciwgdmFsaWQgcHJvcGVydGllcyBhcmUgXCIgKyBWQUxJRF9QUk9QRVJUSUVTLm1hcChmdW5jdGlvbiAocykge1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxcIlwiICsgcyArIFwiXFxcIlwiO1xuICAgICAgICAgIH0pLmpvaW4oJywgJykgKyBcIjsgYnV0IFxcXCJcIiArIGtleSArIFwiXFxcIiB3YXMgcHJvdmlkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBtb2RpZmllci5yZXF1aXJlcyAmJiBtb2RpZmllci5yZXF1aXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyZXF1aXJlbWVudCkge1xuICAgICAgICBpZiAobW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKG1vZCkge1xuICAgICAgICAgIHJldHVybiBtb2QubmFtZSA9PT0gcmVxdWlyZW1lbnQ7XG4gICAgICAgIH0pID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKGZvcm1hdChNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IsIFN0cmluZyhtb2RpZmllci5uYW1lKSwgcmVxdWlyZW1lbnQsIHJlcXVpcmVtZW50KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5pcXVlQnkoYXJyLCBmbikge1xuICB2YXIgaWRlbnRpZmllcnMgPSBuZXcgU2V0KCk7XG4gIHJldHVybiBhcnIuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBmbihpdGVtKTtcblxuICAgIGlmICghaWRlbnRpZmllcnMuaGFzKGlkZW50aWZpZXIpKSB7XG4gICAgICBpZGVudGlmaWVycy5hZGQoaWRlbnRpZmllcik7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcbiAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgIHZhciBleGlzdGluZyA9IG1lcmdlZFtjdXJyZW50Lm5hbWVdO1xuICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xuICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLmRhdGEsIGN1cnJlbnQuZGF0YSlcbiAgICB9KSA6IGN1cnJlbnQ7XG4gICAgcmV0dXJuIG1lcmdlZDtcbiAgfSwge30pOyAvLyBJRTExIGRvZXMgbm90IHN1cHBvcnQgT2JqZWN0LnZhbHVlc1xuXG4gIHJldHVybiBPYmplY3Qua2V5cyhtZXJnZWQpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICB9KTtcbn1cblxudmFyIElOVkFMSURfRUxFTUVOVF9FUlJPUiA9ICdQb3BwZXI6IEludmFsaWQgcmVmZXJlbmNlIG9yIHBvcHBlciBhcmd1bWVudCBwcm92aWRlZC4gVGhleSBtdXN0IGJlIGVpdGhlciBhIERPTSBlbGVtZW50IG9yIHZpcnR1YWwgZWxlbWVudC4nO1xudmFyIElORklOSVRFX0xPT1BfRVJST1IgPSAnUG9wcGVyOiBBbiBpbmZpbml0ZSBsb29wIGluIHRoZSBtb2RpZmllcnMgY3ljbGUgaGFzIGJlZW4gZGV0ZWN0ZWQhIFRoZSBjeWNsZSBoYXMgYmVlbiBpbnRlcnJ1cHRlZCB0byBwcmV2ZW50IGEgYnJvd3NlciBjcmFzaC4nO1xudmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgcGxhY2VtZW50OiAnYm90dG9tJyxcbiAgbW9kaWZpZXJzOiBbXSxcbiAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbn07XG5cbmZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHJldHVybiAhKGVsZW1lbnQgJiYgdHlwZW9mIGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ID09PSAnZnVuY3Rpb24nKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XG4gIGlmIChnZW5lcmF0b3JPcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gIH1cblxuICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgIGRlZmF1bHRNb2RpZmllcnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYgPT09IHZvaWQgMCA/IFtdIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmLFxuICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxuICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICByZXR1cm4gZnVuY3Rpb24gY3JlYXRlUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xuICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICBvcmRlcmVkTW9kaWZpZXJzOiBbXSxcbiAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRfT1BUSU9OUywgZGVmYXVsdE9wdGlvbnMpLFxuICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICBlbGVtZW50czoge1xuICAgICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICAgIHN0eWxlczoge31cbiAgICB9O1xuICAgIHZhciBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgdmFyIGluc3RhbmNlID0ge1xuICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gdHlwZW9mIHNldE9wdGlvbnNBY3Rpb24gPT09ICdmdW5jdGlvbicgPyBzZXRPcHRpb25zQWN0aW9uKHN0YXRlLm9wdGlvbnMpIDogc2V0T3B0aW9uc0FjdGlvbjtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0ge1xuICAgICAgICAgIHJlZmVyZW5jZTogaXNFbGVtZW50KHJlZmVyZW5jZSkgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UpIDogcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlLmNvbnRleHRFbGVtZW50KSA6IFtdLFxuICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICB9OyAvLyBPcmRlcnMgdGhlIG1vZGlmaWVycyBiYXNlZCBvbiB0aGVpciBkZXBlbmRlbmNpZXMgYW5kIGBwaGFzZWBcbiAgICAgICAgLy8gcHJvcGVydGllc1xuXG4gICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycyA9IG9yZGVyZWRNb2RpZmllcnMuZmlsdGVyKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcbiAgICAgICAgfSk7IC8vIFZhbGlkYXRlIHRoZSBwcm92aWRlZCBtb2RpZmllcnMgc28gdGhhdCB0aGUgY29uc3VtZXIgd2lsbCBnZXQgd2FybmVkXG4gICAgICAgIC8vIGlmIG9uZSBvZiB0aGUgbW9kaWZpZXJzIGlzIGludmFsaWQgZm9yIGFueSByZWFzb25cblxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgdmFyIG1vZGlmaWVycyA9IHVuaXF1ZUJ5KFtdLmNvbmNhdChvcmRlcmVkTW9kaWZpZXJzLCBzdGF0ZS5vcHRpb25zLm1vZGlmaWVycyksIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhbGlkYXRlTW9kaWZpZXJzKG1vZGlmaWVycyk7XG5cbiAgICAgICAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5vcHRpb25zLnBsYWNlbWVudCkgPT09IGF1dG8pIHtcbiAgICAgICAgICAgIHZhciBmbGlwTW9kaWZpZXIgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZpbmQoZnVuY3Rpb24gKF9yZWYyKSB7XG4gICAgICAgICAgICAgIHZhciBuYW1lID0gX3JlZjIubmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdmbGlwJztcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoIWZsaXBNb2RpZmllcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFsnUG9wcGVyOiBcImF1dG9cIiBwbGFjZW1lbnRzIHJlcXVpcmUgdGhlIFwiZmxpcFwiIG1vZGlmaWVyIGJlJywgJ3ByZXNlbnQgYW5kIGVuYWJsZWQgdG8gd29yay4nXS5qb2luKCcgJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfZ2V0Q29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUocG9wcGVyKSxcbiAgICAgICAgICAgICAgbWFyZ2luVG9wID0gX2dldENvbXB1dGVkU3R5bGUubWFyZ2luVG9wLFxuICAgICAgICAgICAgICBtYXJnaW5SaWdodCA9IF9nZXRDb21wdXRlZFN0eWxlLm1hcmdpblJpZ2h0LFxuICAgICAgICAgICAgICBtYXJnaW5Cb3R0b20gPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5Cb3R0b20sXG4gICAgICAgICAgICAgIG1hcmdpbkxlZnQgPSBfZ2V0Q29tcHV0ZWRTdHlsZS5tYXJnaW5MZWZ0OyAvLyBXZSBubyBsb25nZXIgdGFrZSBpbnRvIGFjY291bnQgYG1hcmdpbnNgIG9uIHRoZSBwb3BwZXIsIGFuZCBpdCBjYW5cbiAgICAgICAgICAvLyBjYXVzZSBidWdzIHdpdGggcG9zaXRpb25pbmcsIHNvIHdlJ2xsIHdhcm4gdGhlIGNvbnN1bWVyXG5cblxuICAgICAgICAgIGlmIChbbWFyZ2luVG9wLCBtYXJnaW5SaWdodCwgbWFyZ2luQm90dG9tLCBtYXJnaW5MZWZ0XS5zb21lKGZ1bmN0aW9uIChtYXJnaW4pIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KG1hcmdpbik7XG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihbJ1BvcHBlcjogQ1NTIFwibWFyZ2luXCIgc3R5bGVzIGNhbm5vdCBiZSB1c2VkIHRvIGFwcGx5IHBhZGRpbmcnLCAnYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgb3IgYm91bmRhcnkuJywgJ1RvIHJlcGxpY2F0ZSBtYXJnaW4sIHVzZSB0aGUgYG9mZnNldGAgbW9kaWZpZXIsIGFzIHdlbGwgYXMnLCAndGhlIGBwYWRkaW5nYCBvcHRpb24gaW4gdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIGFuZCBgZmxpcGAnLCAnbW9kaWZpZXJzLiddLmpvaW4oJyAnKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgIH0sXG4gICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgLy8gaXMgdXNlZnVsIGZvciBsb3cgZnJlcXVlbmN5IHVwZGF0ZXMgd2hlcmUgc3luYyBiZWhhdmlvciBzaW1wbGlmaWVzIHRoZVxuICAgICAgLy8gbG9naWMuXG4gICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAvLyBwcmVmZXIgdGhlIGFzeW5jIFBvcHBlciN1cGRhdGUgbWV0aG9kXG4gICAgICBmb3JjZVVwZGF0ZTogZnVuY3Rpb24gZm9yY2VVcGRhdGUoKSB7XG4gICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXG4gICAgICAgICAgICBwb3BwZXIgPSBfc3RhdGUkZWxlbWVudHMucG9wcGVyOyAvLyBEb24ndCBwcm9jZWVkIGlmIGByZWZlcmVuY2VgIG9yIGBwb3BwZXJgIGFyZSBub3QgdmFsaWQgZWxlbWVudHNcbiAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKElOVkFMSURfRUxFTUVOVF9FUlJPUik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xuXG5cbiAgICAgICAgc3RhdGUucmVjdHMgPSB7XG4gICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgIHBvcHBlcjogZ2V0TGF5b3V0UmVjdChwb3BwZXIpXG4gICAgICAgIH07IC8vIE1vZGlmaWVycyBoYXZlIHRoZSBhYmlsaXR5IHRvIHJlc2V0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZS4gVGhlXG4gICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgIC8vIHBsYWNlbWVudCwgd2hpY2ggdGhlbiBuZWVkcyB0byByZS1ydW4gYWxsIHRoZSBtb2RpZmllcnMsIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGxvZ2ljIHdhcyBwcmV2aW91c2x5IHJhbiBmb3IgdGhlIHByZXZpb3VzIHBsYWNlbWVudCBhbmQgaXMgdGhlcmVmb3JlXG4gICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgIHN0YXRlLnBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50OyAvLyBPbiBlYWNoIHVwZGF0ZSBjeWNsZSwgdGhlIGBtb2RpZmllcnNEYXRhYCBwcm9wZXJ0eSBmb3IgZWFjaCBtb2RpZmllclxuICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cbiAgICAgICAgLy8gVG8gZW5zdXJlIHBlcnNpc3RlbnQgZGF0YSwgdXNlIGAke25hbWV9I3BlcnNpc3RlbnRgXG5cbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgIHJldHVybiBzdGF0ZS5tb2RpZmllcnNEYXRhW21vZGlmaWVyLm5hbWVdID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kaWZpZXIuZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgX19kZWJ1Z19sb29wc19fID0gMDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICBfX2RlYnVnX2xvb3BzX18gKz0gMTtcblxuICAgICAgICAgICAgaWYgKF9fZGVidWdfbG9vcHNfXyA+IDEwMCkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKElORklOSVRFX0xPT1BfRVJST1IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICBpbmRleCA9IC0xO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9zdGF0ZSRvcmRlcmVkTW9kaWZpZSA9IHN0YXRlLm9yZGVyZWRNb2RpZmllcnNbaW5kZXhdLFxuICAgICAgICAgICAgICBmbiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5mbixcbiAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICBfb3B0aW9ucyA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIgPT09IHZvaWQgMCA/IHt9IDogX3N0YXRlJG9yZGVyZWRNb2RpZmllMixcbiAgICAgICAgICAgICAgbmFtZSA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5uYW1lO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc3RhdGUgPSBmbih7XG4gICAgICAgICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZVxuICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXG4gICAgICAvLyBub3QgbmVjZXNzYXJ5IChkZWJvdW5jZWQgdG8gcnVuIGF0IG1vc3Qgb25jZS1wZXItdGljaylcbiAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICBpbnN0YW5jZS5mb3JjZVVwZGF0ZSgpO1xuICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0pLFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xuICAgICAgICBpc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihJTlZBTElEX0VMRU1FTlRfRVJST1IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfVxuXG4gICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgaWYgKCFpc0Rlc3Ryb3llZCAmJiBvcHRpb25zLm9uRmlyc3RVcGRhdGUpIHtcbiAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSBiZWZvcmUgdGhlIGZpcnN0XG4gICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXG4gICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAvLyBvdGhlciBtb2RpZmllcnMgbmVlZCB0byB1c2UsIGJ1dCB0aGUgbW9kaWZpZXIgaXMgcnVuIGFmdGVyIHRoZSBkZXBlbmRlbnRcbiAgICAvLyBvbmUuXG5cbiAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBuYW1lID0gX3JlZjMubmFtZSxcbiAgICAgICAgICAgIF9yZWYzJG9wdGlvbnMgPSBfcmVmMy5vcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYzJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZjMkb3B0aW9ucyxcbiAgICAgICAgICAgIGVmZmVjdCA9IF9yZWYzLmVmZmVjdDtcblxuICAgICAgICBpZiAodHlwZW9mIGVmZmVjdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjbGVhbnVwRm4gPSBlZmZlY3Qoe1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHZhciBub29wRm4gPSBmdW5jdGlvbiBub29wRm4oKSB7fTtcblxuICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpIHtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9KTtcbiAgICAgIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbnZhciBkZWZhdWx0TW9kaWZpZXJzID0gW2V2ZW50TGlzdGVuZXJzLCBwb3BwZXJPZmZzZXRzJDEsIGNvbXB1dGVTdHlsZXMkMSwgYXBwbHlTdHlsZXMkMSwgb2Zmc2V0JDEsIGZsaXAkMSwgcHJldmVudE92ZXJmbG93JDEsIGFycm93JDEsIGhpZGUkMV07XG52YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbn0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbnZhciB1c2VQb3BwZXIgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG4gICAgdmFyIGxldmVsID0gb3B0aW9ucy5sZXZlbCwgYnV0dG9uUmVmID0gb3B0aW9ucy5idXR0b25SZWYsIGNvbnRlbnRSZWYgPSBvcHRpb25zLmNvbnRlbnRSZWY7XHJcbiAgICB2YXIgX2EgPSBSZWFjdF9fZGVmYXVsdC51c2VDb250ZXh0KFNpZGViYXJDb250ZXh0KSwgY29sbGFwc2VkID0gX2EuY29sbGFwc2VkLCB0b2dnbGVkID0gX2EudG9nZ2xlZCwgdHJhbnNpdGlvbkR1cmF0aW9uID0gX2EudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIHBvcHBlckluc3RhbmNlUmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICAvKipcclxuICAgICAqIGNyZWF0ZSBwb3BwZXIgaW5zdGFuY2Ugb25seSBvbiBmaXJzdCBsZXZlbCBzdWJtZW51IGNvbXBvbmVudHMgYW5kIHdoZW4gc2lkZWJhciBpcyBjb2xsYXBzZWRcclxuICAgICAqL1xyXG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAobGV2ZWwgPT09IDAgJiYgY29sbGFwc2VkICYmIGNvbnRlbnRSZWYuY3VycmVudCAmJiBidXR0b25SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50ID0gY3JlYXRlUG9wcGVyKGJ1dHRvblJlZi5jdXJyZW50LCBjb250ZW50UmVmLmN1cnJlbnQsIHtcclxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcclxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiAnZml4ZWQnLFxyXG4gICAgICAgICAgICAgICAgbW9kaWZpZXJzOiBbXHJcbiAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBbMCwgNV0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiAoX2EgPSBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpOyB9O1xyXG4gICAgfSwgW2xldmVsLCBjb2xsYXBzZWQsIGNvbnRlbnRSZWYsIGJ1dHRvblJlZl0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiB1cGRhdGUgcG9wcGVyIGluc3RhbmNlIChwb3NpdGlvbikgd2hlbiBidXR0b25SZWYgb3IgY29udGVudFJlZiBjaGFuZ2VzXHJcbiAgICAgKi9cclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKGNvbnRlbnRSZWYuY3VycmVudCAmJiBidXR0b25SZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICB2YXIgcm8gPSBuZXcgUmVzaXplT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgKF9hID0gcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcm8ub2JzZXJ2ZShjb250ZW50UmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICByby5vYnNlcnZlKGJ1dHRvblJlZi5jdXJyZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgKF9hID0gcG9wcGVySW5zdGFuY2VSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVwZGF0ZSgpO1xyXG4gICAgICAgIH0sIHRyYW5zaXRpb25EdXJhdGlvbik7XHJcbiAgICB9LCBbdHJhbnNpdGlvbkR1cmF0aW9uLCB0b2dnbGVkLCBjb250ZW50UmVmLCBidXR0b25SZWZdKTtcclxuICAgIHJldHVybiB7IHBvcHBlckluc3RhbmNlOiBwb3BwZXJJbnN0YW5jZVJlZi5jdXJyZW50IH07XHJcbn07XG5cbnZhciBtZW51QnV0dG9uU3R5bGVzID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICB2YXIgcnRsID0gcHJvcHMucnRsLCBsZXZlbCA9IHByb3BzLmxldmVsLCBjb2xsYXBzZWQgPSBwcm9wcy5jb2xsYXBzZWQsIGRpc2FibGVkID0gcHJvcHMuZGlzYWJsZWQsIGFjdGl2ZSA9IHByb3BzLmFjdGl2ZTtcclxuICAgIHJldHVybiBcIlxcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgICBoZWlnaHQ6IDUwcHg7XFxuICAgIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gICAgY29sb3I6IGluaGVyaXQ7XFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG5cXG4gICAgXCIuY29uY2F0KHJ0bFxyXG4gICAgICAgID8gXCJwYWRkaW5nLWxlZnQ6IDIwcHg7XFxuICAgICAgICAgICBwYWRkaW5nLXJpZ2h0OiBcIi5jb25jYXQobGV2ZWwgPT09IDAgPyAyMCA6IChjb2xsYXBzZWQgPyBsZXZlbCA6IGxldmVsICsgMSkgKiAyMCwgXCJweDtcXG4gICAgICAgICAgICBcIilcclxuICAgICAgICA6IFwicGFkZGluZy1yaWdodDogMjBweDtcXG4gICAgICAgICAgIHBhZGRpbmctbGVmdDogXCIuY29uY2F0KGxldmVsID09PSAwID8gMjAgOiAoY29sbGFwc2VkID8gbGV2ZWwgOiBsZXZlbCArIDEpICogMjAsIFwicHg7XFxuICAgICAgICAgICBcIiksIFwiXFxuXFxuICAgICY6aG92ZXIge1xcbiAgICAgIGJhY2tncm91bmQtY29sb3I6ICNmM2YzZjM7XFxuICAgIH1cXG5cXG4gICAgXCIpLmNvbmNhdChkaXNhYmxlZCAmJlxyXG4gICAgICAgIFwiIFxcbiAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbiAgICAgIGN1cnNvcjogZGVmYXVsdDtcXG4gICAgICBjb2xvcjojYWRhZGFkO1xcbiAgICAgICAgXCIsIFwiXFxuXFxuICAgIFwiKS5jb25jYXQoYWN0aXZlICYmICdiYWNrZ3JvdW5kLWNvbG9yOiAjZTJlZWY5OycsIFwiXFxuICBcXG4gIFwiKTtcclxufTtcclxudmFyIE1lbnVCdXR0b25SZWYgPSBmdW5jdGlvbiAoX2EsIHJlZikge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgY29tcG9uZW50ID0gX2EuY29tcG9uZW50LCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjbGFzc05hbWVcIiwgXCJjb21wb25lbnRcIiwgXCJjaGlsZHJlblwiXSk7XHJcbiAgICBpZiAoY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KGNvbXBvbmVudCwgX19hc3NpZ24oX19hc3NpZ24oeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMoY2xhc3NOYW1lKSB9LCByZXN0KSwgeyByZWY6IHJlZiB9KSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdmFyIF9iID0gY29tcG9uZW50LnByb3BzLCBjbGFzc05hbWVQcm9wID0gX2IuY2xhc3NOYW1lLCBwcm9wcyA9IF9fcmVzdChfYiwgW1wiY2xhc3NOYW1lXCJdKTtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNsb25lRWxlbWVudChjb21wb25lbnQsIF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSwgY2xhc3NOYW1lUHJvcCkgfSwgcmVzdCksIHByb3BzKSwgeyByZWY6IHJlZiB9KSwgY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwgX19hc3NpZ24oeyByZWY6IHJlZiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKGNsYXNzTmFtZSkgfSwgcmVzdCksIGNoaWxkcmVuKSk7XHJcbiAgICB9XHJcbn07XHJcbnZhciBNZW51QnV0dG9uID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihNZW51QnV0dG9uUmVmKTtcblxudmFyIFN0eWxlZFN1Yk1lbnUgPSBuZXdTdHlsZWQubGkodGVtcGxhdGVPYmplY3RfMSQxIHx8ICh0ZW1wbGF0ZU9iamVjdF8xJDEgPSBfX21ha2VUZW1wbGF0ZU9iamVjdChbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdLCBbXCJcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gIHdpZHRoOiAxMDAlO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgXCIsIFwiO1xcblxcbiAgPiAuXCIsIFwiIHtcXG4gICAgXCIsIFwiO1xcblxcbiAgICBcIiwgXCI7XFxuICB9XFxuXCJdKSksIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIG1lbnVJdGVtU3R5bGVzID0gX2EubWVudUl0ZW1TdHlsZXM7XHJcbiAgICByZXR1cm4gbWVudUl0ZW1TdHlsZXM7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZXM7XHJcbn0sIG1lbnVDbGFzc2VzLmJ1dHRvbiwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgbGV2ZWwgPSBfYS5sZXZlbCwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgYWN0aXZlID0gX2EuYWN0aXZlLCBjb2xsYXBzZWQgPSBfYS5jb2xsYXBzZWQsIHJ0bCA9IF9hLnJ0bDtcclxuICAgIHJldHVybiBtZW51QnV0dG9uU3R5bGVzKHtcclxuICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxyXG4gICAgICAgIGFjdGl2ZTogYWN0aXZlLFxyXG4gICAgICAgIGNvbGxhcHNlZDogY29sbGFwc2VkLFxyXG4gICAgICAgIHJ0bDogcnRsLFxyXG4gICAgfSk7XHJcbn0sIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgdmFyIGJ1dHRvblN0eWxlcyA9IF9hLmJ1dHRvblN0eWxlcztcclxuICAgIHJldHVybiBidXR0b25TdHlsZXM7XHJcbn0pO1xyXG52YXIgU3ViTWVudUZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGxhYmVsID0gX2EubGFiZWwsIGljb24gPSBfYS5pY29uLCB0aXRsZSA9IF9hLnRpdGxlLCBwcmVmaXggPSBfYS5wcmVmaXgsIHN1ZmZpeCA9IF9hLnN1ZmZpeCwgb3BlbkNvbnRyb2xsZWQgPSBfYS5vcGVuLCBkZWZhdWx0T3BlbiA9IF9hLmRlZmF1bHRPcGVuLCBfYyA9IF9hLmFjdGl2ZSwgYWN0aXZlID0gX2MgPT09IHZvaWQgMCA/IGZhbHNlIDogX2MsIF9kID0gX2EuZGlzYWJsZWQsIGRpc2FibGVkID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIG9uT3BlbkNoYW5nZSA9IF9hLm9uT3BlbkNoYW5nZSwgb25DbGljayA9IF9hLm9uQ2xpY2ssIG9uS2V5VXAgPSBfYS5vbktleVVwLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImNsYXNzTmFtZVwiLCBcImxhYmVsXCIsIFwiaWNvblwiLCBcInRpdGxlXCIsIFwicHJlZml4XCIsIFwic3VmZml4XCIsIFwib3BlblwiLCBcImRlZmF1bHRPcGVuXCIsIFwiYWN0aXZlXCIsIFwiZGlzYWJsZWRcIiwgXCJyb290U3R5bGVzXCIsIFwiY29tcG9uZW50XCIsIFwib25PcGVuQ2hhbmdlXCIsIFwib25DbGlja1wiLCBcIm9uS2V5VXBcIl0pO1xyXG4gICAgdmFyIGxldmVsID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChMZXZlbENvbnRleHQpO1xyXG4gICAgdmFyIF9lID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChTaWRlYmFyQ29udGV4dCksIGNvbGxhcHNlZCA9IF9lLmNvbGxhcHNlZCwgcnRsID0gX2UucnRsLCBzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uID0gX2UudHJhbnNpdGlvbkR1cmF0aW9uO1xyXG4gICAgdmFyIF9mID0gdXNlTWVudSgpLCByZW5kZXJFeHBhbmRJY29uID0gX2YucmVuZGVyRXhwYW5kSWNvbiwgY2xvc2VPbkNsaWNrID0gX2YuY2xvc2VPbkNsaWNrLCBtZW51SXRlbVN0eWxlcyA9IF9mLm1lbnVJdGVtU3R5bGVzLCB0cmFuc2l0aW9uRHVyYXRpb24gPSBfZi50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgX2cgPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZSghIWRlZmF1bHRPcGVuKSwgb3BlbiA9IF9nWzBdLCBzZXRPcGVuID0gX2dbMV07XHJcbiAgICB2YXIgX2ggPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSksIG9wZW5XaGVuQ29sbGFwc2VkID0gX2hbMF0sIHNldE9wZW5XaGVuQ29sbGFwc2VkID0gX2hbMV07XHJcbiAgICB2YXIgX2ogPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShmYWxzZSksIG1vdW50ZWQgPSBfalswXSwgc2V0TW91bnRlZCA9IF9qWzFdO1xyXG4gICAgdmFyIGJ1dHRvblJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihudWxsKTtcclxuICAgIHZhciBjb250ZW50UmVmID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG51bGwpO1xyXG4gICAgdmFyIHRpbWVyID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKCk7XHJcbiAgICB2YXIgcG9wcGVySW5zdGFuY2UgPSB1c2VQb3BwZXIoe1xyXG4gICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICBidXR0b25SZWY6IGJ1dHRvblJlZixcclxuICAgICAgICBjb250ZW50UmVmOiBjb250ZW50UmVmLFxyXG4gICAgfSkucG9wcGVySW5zdGFuY2U7XHJcbiAgICB2YXIgc2xpZGVVcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICAgICAgdmFyIGhlaWdodCA9IHRhcmdldC5vZmZzZXRIZWlnaHQ7XHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSAnMHB4JztcclxuICAgICAgICAgICAgdGFyZ2V0Lm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKTtcclxuICAgICAgICAgICAgdGltZXIuY3VycmVudCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9ICdhdXRvJztcclxuICAgICAgICAgICAgfSwgdHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIHNsaWRlRG93biA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0ID0gY29udGVudFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XHJcbiAgICAgICAgICAgIHRhcmdldC5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdCh0YXJnZXQub2Zmc2V0SGVpZ2h0LCBcInB4XCIpO1xyXG4gICAgICAgICAgICB0YXJnZXQub2Zmc2V0SGVpZ2h0O1xyXG4gICAgICAgICAgICB0YXJnZXQuc3R5bGUuaGVpZ2h0ID0gJzBweCc7XHJcbiAgICAgICAgICAgIHRpbWVyLmN1cnJlbnQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5vdmVyZmxvdyA9ICdhdXRvJztcclxuICAgICAgICAgICAgICAgIHRhcmdldC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICB9LCB0cmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgaGFuZGxlU2xpZGVUb2dnbGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCEobGV2ZWwgPT09IDAgJiYgY29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoTnVtYmVyKHRpbWVyLmN1cnJlbnQpKTtcclxuICAgICAgICAgICAgdmFyIG9wZW5WYWx1ZSA9IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW47XHJcbiAgICAgICAgICAgIG9wZW5WYWx1ZSA/IHNsaWRlRG93bigpIDogc2xpZGVVcCgpO1xyXG4gICAgICAgICAgICBvbk9wZW5DaGFuZ2UgPT09IG51bGwgfHwgb25PcGVuQ2hhbmdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbk9wZW5DaGFuZ2UoIW9wZW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIHR5cGVvZiBvcGVuQ29udHJvbGxlZCA9PT0gJ3VuZGVmaW5lZCcgJiYgc2V0T3Blbighb3Blbik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVPbkNsaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgb25DbGljayA9PT0gbnVsbCB8fCBvbkNsaWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkNsaWNrKGV2ZW50KTtcclxuICAgICAgICBoYW5kbGVTbGlkZVRvZ2dsZSgpO1xyXG4gICAgfTtcclxuICAgIHZhciBoYW5kbGVPbktleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgb25LZXlVcCA9PT0gbnVsbCB8fCBvbktleVVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbktleVVwKGV2ZW50KTtcclxuICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZVNsaWRlVG9nZ2xlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBnZXRTdWJNZW51SXRlbVN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKG1lbnVJdGVtU3R5bGVzKSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7IGxldmVsOiBsZXZlbCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBhY3RpdmU6IGFjdGl2ZSwgaXNTdWJtZW51OiB0cnVlLCBvcGVuOiBvcGVuQ29udHJvbGxlZCAhPT0gbnVsbCAmJiBvcGVuQ29udHJvbGxlZCAhPT0gdm9pZCAwID8gb3BlbkNvbnRyb2xsZWQgOiBvcGVuIH07XHJcbiAgICAgICAgICAgIHZhciByb290RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5yb290LCBidXR0b25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmJ1dHRvbiwgbGFiZWxFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmxhYmVsLCBpY29uRWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5pY29uLCBwcmVmaXhFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnByZWZpeCwgc3VmZml4RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5zdWZmaXgsIHN1Yk1lbnVDb250ZW50RWxTdHlsZXMgPSBtZW51SXRlbVN0eWxlcy5zdWJNZW51Q29udGVudCwgU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLlN1Yk1lbnVFeHBhbmRJY29uO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3Jvb3QnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygcm9vdEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gcm9vdEVsU3R5bGVzKHBhcmFtcykgOiByb290RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdidXR0b24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgYnV0dG9uRWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBidXR0b25FbFN0eWxlcyhwYXJhbXMpIDogYnV0dG9uRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdsYWJlbCc6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBsYWJlbEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gbGFiZWxFbFN0eWxlcyhwYXJhbXMpIDogbGFiZWxFbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2ljb24nOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgaWNvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gaWNvbkVsU3R5bGVzKHBhcmFtcykgOiBpY29uRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVmaXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcHJlZml4RWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBwcmVmaXhFbFN0eWxlcyhwYXJhbXMpIDogcHJlZml4RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdzdWZmaXgnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2Ygc3VmZml4RWxTdHlsZXMgPT09ICdmdW5jdGlvbicgPyBzdWZmaXhFbFN0eWxlcyhwYXJhbXMpIDogc3VmZml4RWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdTdWJNZW51RXhwYW5kSWNvbic6XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBTdWJNZW51RXhwYW5kSWNvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nXHJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ3N1Yk1lbnVDb250ZW50JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1Yk1lbnVDb250ZW50RWxTdHlsZXMgPT09ICdmdW5jdGlvbidcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzdWJNZW51Q29udGVudEVsU3R5bGVzKHBhcmFtcylcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzdWJNZW51Q29udGVudEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBwb3BwZXJJbnN0YW5jZSA9PT0gbnVsbCB8fCBwb3BwZXJJbnN0YW5jZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9wcGVySW5zdGFuY2UudXBkYXRlKCk7IH0sIHNpZGViYXJUcmFuc2l0aW9uRHVyYXRpb24pO1xyXG4gICAgICAgIGlmIChjb2xsYXBzZWQgJiYgbGV2ZWwgPT09IDApIHtcclxuICAgICAgICAgICAgc2V0T3BlbldoZW5Db2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICAvLyA/IGlmIGl0cyB1c2VmdWwgdG8gY2xvc2UgZmlyc3QgbGV2ZWwgc3VibWVudXMgb24gY29sbGFwc2Ugc2lkZWJhciB1bmNvbW1lbnQgdGhlIGNvZGUgYmVsb3dcclxuICAgICAgICAgICAgLy8gc2V0T3BlbihmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSwgW2NvbGxhcHNlZCwgbGV2ZWwsIHJ0bCwgc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiwgcG9wcGVySW5zdGFuY2VdKTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhhbmRsZVRvZ2dsZVBvcHBlciA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgICAgIGlmICghb3BlbldoZW5Db2xsYXBzZWQgJiYgKChfYSA9IGJ1dHRvblJlZi5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnModGFyZ2V0KSkpXHJcbiAgICAgICAgICAgICAgICBzZXRPcGVuV2hlbkNvbGxhcHNlZCh0cnVlKTtcclxuICAgICAgICAgICAgZWxzZSBpZiAoKGNsb3NlT25DbGljayAmJlxyXG4gICAgICAgICAgICAgICAgISgoX2IgPSB0YXJnZXRcclxuICAgICAgICAgICAgICAgICAgICAuY2xvc2VzdChcIi5cIi5jb25jYXQobWVudUNsYXNzZXMubWVudUl0ZW1Sb290KSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jbGFzc0xpc3QuY29udGFpbnMobWVudUNsYXNzZXMuc3ViTWVudVJvb3QpKSkgfHxcclxuICAgICAgICAgICAgICAgICghKChfYyA9IGNvbnRlbnRSZWYuY3VycmVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNvbnRhaW5zKHRhcmdldCkpICYmIG9wZW5XaGVuQ29sbGFwc2VkKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0T3BlbldoZW5Db2xsYXBzZWQoZmFsc2UpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgaGFuZGxlRG9jdW1lbnRDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgICBoYW5kbGVUb2dnbGVQb3BwZXIoZXZlbnQudGFyZ2V0KTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBoYW5kbGVEb2N1bWVudEtleVVwID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicpIHtcclxuICAgICAgICAgICAgICAgIGhhbmRsZVRvZ2dsZVBvcHBlcihldmVudC50YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcclxuICAgICAgICAgICAgICAgIHNldE9wZW5XaGVuQ29sbGFwc2VkKGZhbHNlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHJlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZURvY3VtZW50Q2xpY2spO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZURvY3VtZW50S2V5VXApO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICBpZiAoY29sbGFwc2VkICYmIGxldmVsID09PSAwKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlRG9jdW1lbnRDbGljaywgZmFsc2UpO1xyXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGhhbmRsZURvY3VtZW50S2V5VXAsIGZhbHNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NvbGxhcHNlZCwgbGV2ZWwsIGNsb3NlT25DbGljaywgb3BlbldoZW5Db2xsYXBzZWRdKTtcclxuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciBzaGFyZWRDbGFzc2VzID0gKF9iID0ge30sXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuYWN0aXZlXSA9IGFjdGl2ZSxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5kaXNhYmxlZF0gPSBkaXNhYmxlZCxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5vcGVuXSA9IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4sXHJcbiAgICAgICAgX2IpO1xyXG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZFN1Yk1lbnUsIHsgcmVmOiByZWYsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5tZW51SXRlbVJvb3QsIG1lbnVDbGFzc2VzLnN1Yk1lbnVSb290LCBzaGFyZWRDbGFzc2VzLCBjbGFzc05hbWUpLCBtZW51SXRlbVN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3Jvb3QnKSwgbGV2ZWw6IGxldmVsLCBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgcnRsOiBydGwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGJ1dHRvblN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ2J1dHRvbicpLCByb290U3R5bGVzOiByb290U3R5bGVzIH0sXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChNZW51QnV0dG9uLCBfX2Fzc2lnbih7IFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQobWVudUNsYXNzZXMuYnV0dG9uLCBcIi10ZXN0LWlkXCIpLCByZWY6IGJ1dHRvblJlZiwgdGl0bGU6IHRpdGxlLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuYnV0dG9uLCBzaGFyZWRDbGFzc2VzKSwgb25DbGljazogaGFuZGxlT25DbGljaywgb25LZXlVcDogaGFuZGxlT25LZXlVcCwgY29tcG9uZW50OiBjb21wb25lbnQsIHRhYkluZGV4OiAwIH0sIHJlc3QpLFxyXG4gICAgICAgICAgICBpY29uICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVJY29uLCB7IHJ0bDogcnRsLCBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMuaWNvbiwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdpY29uJykgfSwgaWNvbikpLFxyXG4gICAgICAgICAgICBwcmVmaXggJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudVByZWZpeCwgeyBjb2xsYXBzZWQ6IGNvbGxhcHNlZCwgdHJhbnNpdGlvbkR1cmF0aW9uOiBzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uLCBmaXJzdExldmVsOiBsZXZlbCA9PT0gMCwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnByZWZpeCwgc2hhcmVkQ2xhc3NlcyksIHJ0bDogcnRsLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygncHJlZml4JykgfSwgcHJlZml4KSksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUxhYmVsLCB7IGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5sYWJlbCwgc2hhcmVkQ2xhc3NlcyksIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdsYWJlbCcpIH0sIGxhYmVsKSxcclxuICAgICAgICAgICAgc3VmZml4ICYmIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVTdWZmaXgsIHsgY29sbGFwc2VkOiBjb2xsYXBzZWQsIHRyYW5zaXRpb25EdXJhdGlvbjogc2lkZWJhclRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5zdWZmaXgsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRTdWJNZW51SXRlbVN0eWxlcygnc3VmZml4JykgfSwgc3VmZml4KSksXHJcbiAgICAgICAgICAgIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkRXhwYW5kSWNvbldyYXBwZXIsIHsgcnRsOiBydGwsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5TdWJNZW51RXhwYW5kSWNvbiwgc2hhcmVkQ2xhc3NlcyksIGNvbGxhcHNlZDogY29sbGFwc2VkLCBsZXZlbDogbGV2ZWwsIHJvb3RTdHlsZXM6IGdldFN1Yk1lbnVJdGVtU3R5bGVzKCdTdWJNZW51RXhwYW5kSWNvbicpIH0sIHJlbmRlckV4cGFuZEljb24gPyAocmVuZGVyRXhwYW5kSWNvbih7XHJcbiAgICAgICAgICAgICAgICBsZXZlbDogbGV2ZWwsXHJcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgICAgICAgICBhY3RpdmU6IGFjdGl2ZSxcclxuICAgICAgICAgICAgICAgIG9wZW46IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4sXHJcbiAgICAgICAgICAgIH0pKSA6IGNvbGxhcHNlZCAmJiBsZXZlbCA9PT0gMCA/IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEV4cGFuZEljb25Db2xsYXBzZWQsIG51bGwpKSA6IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZEV4cGFuZEljb24sIHsgcnRsOiBydGwsIG9wZW46IG9wZW5Db250cm9sbGVkICE9PSBudWxsICYmIG9wZW5Db250cm9sbGVkICE9PSB2b2lkIDAgPyBvcGVuQ29udHJvbGxlZCA6IG9wZW4gfSkpKSksXHJcbiAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdWJNZW51Q29udGVudCwgeyByZWY6IGNvbnRlbnRSZWYsIG9wZW5XaGVuQ29sbGFwc2VkOiBvcGVuV2hlbkNvbGxhcHNlZCwgb3Blbjogb3BlbkNvbnRyb2xsZWQgIT09IG51bGwgJiYgb3BlbkNvbnRyb2xsZWQgIT09IHZvaWQgMCA/IG9wZW5Db250cm9sbGVkIDogb3BlbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBkZWZhdWx0T3BlbjogKG9wZW5Db250cm9sbGVkICYmICFtb3VudGVkKSB8fCBkZWZhdWx0T3BlbiwgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLnN1Yk1lbnVDb250ZW50LCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0U3ViTWVudUl0ZW1TdHlsZXMoJ3N1Yk1lbnVDb250ZW50JykgfSxcclxuICAgICAgICAgICAgUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChMZXZlbENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGxldmVsICsgMSB9LCBjaGlsZHJlbikpKSk7XHJcbn07XHJcbnZhciBTdWJNZW51ID0gUmVhY3RfX2RlZmF1bHQuZm9yd2FyZFJlZihTdWJNZW51RlIpO1xyXG52YXIgdGVtcGxhdGVPYmplY3RfMSQxO1xuXG52YXIgU3R5bGVkTWVudUl0ZW0gPSBuZXdTdHlsZWQubGkodGVtcGxhdGVPYmplY3RfMSB8fCAodGVtcGxhdGVPYmplY3RfMSA9IF9fbWFrZVRlbXBsYXRlT2JqZWN0KFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXFxuICA+IC5cIiwgXCIge1xcbiAgICBcIiwgXCI7XFxuXFxuICAgIFwiLCBcIjtcXG4gIH1cXG5cIl0sIFtcIlxcbiAgd2lkdGg6IDEwMCU7XFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuXFxuICBcIiwgXCI7XFxuXFxuICBcIiwgXCI7XFxuXFxuICA+IC5cIiwgXCIge1xcbiAgICBcIiwgXCI7XFxuXFxuICAgIFwiLCBcIjtcXG4gIH1cXG5cIl0pKSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgbWVudUl0ZW1TdHlsZXMgPSBfYS5tZW51SXRlbVN0eWxlcztcclxuICAgIHJldHVybiBtZW51SXRlbVN0eWxlcztcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgcm9vdFN0eWxlcyA9IF9hLnJvb3RTdHlsZXM7XHJcbiAgICByZXR1cm4gcm9vdFN0eWxlcztcclxufSwgbWVudUNsYXNzZXMuYnV0dG9uLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgIHZhciBsZXZlbCA9IF9hLmxldmVsLCBkaXNhYmxlZCA9IF9hLmRpc2FibGVkLCBhY3RpdmUgPSBfYS5hY3RpdmUsIGNvbGxhcHNlZCA9IF9hLmNvbGxhcHNlZCwgcnRsID0gX2EucnRsO1xyXG4gICAgcmV0dXJuIG1lbnVCdXR0b25TdHlsZXMoe1xyXG4gICAgICAgIGxldmVsOiBsZXZlbCxcclxuICAgICAgICBkaXNhYmxlZDogZGlzYWJsZWQsXHJcbiAgICAgICAgYWN0aXZlOiBhY3RpdmUsXHJcbiAgICAgICAgY29sbGFwc2VkOiBjb2xsYXBzZWQsXHJcbiAgICAgICAgcnRsOiBydGwsXHJcbiAgICB9KTtcclxufSwgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgYnV0dG9uU3R5bGVzID0gX2EuYnV0dG9uU3R5bGVzO1xyXG4gICAgcmV0dXJuIGJ1dHRvblN0eWxlcztcclxufSk7XHJcbnZhciBNZW51SXRlbUZSID0gZnVuY3Rpb24gKF9hLCByZWYpIHtcclxuICAgIHZhciBfYjtcclxuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpY29uID0gX2EuaWNvbiwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBwcmVmaXggPSBfYS5wcmVmaXgsIHN1ZmZpeCA9IF9hLnN1ZmZpeCwgX2MgPSBfYS5hY3RpdmUsIGFjdGl2ZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jLCBfZCA9IF9hLmRpc2FibGVkLCBkaXNhYmxlZCA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBjb21wb25lbnQgPSBfYS5jb21wb25lbnQsIHJvb3RTdHlsZXMgPSBfYS5yb290U3R5bGVzLCByZXN0ID0gX19yZXN0KF9hLCBbXCJjaGlsZHJlblwiLCBcImljb25cIiwgXCJjbGFzc05hbWVcIiwgXCJwcmVmaXhcIiwgXCJzdWZmaXhcIiwgXCJhY3RpdmVcIiwgXCJkaXNhYmxlZFwiLCBcImNvbXBvbmVudFwiLCBcInJvb3RTdHlsZXNcIl0pO1xyXG4gICAgdmFyIGxldmVsID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChMZXZlbENvbnRleHQpO1xyXG4gICAgdmFyIF9lID0gUmVhY3RfX2RlZmF1bHQudXNlQ29udGV4dChTaWRlYmFyQ29udGV4dCksIGNvbGxhcHNlZCA9IF9lLmNvbGxhcHNlZCwgcnRsID0gX2UucnRsLCB0cmFuc2l0aW9uRHVyYXRpb24gPSBfZS50cmFuc2l0aW9uRHVyYXRpb247XHJcbiAgICB2YXIgbWVudUl0ZW1TdHlsZXMgPSB1c2VNZW51KCkubWVudUl0ZW1TdHlsZXM7XHJcbiAgICB2YXIgZ2V0TWVudUl0ZW1TdHlsZXMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChtZW51SXRlbVN0eWxlcykge1xyXG4gICAgICAgICAgICB2YXIgcGFyYW1zID0geyBsZXZlbDogbGV2ZWwsIGRpc2FibGVkOiBkaXNhYmxlZCwgYWN0aXZlOiBhY3RpdmUsIGlzU3VibWVudTogZmFsc2UgfTtcclxuICAgICAgICAgICAgdmFyIHJvb3RFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnJvb3QsIGJ1dHRvbkVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMuYnV0dG9uLCBsYWJlbEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMubGFiZWwsIGljb25FbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLmljb24sIHByZWZpeEVsU3R5bGVzID0gbWVudUl0ZW1TdHlsZXMucHJlZml4LCBzdWZmaXhFbFN0eWxlcyA9IG1lbnVJdGVtU3R5bGVzLnN1ZmZpeDtcclxuICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdyb290JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJvb3RFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IHJvb3RFbFN0eWxlcyhwYXJhbXMpIDogcm9vdEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnYnV0dG9uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGJ1dHRvbkVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gYnV0dG9uRWxTdHlsZXMocGFyYW1zKSA6IGJ1dHRvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnbGFiZWwnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgbGFiZWxFbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGxhYmVsRWxTdHlsZXMocGFyYW1zKSA6IGxhYmVsRWxTdHlsZXM7XHJcbiAgICAgICAgICAgICAgICBjYXNlICdpY29uJzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGljb25FbFN0eWxlcyA9PT0gJ2Z1bmN0aW9uJyA/IGljb25FbFN0eWxlcyhwYXJhbXMpIDogaWNvbkVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAncHJlZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHByZWZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gcHJlZml4RWxTdHlsZXMocGFyYW1zKSA6IHByZWZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAnc3VmZml4JzpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHN1ZmZpeEVsU3R5bGVzID09PSAnZnVuY3Rpb24nID8gc3VmZml4RWxTdHlsZXMocGFyYW1zKSA6IHN1ZmZpeEVsU3R5bGVzO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHZhciBzaGFyZWRDbGFzc2VzID0gKF9iID0ge30sXHJcbiAgICAgICAgX2JbbWVudUNsYXNzZXMuYWN0aXZlXSA9IGFjdGl2ZSxcclxuICAgICAgICBfYlttZW51Q2xhc3Nlcy5kaXNhYmxlZF0gPSBkaXNhYmxlZCxcclxuICAgICAgICBfYik7XHJcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUl0ZW0sIHsgcmVmOiByZWYsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5tZW51SXRlbVJvb3QsIHNoYXJlZENsYXNzZXMsIGNsYXNzTmFtZSksIG1lbnVJdGVtU3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygncm9vdCcpLCBsZXZlbDogbGV2ZWwsIGNvbGxhcHNlZDogY29sbGFwc2VkLCBydGw6IHJ0bCwgZGlzYWJsZWQ6IGRpc2FibGVkLCBhY3RpdmU6IGFjdGl2ZSwgYnV0dG9uU3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnYnV0dG9uJyksIHJvb3RTdHlsZXM6IHJvb3RTdHlsZXMgfSxcclxuICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KE1lbnVCdXR0b24sIF9fYXNzaWduKHsgY2xhc3NOYW1lOiBjbGFzc25hbWVzKG1lbnVDbGFzc2VzLmJ1dHRvbiwgc2hhcmVkQ2xhc3NlcyksIFwiZGF0YS10ZXN0aWRcIjogXCJcIi5jb25jYXQobWVudUNsYXNzZXMuYnV0dG9uLCBcIi10ZXN0LWlkXCIpLCBjb21wb25lbnQ6IGNvbXBvbmVudCwgdGFiSW5kZXg6IDAgfSwgcmVzdCksXHJcbiAgICAgICAgICAgIGljb24gJiYgKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU3R5bGVkTWVudUljb24sIHsgcnRsOiBydGwsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5pY29uLCBzaGFyZWRDbGFzc2VzKSwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ2ljb24nKSB9LCBpY29uKSksXHJcbiAgICAgICAgICAgIHByZWZpeCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51UHJlZml4LCB7IGNvbGxhcHNlZDogY29sbGFwc2VkLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5wcmVmaXgsIHNoYXJlZENsYXNzZXMpLCBydGw6IHJ0bCwgcm9vdFN0eWxlczogZ2V0TWVudUl0ZW1TdHlsZXMoJ3ByZWZpeCcpIH0sIHByZWZpeCkpLFxyXG4gICAgICAgICAgICBSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFN0eWxlZE1lbnVMYWJlbCwgeyBjbGFzc05hbWU6IGNsYXNzbmFtZXMobWVudUNsYXNzZXMubGFiZWwsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnbGFiZWwnKSB9LCBjaGlsZHJlbiksXHJcbiAgICAgICAgICAgIHN1ZmZpeCAmJiAoUmVhY3RfX2RlZmF1bHQuY3JlYXRlRWxlbWVudChTdHlsZWRNZW51U3VmZml4LCB7IGNvbGxhcHNlZDogY29sbGFwc2VkLCB0cmFuc2l0aW9uRHVyYXRpb246IHRyYW5zaXRpb25EdXJhdGlvbiwgZmlyc3RMZXZlbDogbGV2ZWwgPT09IDAsIGNsYXNzTmFtZTogY2xhc3NuYW1lcyhtZW51Q2xhc3Nlcy5zdWZmaXgsIHNoYXJlZENsYXNzZXMpLCByb290U3R5bGVzOiBnZXRNZW51SXRlbVN0eWxlcygnc3VmZml4JykgfSwgc3VmZml4KSkpKSk7XHJcbn07XHJcbnZhciBNZW51SXRlbSA9IFJlYWN0X19kZWZhdWx0LmZvcndhcmRSZWYoTWVudUl0ZW1GUik7XHJcbnZhciB0ZW1wbGF0ZU9iamVjdF8xO1xuXG4vKipcclxuICogQGRlcHJlY2F0ZWRcclxuICogYFByb1NpZGViYXJQcm92aWRlcmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAqL1xyXG52YXIgUHJvU2lkZWJhclByb3ZpZGVyID0gZnVuY3Rpb24gKF9hKSB7XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbjtcclxuICAgIGNvbnNvbGUud2FybignUHJvU2lkZWJhclByb3ZpZGVyIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLicpO1xyXG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoU2lkZWJhclByb3ZpZGVyLCBudWxsLCBjaGlsZHJlbik7XHJcbn07XG5cbi8qKlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKiBgdXNlUHJvU2lkZWJhcmAgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXHJcbiAqICBwbGVhc2UgdXNlIFNpZGViYXIgcHJvcHMgaW5zdGVhZC5cclxuICovXHJcbnZhciB1c2VQcm9TaWRlYmFyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGxlZ2FjeVNpZGViYXJDb250ZXh0ID0gdXNlTGVnYWN5U2lkZWJhcigpO1xyXG4gICAgaWYgKGxlZ2FjeVNpZGViYXJDb250ZXh0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZVByb1NpZGViYXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFByb1NpZGViYXJQcm92aWRlci4gUGxlYXNlIHdyYXAgeW91ciBjb21wb25lbnQgd2l0aCBhIFByb1NpZGViYXJQcm92aWRlciB0byB1c2UgdGhpcyBob29rLicpO1xyXG4gICAgfVxyXG4gICAgdmFyIGNvbGxhcHNlU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVDb2xsYXBzZVN0YXRlKCk7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVTaWRlYmFyU3RhdGUoeyBjb2xsYXBzZWQ6IHZhbHVlIH0pO1xyXG4gICAgfSwgXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICBbbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlQ29sbGFwc2VTdGF0ZSwgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlXSk7XHJcbiAgICB2YXIgdG9nZ2xlU2lkZWJhciA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uICh2YWx1ZSkge1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVUb2dnbGVTdGF0ZSgpO1xyXG4gICAgICAgIGVsc2VcclxuICAgICAgICAgICAgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlKHsgdG9nZ2xlZDogdmFsdWUgfSk7XHJcbiAgICB9LCBcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcclxuICAgIFtsZWdhY3lTaWRlYmFyQ29udGV4dC51cGRhdGVUb2dnbGVTdGF0ZSwgbGVnYWN5U2lkZWJhckNvbnRleHQudXBkYXRlU2lkZWJhclN0YXRlXSk7XHJcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybigndXNlUHJvU2lkZWJhciBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS4gUGxlYXNlIHVzZSBTaWRlYmFyIHByb3BzIGluc3RlYWQuJyk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbGxhcHNlU2lkZWJhcjogY29sbGFwc2VTaWRlYmFyLFxyXG4gICAgICAgIHRvZ2dsZVNpZGViYXI6IHRvZ2dsZVNpZGViYXIsXHJcbiAgICAgICAgY29sbGFwc2VkOiAhIWxlZ2FjeVNpZGViYXJDb250ZXh0LmNvbGxhcHNlZCxcclxuICAgICAgICBicm9rZW46ICEhbGVnYWN5U2lkZWJhckNvbnRleHQuYnJva2VuLFxyXG4gICAgICAgIHRvZ2dsZWQ6ICEhbGVnYWN5U2lkZWJhckNvbnRleHQudG9nZ2xlZCxcclxuICAgICAgICBydGw6ICEhbGVnYWN5U2lkZWJhckNvbnRleHQucnRsLFxyXG4gICAgfTtcclxufTtcblxuZXhwb3J0IHsgTGV2ZWxDb250ZXh0LCBNZW51LCBNZW51Q29udGV4dCwgTWVudUl0ZW0sIE1lbnVJdGVtRlIsIFByb1NpZGViYXJQcm92aWRlciwgU2lkZWJhciwgU2lkZWJhckNvbnRleHQsIFN1Yk1lbnUsIFN1Yk1lbnVGUiwgbWVudUNsYXNzZXMsIHNpZGViYXJDbGFzc2VzLCB1c2VQcm9TaWRlYmFyIH07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJSZWFjdF9fZGVmYXVsdCIsImZvcndhcmRSZWYiLCJ1c2VDb250ZXh0IiwiY3JlYXRlRWxlbWVudCIsImNyZWF0ZUNvbnRleHQiLCJGcmFnbWVudCIsIl9fYXNzaWduIiwiT2JqZWN0IiwiYXNzaWduIiwidCIsInMiLCJpIiwibiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInAiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJhcHBseSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX21ha2VUZW1wbGF0ZU9iamVjdCIsImNvb2tlZCIsInJhdyIsImRlZmluZVByb3BlcnR5IiwidmFsdWUiLCJfZXh0ZW5kcyIsImJpbmQiLCJ0YXJnZXQiLCJzb3VyY2UiLCJrZXkiLCJtZW1vaXplIiwiZm4iLCJjYWNoZSIsImNyZWF0ZSIsImFyZyIsInVuZGVmaW5lZCIsInJlYWN0UHJvcHNSZWdleCIsImlzUHJvcFZhbGlkIiwicHJvcCIsInRlc3QiLCJjaGFyQ29kZUF0Iiwic2hlZXRGb3JUYWciLCJ0YWciLCJzaGVldCIsImRvY3VtZW50Iiwic3R5bGVTaGVldHMiLCJvd25lck5vZGUiLCJjcmVhdGVTdHlsZUVsZW1lbnQiLCJvcHRpb25zIiwic2V0QXR0cmlidXRlIiwibm9uY2UiLCJhcHBlbmRDaGlsZCIsImNyZWF0ZVRleHROb2RlIiwiU3R5bGVTaGVldCIsIl90aGlzIiwiX2luc2VydFRhZyIsImJlZm9yZSIsInRhZ3MiLCJpbnNlcnRpb25Qb2ludCIsIm5leHRTaWJsaW5nIiwicHJlcGVuZCIsImNvbnRhaW5lciIsImZpcnN0Q2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJwdXNoIiwiaXNTcGVlZHkiLCJzcGVlZHkiLCJwcm9jZXNzIiwiY3RyIiwiX3Byb3RvIiwiaHlkcmF0ZSIsIm5vZGVzIiwiZm9yRWFjaCIsImluc2VydCIsInJ1bGUiLCJpc0ltcG9ydFJ1bGUiLCJfYWxyZWFkeUluc2VydGVkT3JkZXJJbnNlbnNpdGl2ZVJ1bGUiLCJjb25zb2xlIiwiZXJyb3IiLCJpbnNlcnRSdWxlIiwiY3NzUnVsZXMiLCJmbHVzaCIsInBhcmVudE5vZGUiLCJyZW1vdmVDaGlsZCIsIk1TIiwiTU9aIiwiV0VCS0lUIiwiQ09NTUVOVCIsIlJVTEVTRVQiLCJERUNMQVJBVElPTiIsIklNUE9SVCIsIktFWUZSQU1FUyIsImFicyIsIk1hdGgiLCJmcm9tIiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiaGFzaCQyIiwiY2hhcmF0IiwidHJpbSIsIm1hdGNoIiwicGF0dGVybiIsImV4ZWMiLCJyZXBsYWNlIiwicmVwbGFjZW1lbnQiLCJpbmRleG9mIiwic2VhcmNoIiwiaW5kZXgiLCJzdWJzdHIiLCJiZWdpbiIsImVuZCIsInNsaWNlIiwic3RybGVuIiwic2l6ZW9mIiwiYXBwZW5kIiwiYXJyYXkiLCJjb21iaW5lIiwiY2FsbGJhY2siLCJtYXAiLCJqb2luIiwibGluZSIsImNvbHVtbiIsInBvc2l0aW9uIiwiY2hhcmFjdGVyIiwiY2hhcmFjdGVycyIsIm5vZGUiLCJyb290IiwicGFyZW50IiwidHlwZSIsInByb3BzIiwiY2hpbGRyZW4iLCJyZXR1cm4iLCJjb3B5IiwiY2hhciIsInByZXYiLCJuZXh0IiwicGVlayIsImNhcmV0IiwidG9rZW4iLCJhbGxvYyIsImRlYWxsb2MiLCJkZWxpbWl0IiwiZGVsaW1pdGVyIiwid2hpdGVzcGFjZSIsImVzY2FwaW5nIiwiY291bnQiLCJjb21tZW50ZXIiLCJpZGVudGlmaWVyIiwiY29tcGlsZSIsInBhcnNlIiwicnVsZXMiLCJydWxlc2V0cyIsInBzZXVkbyIsInBvaW50cyIsImRlY2xhcmF0aW9ucyIsIm9mZnNldCIsImF0cnVsZSIsInByb3BlcnR5IiwicHJldmlvdXMiLCJ2YXJpYWJsZSIsInNjYW5uaW5nIiwiYW1wZXJzYW5kIiwicmVmZXJlbmNlIiwiY29tbWVudCIsImRlY2xhcmF0aW9uIiwicnVsZXNldCIsInBvc3QiLCJzaXplIiwiaiIsImsiLCJ4IiwieSIsInoiLCJzZXJpYWxpemUiLCJvdXRwdXQiLCJzdHJpbmdpZnkiLCJlbGVtZW50IiwibWlkZGxld2FyZSIsImNvbGxlY3Rpb24iLCJydWxlc2hlZXQiLCJ3ZWFrTWVtb2l6ZSIsImZ1bmMiLCJXZWFrTWFwIiwiaGFzIiwiZ2V0IiwicmV0Iiwic2V0IiwiaWRlbnRpZmllcldpdGhQb2ludFRyYWNraW5nIiwidG9SdWxlcyIsInBhcnNlZCIsImdldFJ1bGVzIiwiZml4ZWRFbGVtZW50cyIsImNvbXBhdCIsImlzSW1wbGljaXRSdWxlIiwicGFyZW50UnVsZXMiLCJyZW1vdmVMYWJlbCIsImlnbm9yZUZsYWciLCJpc0lnbm9yaW5nQ29tbWVudCIsImNyZWF0ZVVuc2FmZVNlbGVjdG9yc0FsYXJtIiwidW5zYWZlUHNldWRvQ2xhc3NlcyIsImlzTmVzdGVkIiwiY29tbWVudENvbnRhaW5lciIsInVuc2FmZVBzZXVkb0NsYXNzIiwic3BsaXQiLCJpc1ByZXBlbmRlZFdpdGhSZWd1bGFyUnVsZXMiLCJudWxsaWZ5RWxlbWVudCIsImluY29ycmVjdEltcG9ydEFsYXJtIiwicHJlZml4IiwicHJlZml4ZXIiLCJpc0Jyb3dzZXIkNSIsImdldFNlcnZlclN0eWxpc0NhY2hlIiwibmFtZSIsImRlZmF1bHRTdHlsaXNQbHVnaW5zIiwiY3JlYXRlQ2FjaGUiLCJFcnJvciIsInNzclN0eWxlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJBcnJheSIsImRhdGFFbW90aW9uQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwiaGVhZCIsInN0eWxpc1BsdWdpbnMiLCJpbnNlcnRlZCIsIm5vZGVzVG9IeWRyYXRlIiwiYXR0cmliIiwiX2luc2VydCIsIm9tbmlwcmVzZW50UGx1Z2lucyIsImN1cnJlbnRTaGVldCIsImZpbmFsaXppbmdQbHVnaW5zIiwic2VyaWFsaXplciIsImNvbmNhdCIsInN0eWxpcyIsInN0eWxlcyIsInNlbGVjdG9yIiwic2VyaWFsaXplZCIsInNob3VsZENhY2hlIiwiX2ZpbmFsaXppbmdQbHVnaW5zIiwiX3NlcmlhbGl6ZXIiLCJfc3R5bGlzIiwic2VydmVyU3R5bGlzQ2FjaGUiLCJyZWdpc3RlcmVkIiwiaXNCcm93c2VyJDQiLCJnZXRSZWdpc3RlcmVkU3R5bGVzJDEiLCJyZWdpc3RlcmVkU3R5bGVzIiwiY2xhc3NOYW1lcyIsInJhd0NsYXNzTmFtZSIsImNsYXNzTmFtZSIsInJlZ2lzdGVyU3R5bGVzJDEiLCJyZWdpc3RlclN0eWxlcyIsImlzU3RyaW5nVGFnIiwiaW5zZXJ0U3R5bGVzJDEiLCJpbnNlcnRTdHlsZXMiLCJzdHlsZXNGb3JTU1IiLCJjdXJyZW50IiwibWF5YmVTdHlsZXMiLCJtdXJtdXIyJDEiLCJzdHIiLCJoIiwibGVuIiwidG9TdHJpbmciLCJ1bml0bGVzc0tleXMkMSIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJtc0dyaWRSb3ciLCJtc0dyaWRSb3dTcGFuIiwibXNHcmlkQ29sdW1uIiwibXNHcmlkQ29sdW1uU3BhbiIsImZvbnRXZWlnaHQiLCJsaW5lSGVpZ2h0Iiwib3BhY2l0eSIsIm9yZGVyIiwib3JwaGFucyIsInRhYlNpemUiLCJ3aWRvd3MiLCJ6SW5kZXgiLCJ6b29tIiwiV2Via2l0TGluZUNsYW1wIiwiZmlsbE9wYWNpdHkiLCJmbG9vZE9wYWNpdHkiLCJzdG9wT3BhY2l0eSIsInN0cm9rZURhc2hhcnJheSIsInN0cm9rZURhc2hvZmZzZXQiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlT3BhY2l0eSIsInN0cm9rZVdpZHRoIiwiSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IkMiIsIlVOREVGSU5FRF9BU19PQkpFQ1RfS0VZX0VSUk9SJDEiLCJoeXBoZW5hdGVSZWdleCQxIiwiYW5pbWF0aW9uUmVnZXgkMSIsImlzQ3VzdG9tUHJvcGVydHkkMSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc1Byb2Nlc3NhYmxlVmFsdWUkMSIsImlzUHJvY2Vzc2FibGVWYWx1ZSIsInByb2Nlc3NTdHlsZU5hbWUkMSIsInN0eWxlTmFtZSIsInRvTG93ZXJDYXNlIiwicHJvY2Vzc1N0eWxlVmFsdWUkMSIsInByb2Nlc3NTdHlsZVZhbHVlIiwicDEiLCJwMiIsImN1cnNvciQxIiwiY29udGVudFZhbHVlUGF0dGVybiQxIiwiY29udGVudFZhbHVlcyQxIiwib2xkUHJvY2Vzc1N0eWxlVmFsdWUkMSIsIm1zUGF0dGVybiQxIiwiaHlwaGVuUGF0dGVybiQxIiwiaHlwaGVuYXRlZENhY2hlJDEiLCJjaGFyQXQiLCJwcm9jZXNzZWQiLCJfY2hhciIsInRvVXBwZXJDYXNlIiwibm9Db21wb25lbnRTZWxlY3Rvck1lc3NhZ2UkMSIsImhhbmRsZUludGVycG9sYXRpb24kMSIsIm1lcmdlZFByb3BzIiwiaW50ZXJwb2xhdGlvbiIsIl9fZW1vdGlvbl9zdHlsZXMiLCJhbmltIiwiY3JlYXRlU3RyaW5nRnJvbU9iamVjdCQxIiwicHJldmlvdXNDdXJzb3IiLCJyZXN1bHQiLCJtYXRjaGVkIiwicmVwbGFjZWQiLCJmYWtlVmFyTmFtZSIsImNhY2hlZCIsIm9iaiIsInN0cmluZyIsImlzQXJyYXkiLCJfa2V5IiwiX2kiLCJpbnRlcnBvbGF0ZWQiLCJsYWJlbFBhdHRlcm4kMSIsInNvdXJjZU1hcFBhdHRlcm4kMSIsInNlcmlhbGl6ZVN0eWxlcyQxIiwic2VyaWFsaXplU3R5bGVzIiwiYXJncyIsInN0cmluZ01vZGUiLCJzdHJpbmdzIiwic291cmNlTWFwIiwibGFzdEluZGV4IiwiaWRlbnRpZmllck5hbWUiLCJpc0Jyb3dzZXIkMyIsInN5bmNGYWxsYmFjayIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdEFsd2F5c1dpdGhTeW5jRmFsbGJhY2siLCJpc0Jyb3dzZXIkMiIsIkVtb3Rpb25DYWNoZUNvbnRleHQiLCJIVE1MRWxlbWVudCIsImRpc3BsYXlOYW1lIiwiUHJvdmlkZXIiLCJ3aXRoRW1vdGlvbkNhY2hlIiwicmVmIiwiVGhlbWVDb250ZXh0IiwidHlwZVByb3BOYW1lIiwibGFiZWxQcm9wTmFtZSIsIkluc2VydGlvbiQxIiwiSW5zZXJ0aW9uIiwiX3JlZiIsIl9yZWYyIiwic2VyaWFsaXplZE5hbWVzIiwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwiLCJfX2h0bWwiLCJFbW90aW9uIiwiY3NzUHJvcCIsImNzcyIsIldyYXBwZWRDb21wb25lbnQiLCJsYWJlbEZyb21TdGFjayIsIm5ld1Byb3BzIiwiaXNCcm93c2VyJDEiLCJnZXRSZWdpc3RlcmVkU3R5bGVzIiwibXVybXVyMiIsInVuaXRsZXNzS2V5cyIsIklMTEVHQUxfRVNDQVBFX1NFUVVFTkNFX0VSUk9SJDEiLCJVTkRFRklORURfQVNfT0JKRUNUX0tFWV9FUlJPUiIsImh5cGhlbmF0ZVJlZ2V4IiwiYW5pbWF0aW9uUmVnZXgiLCJwcm9jZXNzU3R5bGVOYW1lIiwiY3Vyc29yIiwiY29udGVudFZhbHVlUGF0dGVybiIsImNvbnRlbnRWYWx1ZXMiLCJvbGRQcm9jZXNzU3R5bGVWYWx1ZSIsIm1zUGF0dGVybiIsImh5cGhlblBhdHRlcm4iLCJoeXBoZW5hdGVkQ2FjaGUiLCJub0NvbXBvbmVudFNlbGVjdG9yTWVzc2FnZSIsImhhbmRsZUludGVycG9sYXRpb24iLCJjcmVhdGVTdHJpbmdGcm9tT2JqZWN0IiwibGFiZWxQYXR0ZXJuIiwic291cmNlTWFwUGF0dGVybiIsInRlc3RPbWl0UHJvcHNPblN0cmluZ1RhZyIsInRlc3RPbWl0UHJvcHNPbkNvbXBvbmVudCIsImdldERlZmF1bHRTaG91bGRGb3J3YXJkUHJvcCIsImNvbXBvc2VTaG91bGRGb3J3YXJkUHJvcHMiLCJpc1JlYWwiLCJzaG91bGRGb3J3YXJkUHJvcCIsIm9wdGlvbnNTaG91bGRGb3J3YXJkUHJvcCIsIl9fZW1vdGlvbl9mb3J3YXJkUHJvcCIsInByb3BOYW1lIiwiSUxMRUdBTF9FU0NBUEVfU0VRVUVOQ0VfRVJST1IiLCJpc0Jyb3dzZXIiLCJjcmVhdGVTdHlsZWQiLCJfX2Vtb3Rpb25fcmVhbCIsImJhc2VUYWciLCJfX2Vtb3Rpb25fYmFzZSIsInRhcmdldENsYXNzTmFtZSIsImxhYmVsIiwiZGVmYXVsdFNob3VsZEZvcndhcmRQcm9wIiwic2hvdWxkVXNlQXMiLCJTdHlsZWQiLCJGaW5hbFRhZyIsImFzIiwiY2xhc3NJbnRlcnBvbGF0aW9ucyIsInRoZW1lIiwiZmluYWxTaG91bGRGb3J3YXJkUHJvcCIsImRlZmF1bHRQcm9wcyIsIndpdGhDb21wb25lbnQiLCJuZXh0VGFnIiwibmV4dE9wdGlvbnMiLCJuZXdTdHlsZWQiLCJ0YWdOYW1lIiwiY2xhc3NuYW1lcyQxIiwiZXhwb3J0cyIsIm1vZHVsZSIsImhhc093biIsImNsYXNzZXMiLCJhcmdUeXBlIiwiaW5uZXIiLCJpbmNsdWRlcyIsImRlZmF1bHQiLCJ3aW5kb3ciLCJjbGFzc25hbWVzIiwiTGVnYWN5U2lkZWJhckNvbnRleHQiLCJTaWRlYmFyUHJvdmlkZXIiLCJfYSIsIl9iIiwidXNlU3RhdGUiLCJjb2xsYXBzZWQiLCJ0b2dnbGVkIiwiYnJva2VuIiwicnRsIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwic2lkZWJhclN0YXRlIiwic2V0U2lkZWJhclN0YXRlIiwidXBkYXRlU2lkZWJhclN0YXRlIiwidXNlQ2FsbGJhY2siLCJ2YWx1ZXMiLCJwcmV2U3RhdGUiLCJ1cGRhdGVDb2xsYXBzZVN0YXRlIiwiQm9vbGVhbiIsInVwZGF0ZVRvZ2dsZVN0YXRlIiwicHJvdmlkZXJWYWx1ZSIsInVzZU1lbW8iLCJ1c2VMZWdhY3lTaWRlYmFyIiwiY29udGV4dCIsInVzZU1lZGlhUXVlcnkiLCJicmVha3BvaW50IiwibWF0Y2hNZWRpYSIsIm1hdGNoZXMiLCJzZXRNYXRjaGVzIiwidXNlRWZmZWN0IiwibWVkaWFfMSIsImhhbmRsZU1hdGNoXzEiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNpZGViYXJDbGFzc2VzIiwiaW1hZ2UiLCJiYWNrZHJvcCIsIm1lbnVDbGFzc2VzIiwibWVudUl0ZW1Sb290Iiwic3ViTWVudVJvb3QiLCJidXR0b24iLCJzdWZmaXgiLCJpY29uIiwic3ViTWVudUNvbnRlbnQiLCJTdWJNZW51RXhwYW5kSWNvbiIsImRpc2FibGVkIiwiYWN0aXZlIiwib3BlbiIsIlN0eWxlZEJhY2tkcm9wIiwiZGl2IiwidGVtcGxhdGVPYmplY3RfMSRiIiwiQlJFQUtfUE9JTlRTIiwieHMiLCJzbSIsIm1kIiwibGciLCJ4bCIsInh4bCIsImFsd2F5cyIsImFsbCIsIlN0eWxlZFNpZGViYXIiLCJhc2lkZSIsInRlbXBsYXRlT2JqZWN0XzEkYSIsIndpZHRoIiwiY29sbGFwc2VkV2lkdGgiLCJyb290U3R5bGVzIiwiU3R5bGVkU2lkZWJhckNvbnRhaW5lciIsInRlbXBsYXRlT2JqZWN0XzIkMSIsImJhY2tncm91bmRDb2xvciIsIlN0eWxlZFNpZGViYXJJbWFnZSIsImltZyIsInRlbXBsYXRlT2JqZWN0XzMkMSIsIlNpZGViYXJDb250ZXh0IiwiU2lkZWJhciIsIm9uQmFja2Ryb3BDbGljayIsIm9uQnJlYWtQb2ludCIsIl9jIiwiX2QiLCJkZWZhdWx0Q29sbGFwc2VkIiwiYnJlYWtQb2ludCIsImN1c3RvbUJyZWFrUG9pbnQiLCJfZSIsIl9mIiwicmVzdCIsImdldEJyZWFrcG9pbnRWYWx1ZSIsIndhcm4iLCJicmVha3BvaW50Q2FsbGJhY2tGblJlZiIsInVzZVJlZiIsIl9nIiwibW91bnRlZCIsInNldE1vdW50ZWQiLCJsZWdhY3lTaWRlYmFyQ29udGV4dCIsImNvbGxhcHNlZFZhbHVlIiwidG9nZ2xlZFZhbHVlIiwiaGFuZGxlQmFja2Ryb3BDbGljayIsInNyYyIsImFsdCIsInJvbGUiLCJ0YWJJbmRleCIsIm9uQ2xpY2siLCJvbktleVByZXNzIiwiU3R5bGVkVWwiLCJ1bCIsInRlbXBsYXRlT2JqZWN0XzEkOSIsIlN0eWxlZE1lbnUiLCJuYXYiLCJ0ZW1wbGF0ZU9iamVjdF8xJDgiLCJNZW51Q29udGV4dCIsIkxldmVsQ29udGV4dCIsIk1lbnVGUiIsImNsb3NlT25DbGljayIsIm1lbnVJdGVtU3R5bGVzIiwicmVuZGVyRXhwYW5kSWNvbiIsIk1lbnUiLCJ1c2VNZW51IiwiU3R5bGVkU3ViTWVudUNvbnRlbnQiLCJ0ZW1wbGF0ZU9iamVjdF8xJDciLCJmaXJzdExldmVsIiwiZGVmYXVsdE9wZW4iLCJvcGVuV2hlbkNvbGxhcHNlZCIsIlN1Yk1lbnVDb250ZW50RlIiLCJkZWZhdWx0T3BlblN0YXRlIiwiU3ViTWVudUNvbnRlbnQiLCJTdHlsZWRNZW51TGFiZWwiLCJzcGFuIiwidGVtcGxhdGVPYmplY3RfMSQ2IiwiU3R5bGVkTWVudUljb24iLCJ0ZW1wbGF0ZU9iamVjdF8xJDUiLCJTdHlsZWRNZW51UHJlZml4IiwidGVtcGxhdGVPYmplY3RfMSQ0IiwiU3R5bGVkTWVudVN1ZmZpeCIsInRlbXBsYXRlT2JqZWN0XzEkMyIsIlN0eWxlZEV4cGFuZEljb25XcmFwcGVyIiwidGVtcGxhdGVPYmplY3RfMSQyIiwibGV2ZWwiLCJTdHlsZWRFeHBhbmRJY29uIiwidGVtcGxhdGVPYmplY3RfMiIsIlN0eWxlZEV4cGFuZEljb25Db2xsYXBzZWQiLCJ0ZW1wbGF0ZU9iamVjdF8zIiwidG9wIiwiYm90dG9tIiwicmlnaHQiLCJsZWZ0IiwiYXV0byIsImJhc2VQbGFjZW1lbnRzIiwic3RhcnQiLCJjbGlwcGluZ1BhcmVudHMiLCJ2aWV3cG9ydCIsInBvcHBlciIsInZhcmlhdGlvblBsYWNlbWVudHMiLCJyZWR1Y2UiLCJhY2MiLCJwbGFjZW1lbnQiLCJwbGFjZW1lbnRzIiwiYmVmb3JlUmVhZCIsInJlYWQiLCJhZnRlclJlYWQiLCJiZWZvcmVNYWluIiwibWFpbiIsImFmdGVyTWFpbiIsImJlZm9yZVdyaXRlIiwid3JpdGUiLCJhZnRlcldyaXRlIiwibW9kaWZpZXJQaGFzZXMiLCJnZXROb2RlTmFtZSIsIm5vZGVOYW1lIiwiZ2V0V2luZG93Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsIkVsZW1lbnQiLCJpc0hUTUxFbGVtZW50IiwiaXNTaGFkb3dSb290IiwiU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwic3RhdGUiLCJrZXlzIiwiZWxlbWVudHMiLCJzdHlsZSIsImF0dHJpYnV0ZXMiLCJyZW1vdmVBdHRyaWJ1dGUiLCJlZmZlY3QkMiIsImluaXRpYWxTdHlsZXMiLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiYXR0cmlidXRlIiwiYXBwbHlTdHlsZXMkMSIsImVuYWJsZWQiLCJwaGFzZSIsImVmZmVjdCIsInJlcXVpcmVzIiwiZ2V0QmFzZVBsYWNlbWVudCIsIm1heCIsIm1pbiIsInJvdW5kIiwiZ2V0VUFTdHJpbmciLCJ1YURhdGEiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJvZmZzZXRIZWlnaHQiLCJoZWlnaHQiLCJ2aXN1YWxWaWV3cG9ydCIsImFkZFZpc3VhbE9mZnNldHMiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiZ2V0TGF5b3V0UmVjdCIsImNvbnRhaW5zIiwiY2hpbGQiLCJyb290Tm9kZSIsImdldFJvb3ROb2RlIiwiaXNTYW1lTm9kZSIsImhvc3QiLCJnZXRDb21wdXRlZFN0eWxlIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZmlsdGVyIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWluJDEiLCJtYXgkMSIsIndpdGhpbk1heENsYW1wIiwidiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJlZmZlY3QkMSIsIl9vcHRpb25zJGVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYXJyb3ckMSIsInJlcXVpcmVzSWZFeGlzdHMiLCJnZXRWYXJpYXRpb24iLCJ1bnNldFNpZGVzIiwicm91bmRPZmZzZXRzQnlEUFIiLCJ3aW4iLCJkcHIiLCJkZXZpY2VQaXhlbFJhdGlvIiwibWFwVG9TdHlsZXMiLCJfT2JqZWN0JGFzc2lnbjIiLCJwb3BwZXJSZWN0IiwidmFyaWF0aW9uIiwib2Zmc2V0cyIsImdwdUFjY2VsZXJhdGlvbiIsImFkYXB0aXZlIiwicm91bmRPZmZzZXRzIiwiaXNGaXhlZCIsIl9vZmZzZXRzJHgiLCJfb2Zmc2V0cyR5IiwiX3JlZjMiLCJoYXNYIiwiaGFzWSIsInNpZGVYIiwic2lkZVkiLCJoZWlnaHRQcm9wIiwid2lkdGhQcm9wIiwib2Zmc2V0WSIsIm9mZnNldFgiLCJjb21tb25TdHlsZXMiLCJfcmVmNCIsIl9PYmplY3QkYXNzaWduIiwiY29tcHV0ZVN0eWxlcyIsIl9yZWY1IiwiX29wdGlvbnMkZ3B1QWNjZWxlcmF0IiwiX29wdGlvbnMkYWRhcHRpdmUiLCJfb3B0aW9ucyRyb3VuZE9mZnNldHMiLCJ0cmFuc2l0aW9uUHJvcGVydHkiLCJzb21lIiwiY29tcHV0ZVN0eWxlcyQxIiwiZGF0YSIsInBhc3NpdmUiLCJpbnN0YW5jZSIsIl9vcHRpb25zJHNjcm9sbCIsInNjcm9sbCIsIl9vcHRpb25zJHJlc2l6ZSIsInJlc2l6ZSIsInNjcm9sbFBhcmVudHMiLCJzY3JvbGxQYXJlbnQiLCJ1cGRhdGUiLCJldmVudExpc3RlbmVycyIsImhhc2gkMSIsImdldE9wcG9zaXRlUGxhY2VtZW50IiwiaGFzaCIsImdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50IiwiZ2V0V2luZG93U2Nyb2xsIiwic2Nyb2xsTGVmdCIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsVG9wIiwicGFnZVlPZmZzZXQiLCJnZXRXaW5kb3dTY3JvbGxCYXJYIiwiZ2V0Vmlld3BvcnRSZWN0IiwiaHRtbCIsImxheW91dFZpZXdwb3J0IiwiZ2V0RG9jdW1lbnRSZWN0IiwiX2VsZW1lbnQkb3duZXJEb2N1bWVuIiwid2luU2Nyb2xsIiwiYm9keSIsInNjcm9sbFdpZHRoIiwic2Nyb2xsSGVpZ2h0IiwiZGlyZWN0aW9uIiwiaXNTY3JvbGxQYXJlbnQiLCJfZ2V0Q29tcHV0ZWRTdHlsZSIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0U2Nyb2xsUGFyZW50IiwibGlzdFNjcm9sbFBhcmVudHMiLCJsaXN0IiwiaXNCb2R5IiwidXBkYXRlZExpc3QiLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkc3RyYXRlZ3kiLCJfb3B0aW9ucyRib3VuZGFyeSIsIl9vcHRpb25zJHJvb3RCb3VuZGFyeSIsIl9vcHRpb25zJGVsZW1lbnRDb250ZSIsImVsZW1lbnRDb250ZXh0IiwiX29wdGlvbnMkYWx0Qm91bmRhcnkiLCJhbHRCb3VuZGFyeSIsIl9vcHRpb25zJHBhZGRpbmciLCJhbHRDb250ZXh0IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiY29udGV4dEVsZW1lbnQiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm11bHRpcGx5IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImEiLCJiIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfc2tpcCIsIl9vcHRpb25zJG1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsIl9vcHRpb25zJGFsdEF4aXMiLCJhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicmVmZXJlbmNlUmVjdCIsImNoZWNrc01hcCIsIk1hcCIsIm1ha2VGYWxsYmFja0NoZWNrcyIsImZpcnN0Rml0dGluZ1BsYWNlbWVudCIsIl9iYXNlUGxhY2VtZW50IiwiaXNTdGFydFZhcmlhdGlvbiIsIm1haW5WYXJpYXRpb25TaWRlIiwiYWx0VmFyaWF0aW9uU2lkZSIsImNoZWNrcyIsImV2ZXJ5IiwiY2hlY2siLCJudW1iZXJPZkNoZWNrcyIsIl9sb29wIiwiZml0dGluZ1BsYWNlbWVudCIsImZpbmQiLCJfcmV0IiwicmVzZXQiLCJmbGlwJDEiLCJnZXRTaWRlT2Zmc2V0cyIsInByZXZlbnRlZE9mZnNldHMiLCJpc0FueVNpZGVGdWxseUNsaXBwZWQiLCJzaWRlIiwiaGlkZSIsInByZXZlbnRPdmVyZmxvdyIsInJlZmVyZW5jZU92ZXJmbG93IiwicG9wcGVyQWx0T3ZlcmZsb3ciLCJyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMiLCJwb3BwZXJFc2NhcGVPZmZzZXRzIiwiaXNSZWZlcmVuY2VIaWRkZW4iLCJoYXNQb3BwZXJFc2NhcGVkIiwiaGlkZSQxIiwiZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkiLCJpbnZlcnREaXN0YW5jZSIsInNraWRkaW5nIiwiZGlzdGFuY2UiLCJfb3B0aW9ucyRvZmZzZXQiLCJfZGF0YSRzdGF0ZSRwbGFjZW1lbnQiLCJvZmZzZXQkMSIsInBvcHBlck9mZnNldHMkMSIsImdldEFsdEF4aXMiLCJfb3B0aW9ucyR0ZXRoZXIiLCJ0ZXRoZXIiLCJfb3B0aW9ucyR0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXQiLCJ0ZXRoZXJPZmZzZXRWYWx1ZSIsIm5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSIsIm9mZnNldE1vZGlmaWVyU3RhdGUiLCJfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQiLCJtYWluU2lkZSIsImFsdFNpZGUiLCJhZGRpdGl2ZSIsIm1pbkxlbiIsIm1heExlbiIsImFycm93UGFkZGluZ09iamVjdCIsImFycm93UGFkZGluZ01pbiIsImFycm93UGFkZGluZ01heCIsImFycm93TGVuIiwibWluT2Zmc2V0IiwibWF4T2Zmc2V0IiwiY2xpZW50T2Zmc2V0Iiwib2Zmc2V0TW9kaWZpZXJWYWx1ZSIsInRldGhlck1pbiIsInRldGhlck1heCIsInByZXZlbnRlZE9mZnNldCIsIl9vZmZzZXRNb2RpZmllclN0YXRlJDIiLCJfbWFpblNpZGUiLCJfYWx0U2lkZSIsIl9vZmZzZXQiLCJfbGVuIiwiX21pbiIsIl9tYXgiLCJpc09yaWdpblNpZGUiLCJfb2Zmc2V0TW9kaWZpZXJWYWx1ZSIsIl90ZXRoZXJNaW4iLCJfdGV0aGVyTWF4IiwiX3ByZXZlbnRlZE9mZnNldCIsInByZXZlbnRPdmVyZmxvdyQxIiwiZ2V0SFRNTEVsZW1lbnRTY3JvbGwiLCJnZXROb2RlU2Nyb2xsIiwiaXNFbGVtZW50U2NhbGVkIiwiZ2V0Q29tcG9zaXRlUmVjdCIsImVsZW1lbnRPclZpcnR1YWxFbGVtZW50IiwiaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQiLCJvZmZzZXRQYXJlbnRJc1NjYWxlZCIsIm1vZGlmaWVycyIsInZpc2l0ZWQiLCJTZXQiLCJtb2RpZmllciIsImFkZCIsImRlcCIsImRlcE1vZGlmaWVyIiwib3JkZXJNb2RpZmllcnMiLCJvcmRlcmVkTW9kaWZpZXJzIiwiZGVib3VuY2UiLCJwZW5kaW5nIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiZm9ybWF0IiwiYyIsIklOVkFMSURfTU9ESUZJRVJfRVJST1IiLCJNSVNTSU5HX0RFUEVOREVOQ1lfRVJST1IiLCJWQUxJRF9QUk9QRVJUSUVTIiwidmFsaWRhdGVNb2RpZmllcnMiLCJzZWxmIiwicmVxdWlyZW1lbnQiLCJtb2QiLCJ1bmlxdWVCeSIsImFyciIsImlkZW50aWZpZXJzIiwibWVyZ2VCeU5hbWUiLCJtZXJnZWQiLCJleGlzdGluZyIsIklOVkFMSURfRUxFTUVOVF9FUlJPUiIsIklORklOSVRFX0xPT1BfRVJST1IiLCJERUZBVUxUX09QVElPTlMiLCJhcmVWYWxpZEVsZW1lbnRzIiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImVmZmVjdENsZWFudXBGbnMiLCJpc0Rlc3Ryb3llZCIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJmbGlwTW9kaWZpZXIiLCJtYXJnaW5Ub3AiLCJtYXJnaW5SaWdodCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJwYXJzZUZsb2F0IiwicnVuTW9kaWZpZXJFZmZlY3RzIiwiZm9yY2VVcGRhdGUiLCJfc3RhdGUkZWxlbWVudHMiLCJfX2RlYnVnX2xvb3BzX18iLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUiLCJfc3RhdGUkb3JkZXJlZE1vZGlmaWUyIiwiZGVzdHJveSIsIm9uRmlyc3RVcGRhdGUiLCJfcmVmMyRvcHRpb25zIiwiY2xlYW51cEZuIiwibm9vcEZuIiwidXNlUG9wcGVyIiwiYnV0dG9uUmVmIiwiY29udGVudFJlZiIsInBvcHBlckluc3RhbmNlUmVmIiwicm8iLCJSZXNpemVPYnNlcnZlciIsIm9ic2VydmUiLCJzZXRUaW1lb3V0IiwicG9wcGVySW5zdGFuY2UiLCJtZW51QnV0dG9uU3R5bGVzIiwiTWVudUJ1dHRvblJlZiIsImNvbXBvbmVudCIsImNsYXNzTmFtZVByb3AiLCJjbG9uZUVsZW1lbnQiLCJNZW51QnV0dG9uIiwiU3R5bGVkU3ViTWVudSIsImxpIiwidGVtcGxhdGVPYmplY3RfMSQxIiwiYnV0dG9uU3R5bGVzIiwiU3ViTWVudUZSIiwidGl0bGUiLCJvcGVuQ29udHJvbGxlZCIsIm9uT3BlbkNoYW5nZSIsIm9uS2V5VXAiLCJzaWRlYmFyVHJhbnNpdGlvbkR1cmF0aW9uIiwic2V0T3BlbiIsIl9oIiwic2V0T3BlbldoZW5Db2xsYXBzZWQiLCJfaiIsInRpbWVyIiwic2xpZGVVcCIsImRpc3BsYXkiLCJzbGlkZURvd24iLCJoYW5kbGVTbGlkZVRvZ2dsZSIsImNsZWFyVGltZW91dCIsIk51bWJlciIsIm9wZW5WYWx1ZSIsImhhbmRsZU9uQ2xpY2siLCJldmVudCIsImhhbmRsZU9uS2V5VXAiLCJnZXRTdWJNZW51SXRlbVN0eWxlcyIsInBhcmFtcyIsImlzU3VibWVudSIsInJvb3RFbFN0eWxlcyIsImJ1dHRvbkVsU3R5bGVzIiwibGFiZWxFbFN0eWxlcyIsImljb25FbFN0eWxlcyIsInByZWZpeEVsU3R5bGVzIiwic3VmZml4RWxTdHlsZXMiLCJzdWJNZW51Q29udGVudEVsU3R5bGVzIiwiU3ViTWVudUV4cGFuZEljb25FbFN0eWxlcyIsImhhbmRsZVRvZ2dsZVBvcHBlciIsImNsb3Nlc3QiLCJjbGFzc0xpc3QiLCJoYW5kbGVEb2N1bWVudENsaWNrIiwiaGFuZGxlRG9jdW1lbnRLZXlVcCIsInJlbW92ZUV2ZW50TGlzdGVuZXJzIiwic2hhcmVkQ2xhc3NlcyIsIlN1Yk1lbnUiLCJTdHlsZWRNZW51SXRlbSIsInRlbXBsYXRlT2JqZWN0XzEiLCJNZW51SXRlbUZSIiwiZ2V0TWVudUl0ZW1TdHlsZXMiLCJNZW51SXRlbSIsIlByb1NpZGViYXJQcm92aWRlciIsInVzZVByb1NpZGViYXIiLCJjb2xsYXBzZVNpZGViYXIiLCJ0b2dnbGVTaWRlYmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-pro-sidebar/dist/index.es.js\n");

/***/ })

};
;